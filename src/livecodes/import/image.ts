import { detectLanguage, getLanguageByAlias, getLanguageEditorId, languages } from '../languages';
import type { ContentConfig } from '../models';
import { blobToBase64, loadScript } from '../utils/utils';
import { metaPngUrl, tesseractUrl } from '../vendors';
import { importCompressedCode } from './code';
import { importProject } from './project-id';

let Tesseract:
  | {
      createWorker: (lang: string) => Promise<{
        recognize: (blob: Blob) => Promise<{ data: { text: string } }>;
        terminate: () => void;
      }>;
    }
  | undefined;

const ocr = async (image: Blob) => {
  Tesseract = Tesseract ?? (await import(tesseractUrl)).default;
  if (!Tesseract) return '';
  const worker = await Tesseract.createWorker('eng');
  const ret = await worker.recognize(image);
  worker.terminate();
  return ret.data.text;
};

/**
 * detect images created by LiveCodes "Code to Image" with share URL
 */
const getConfigFromShareUrl = (text: string, isShareUrl = false) => {
  const shareUrlPattern = /\?x=(id\/\S{11,20})/g;
  let projectId = [...text.matchAll(new RegExp(shareUrlPattern))].at(-1)?.[1];
  if (projectId) {
    projectId = projectId.replace(/]/g, 'j');
    const alphabet = '23456789abcdefghijkmnpqrstuvwxyz';
    if (
      projectId
        .slice('id/'.length)
        .split('')
        .every((c) => alphabet.includes(c))
    ) {
      return importProject(projectId);
    }
  }
  if (isShareUrl) {
    try {
      const url = new URL(text.trim());
      const code = decodeURIComponent(url.href.split('#config=')[1] || '');
      if (code) {
        return importCompressedCode(code);
      }
    } catch {
      //
    }
  }
  return null;
};

const cleanUpCode = async (code: string) => {
  if (!code?.trim()) return '';
  let lines = code.trim().split('\n');
  const [firstLine, ...rest] = lines;
  const lastLines = lines.slice(-2).join('\n');

  const config = await getConfigFromShareUrl(lastLines);
  if (config) return config;

  // remove first line if it contains window buttons
  const buttonCharacters = ['0', 'C', 'N', 'J', 'X', '(', ')', '[', ']', '|'];
  const charactersFound = firstLine
    .slice(0, 6)
    .split('')
    .filter((c) => buttonCharacters.includes(c)).length;
  const hasButtons = charactersFound > 2 || charactersFound / firstLine.length > 0.6;
  if (hasButtons) {
    code = rest.join('\n');
  }

  lines = code.trim().split('\n');

  // remove line numbers
  if (lines.filter((l) => l.match(/^[0-9]{1,4}\s?/)).length / lines.length > 0.3) {
    code = lines.map((l) => l.replace(/^\S{1,4}\s?/, '')).join('\n');
  }

  code = code.replace(/[‘’]/g, "'").replace(/[“”]/g, '"');
  return code;
};

export const importFromImage = async (blob: Blob): Promise<Partial<ContentConfig>> => {
  try {
    const metaPng: any = await loadScript(metaPngUrl, 'MetaPNG');
    const arrayBuffer = await blob.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    const livecodesUrl = metaPng.getMetadata(uint8Array, 'LiveCodes URL');
    if (livecodesUrl) {
      const config = await getConfigFromShareUrl(livecodesUrl, true);
      if (config) return config;
    }
  } catch {
    // not PNG or not generated by LiveCodes, continue
  }

  try {
    const text = await ocr(blob);
    const content = await cleanUpCode(text);
    if (content && typeof content === 'object') {
      // config from share url
      return content;
    }

    if (content.trim().length > 3) {
      const langs = languages.map((lang) => lang.name);
      const detected = await detectLanguage(content, langs);
      detected.language = getLanguageByAlias(detected.language) || detected.language;
      detected.secondBest = getLanguageByAlias(detected.secondBest) || detected.secondBest;
      // language name or filename with extension in image
      const langNamesInCode = languages
        .filter(
          (lang) =>
            content.search(new RegExp(`\\b${lang.name}\\b`, 'i')) !== -1 ||
            content.search(new RegExp(`\\b${lang.extensions[0]}\\b`, 'i')) !== -1,
        )
        .map((lang) => lang.name);
      const language =
        langNamesInCode.find(
          (lang) => lang === detected.language || lang === detected.secondBest,
        ) ??
        langNamesInCode[0] ??
        detected.language ??
        detected.secondBest ??
        'html';

      const editorId = getLanguageEditorId(language) ?? 'markup';
      return {
        activeEditor: editorId,
        [editorId]: {
          language,
          content,
        },
      };
    }
  } catch {
    //
  }

  // fallback
  return {
    markup: {
      language: 'html',
      content: `<img src="${await blobToBase64(blob)}" alt="image" />`,
    },
  };
};
