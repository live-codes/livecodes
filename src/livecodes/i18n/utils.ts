import { predefinedValues } from '../utils/utils';
import type { TagElement } from './models';

/**
 * Abstractify HTML string. Convert all tags to a format like `<0>`, `<1>`, etc.
 * @param html The HTML string to abstractify.
 * @returns The abstractified HTML string, with a list of objects of their tag names and attributes.
 */
export const abstractifyHTML = (html: string) => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  const elements: TagElement[] = [];
  let counter = 0;

  const replaceElement = (node: HTMLElement) => {
    if (node.nodeType !== Node.ELEMENT_NODE) return;

    node.childNodes.forEach((child) => {
      replaceElement(child as HTMLElement);
    });

    const name = node.tagName.toLowerCase();
    if (name === 'body') return;

    const attributes =
      node.attributes.length === 0
        ? undefined
        : Array.from(node.attributes).reduce(
            (acc, attr) => {
              acc[attr.name] = attr.value;
              return acc;
            },
            {} as Record<string, string>,
          );

    elements.push({ name, attributes });

    const newElement = doc.createElement(`tag-${counter}`);
    while (node.firstChild) {
      newElement.appendChild(node.firstChild);
    }

    // node.parentNode is always defined because we're traversing from the body
    node.parentNode!.replaceChild(newElement, node);

    counter++;
  };

  replaceElement(doc.body);

  // Make tag numbering consistent with Lokalise
  // Tag generated by `replaceElement` is in deep-first order, while Lokalise is left-to-right order
  let newCounter = 1;
  const closing: Array<{ from: RegExp; to: string }> = [];
  let htmlString = doc.body.innerHTML.replace(/tag-/g, '');
  const newElements: TagElement[] = [];
  htmlString = htmlString.replace(/<(\d+)>/g, (_, p1) => {
    newElements.push(elements[p1]);

    // Replace corresponding closing tag to a special tag, in order to avoid replaced tag being replaced again
    closing.push({ from: new RegExp(`</${p1}>`, 'g'), to: `<*/${newCounter}>` });

    return `<${newCounter++}>`;
  });
  closing.forEach(({ from, to }) => {
    htmlString = htmlString.replace(from, to);
  });
  htmlString = htmlString.replace(/<\*\//g, '</');

  return {
    html: htmlString,
    elements: newElements,
  };
};

/**
 * Reverse the abstractified HTML string back to the original HTML string.
 *
 * @param html The abstractified HTML string.
 * @param elements The list of objects of their tag names and attributes.
 * @returns The original HTML string.
 */
export const unabstractifyHTML = (html: string, elements: TagElement[], interpolation = {}) => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(
    html.replace(/<(\/?)(\d+)([^>]*)>/g, '<$1tag-$2$3>'),
    'text/html',
  );

  elements.forEach((element, index) => {
    const oldElement = doc.body.querySelector(`tag-${index + 1}`);
    const newElement = doc.createElement(element.name);

    // Copy previously saved attributes to newElement
    if (element.attributes) {
      Object.entries(element.attributes).forEach(([key, value]) => {
        newElement.setAttribute(key, value);
      });
    }

    // Override attributes base on those from abstract tags (oldElement)
    if (oldElement?.attributes) {
      Array.from(oldElement.attributes).forEach((attr) => {
        newElement.setAttribute(attr.name, attr.value);
      });
    }

    // Copy the children from oldElement to newElement
    while (oldElement?.firstChild) {
      newElement.appendChild(oldElement.firstChild);
    }

    oldElement?.replaceWith(newElement);
  });

  let unabstractifiedHTML = doc.body.innerHTML;
  for (const [original, replaced] of Object.entries({ ...interpolation, ...predefinedValues })) {
    unabstractifiedHTML = unabstractifiedHTML.replaceAll(`{{${original}}}`, replaced);
  }

  return unabstractifiedHTML;
};
