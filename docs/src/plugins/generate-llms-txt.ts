import fs from 'fs';
import path from 'path';
import sidebars from '../../sidebars';

export default function (
  context: {
    siteDir: string;
    siteConfig: { url: string; baseUrl: string; customFields?: { docsBaseUrl?: string } };
  },
  options: {
    title?: string;
    description?: string;
    exportIndividualFiles?: boolean;
    ignoreFiles?: Array<string | RegExp>;
    prependFiles?: string[];
  } = {},
) {
  const apiSidebarPath = '../../docs/api/typedoc-sidebar.cjs';
  const isDev = process.env.NODE_ENV === 'development';
  const docsDir = path.join(context.siteDir, 'docs');
  const staticDir = path.join(context.siteDir, 'static');
  const outputFile = path.join(staticDir, 'llms.txt');
  const outputFileFull = path.join(staticDir, 'llms-full.txt');
  const buildDir = path.resolve(context.siteDir, '../build');
  const baseUrl =
    context.siteConfig.customFields?.docsBaseUrl ||
    context.siteConfig.url + context.siteConfig.baseUrl;

  const files = [];

  const getFullPath = (relativePath: string) => path.resolve(docsDir, relativePath);

  const addFile = (filePath: string) => {
    if (
      options.ignoreFiles?.includes(filePath) ||
      options.ignoreFiles?.some(
        (pattern) => typeof pattern !== 'string' && new RegExp(pattern).test(filePath),
      ) ||
      path.basename(filePath).startsWith('_')
    ) {
      return;
    }
    filePath = getFullPath(filePath);
    if (fileExists(filePath + '.mdx')) {
      filePath = filePath + '.mdx';
      files.push(filePath);
    } else if (fileExists(filePath + '.md')) {
      filePath = filePath + '.md';
      files.push(filePath);
    } else if (fileExists(filePath)) {
      files.push(filePath);
    }
    if (options.exportIndividualFiles) {
      const relativePath = path.relative(docsDir, filePath);
      fs.mkdirSync(path.resolve(staticDir, path.dirname(relativePath)), { recursive: true });
      const content = fs.readFileSync(filePath, 'utf8');
      fs.writeFileSync(
        path.resolve(staticDir, relativePath).replace(/\.md(x)?/g, '.html.md'),
        cleanContent(content),
      );
    }
  };

  const fileExists = (filePath: string) => {
    filePath = getFullPath(filePath);
    return fs.existsSync(filePath);
  };

  const getDirFiles = (dirPath: string) => {
    dirPath = getFullPath(dirPath);
    return fs
      .readdirSync(dirPath)
      .filter((file) => file.endsWith('.md') || file.endsWith('.mdx'))
      .map((file) => dirPath + '/' + file);
  };

  const capitalize = (str: string) =>
    str
      .replace('livecodes', 'LiveCodes')
      .replace('sdk', 'SDK')
      .replace(/-/g, ' ')
      .split(' ')
      .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
      .join(' ');

  const processItem = (item: any) => {
    if (typeof item === 'string') {
      addFile(item);
      return;
    }
    if (item.type === 'category') {
      if (item.link?.type === 'doc') {
        addFile(item.link.id);
      }
      if (item.items) {
        item.items.forEach(processItem);
      }
      return;
    }
    if (item.type === 'doc') {
      addFile(item.id);
      return;
    }
    if (item.type === 'autogenerated' && item.dirName) {
      getDirFiles(item.dirName).forEach(addFile);
      return;
    }
  };

  function shouldIncludePage(content: string) {
    const metadataMatch = content.match(/^---([\s\S]*?)---/);
    if (metadataMatch) {
      const metadata = metadataMatch[1];
      const isDraft = /draft:\s*true/.test(metadata);
      const isHidden = /hidden:\s*true/.test(metadata) || /unlisted:\s*true/.test(metadata);

      if (isHidden) return false;
      if (isDraft) return isDev;
      return true;
    }
    return true;
  }

  function cleanContent(content: string) {
    return content
      .replace(/^---[\s\S]*?---\s*/, '')
      .replace(/\.md(x)\)?/g, '.html.md)')
      .trim();
  }

  async function generateContent() {
    if (!fs.existsSync(staticDir)) {
      fs.mkdirSync(staticDir, { recursive: true });
    }

    const contentArray = [];
    const fullContentArray = [];

    options.prependFiles?.forEach((file) => files.push(getFullPath(file)));
    Object.values(sidebars).forEach((sidebar) => {
      if (Array.isArray(sidebar)) {
        sidebar.forEach(processItem);
      } else {
        processItem(sidebar);
      }
    });
    try {
      const apiSidebar = await import(apiSidebarPath);
      apiSidebar.forEach(processItem);
    } catch {
      // eslint-disable-next-line no-console
      console.warn('Could not import api/typedoc-sidebar.cjs');
    }

    function generateContent() {
      const header = `# ${options.title}\n\n> ${options.description}\n\n`;
      let currentDir = null;

      files.forEach((item) => {
        const content = fs.readFileSync(item, 'utf8');
        if (shouldIncludePage(content)) {
          // add link to llms.txt
          const dirName = capitalize(path.basename(path.dirname(item)));
          const fileName = capitalize(path.basename(item.slice(0, -path.extname(item).length)));
          const relativePath = path.relative(docsDir, item);
          const fileNameWithPath = relativePath.includes('..')
            ? ''
            : relativePath.slice(0, -path.extname(relativePath).length).replace(/\\/g, '/');

          if (dirName !== currentDir && fileNameWithPath !== '') {
            currentDir = dirName;
            contentArray.push(`\n## ${dirName}\n\n`);
          }
          const titleMatch = content.match(new RegExp(/#\s*(.*)/));
          const title = titleMatch?.[1]?.replace('<wbr />', '').split(' {#')[0] ?? fileName;
          const extension = fileNameWithPath ? '.html.md' : '';
          const url = baseUrl + fileNameWithPath + extension;

          if (fileNameWithPath !== '') {
            contentArray.push(`- [${title}](${url})\n`);
          }

          // full content (llms-full.txt)
          fullContentArray.push(
            `<!-- Source: ${baseUrl}${fileNameWithPath} -->\n\n${cleanContent(content)}`,
          );
        }
      });
      fs.writeFileSync(outputFile, header + contentArray.join(''));
      if (fs.existsSync(buildDir)) {
        fs.copyFileSync(outputFile, path.join(buildDir, path.basename(outputFile)));
      }

      fs.writeFileSync(outputFileFull, header + fullContentArray.join('\n\n---\n\n'));
      if (fs.existsSync(buildDir)) {
        fs.copyFileSync(outputFileFull, path.join(buildDir, path.basename(outputFileFull)));
      }
    }

    generateContent();

    // eslint-disable-next-line no-console
    console.log(`Generated: llms.txt files`);
  }

  return {
    name: 'generate-llms-txt',

    // Expose the generate function through the plugin instance
    generateContent,

    async loadContent() {
      await generateContent();
    },

    async contentLoaded({ content, actions }) {
      //
    },

    // Add a CLI command to invoke the generation
    extendCli(cli) {
      cli
        .command('generate-llms-txt')
        .description('Generate the LLMs text file')
        .action(async () => {
          await generateContent();
        });
    },
  };
}
