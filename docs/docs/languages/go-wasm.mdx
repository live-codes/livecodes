# Go (Wasm)

[Go](https://go.dev/) (Golang), is an open-source, statically typed, and compiled programming language developed by Google. It is designed for simplicity, efficiency, and strong support for concurrency, making it well-suited for building scalable and high-performance applications.

LiveCodes uses [Yaegi](https://github.com/traefik/yaegi), the Go interpreter (running on WebAssembly), to run Go in the browser.

:::info Note

LiveCodes also supports running Go using [GopherJS](https://github.com/gopherjs/gopherjs) which is a Go to JavaScript compiler. Read documentation [here](./go.mdx).

:::

## Demo

import LiveCodes from '../../src/components/LiveCodes.tsx';

export const params = {
  'go-wasm': 'package main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.Println("Hello, World!")\n}\n',
  console: 'full',
};

<LiveCodes params={params}></LiveCodes>

## Usage

LiveCodes runs Go in the browser, including the [standard library](https://pkg.go.dev/std).


### Communication with JavaScript

The Go code runs in the context of the [result page](../features/result.mdx).
A few helper properties and methods are available in the browser global `livecodes.goWasm` object:

- `livecodes.goWasm.input`: the initial standard input that is passed to the Go code.
- `livecodes.goWasm.loaded`: A promise that resolves when the Go environment is loaded. Any other helpers should be used after this promise resolves.
- `livecodes.goWasm.output`: the standard output.
- `livecodes.goWasm.error`: the standard error.
- `livecodes.goWasm.exitCode`: the exit code.
- `livecodes.goWasm.run`: a function that runs the Go code with new input. This function takes a string as input and returns a promise that resolves when the Go code is done running. The promise resolves with an object containing the `input`, `output`, `error`, and `exitCode` properties.

See the [example below](#example-usage) for more details.

## Language Info

### Name

`go-wasm`

### Extensions

`wasm.go`, `go-wasm`, `gowasm`

### Editor

`script`

## Compiler

[Yaegi](https://github.com/traefik/yaegi), compiled to WebAssembly ([yaegi-wasm](https://www.npmjs.com/package/yaegi-wasm))

# Yaegi WebAssembly - Minimal Guide

Compile Yaegi Go interpreter to WebAssembly.

## Purpose of Wrapper

The wrapper is needed because:
- **Yaegi CLI** expects file system access and terminal I/O (won't work in browsers)
- **Custom wrapper** creates a JavaScript-accessible API using `syscall/js`
- **Bridges Go and JavaScript** by exposing functions like `window.yaegi.eval()`
- **Handles I/O properly** by capturing stdout/stderr for web environments

## Setup

```bash
mkdir yaegi-wasm && cd yaegi-wasm
go mod init yaegi-wasm
go get github.com/traefik/yaegi@latest
```

## Create Wrapper (`main.go`)

```go
package main

import (
    "bytes"
    "fmt"
    "io"
    "os"
    "syscall/js"
    "github.com/traefik/yaegi/interp"
    "github.com/traefik/yaegi/stdlib"
)

var interpreter *interp.Interpreter

func main() {
    c := make(chan struct{}, 0)
    
    global := js.Global()
    if global.Get("window").IsUndefined() {
        global.Set("window", global)
    }
    
    interpreter = interp.New(interp.Options{})
    interpreter.Use(stdlib.Symbols)
    
    global.Get("window").Set("yaegi", map[string]interface{}{
        "eval":  js.FuncOf(evalGo),
        "reset": js.FuncOf(resetInterpreter),
    })
    
    <-c
}

func evalGo(this js.Value, args []js.Value) interface{} {
    if len(args) != 1 {
        return map[string]interface{}{
            "success": false,
            "error":   "eval requires exactly one argument",
        }
    }
    
    sourceCode := args[0].String()
    
    // Capture stdout
    oldStdout := os.Stdout
    r, w, _ := os.Pipe()
    os.Stdout = w
    
    var outputBuffer bytes.Buffer
    done := make(chan bool)
    
    go func() {
        io.Copy(&outputBuffer, r)
        done <- true
    }()
    
    var evalError error
    func() {
        defer func() {
            if r := recover(); r != nil {
                evalError = fmt.Errorf("panic: %v", r)
            }
        }()
        _, evalError = interpreter.Eval(sourceCode)
    }()
    
    w.Close()
    os.Stdout = oldStdout
    <-done
    
    output := outputBuffer.String()
    
    if evalError != nil {
        return map[string]interface{}{
            "success": false,
            "error":   evalError.Error(),
            "output":  output,
        }
    }
    
    return map[string]interface{}{
        "success": true,
        "output":  output,
    }
}

func resetInterpreter(this js.Value, args []js.Value) interface{} {
    interpreter = interp.New(interp.Options{})
    interpreter.Use(stdlib.Symbols)
    return map[string]interface{}{"success": true}
}
```

## Build

```bash
export GOOS=js GOARCH=wasm
go build -o yaegi.wasm main.go
cp "$(go env GOROOT)/lib/wasm/wasm_exec.js" .
```


## File Structure

```
yaegi-wasm/
├── main.go
├── go.mod
├── go.sum
├── yaegi.wasm      (generated)
└── wasm_exec.js    (copied from Go)
```

## Notes

- WebAssembly file will be ~30-40MB (includes Go runtime)
- Must serve over HTTP, not file:// protocol


### Version

Yaegi v0.16.1, running go1.25.0

## Code Formatting

Using [GopherJS](https://github.com/gopherjs/gopherjs)

## Example Usage

This example demonstrates standard library usage and JavaScript interoperability (also check the code in the HTML editor):

<LiveCodes template="go-wasm" height="80vh"></LiveCodes>


## Live Reload

By default, new code changes are sent to the result page for re-evaluation without a full page reload, to avoid the need to reload the Go environment.

This behavior can be disabled by adding the code comment `// __livecodes_reload__` to the code, which will force a full page reload.
This comment can be added in the [`hiddenContent` property of the editor](../configuration/configuration-object.mdx#markup) for embedded playgrounds.

## Starter Template

https://livecodes.io/?template=go-wasm

## Links

- [Go](https://go.dev/)
- [Go documentation](https://go.dev/doc/)
- [Go standard library](https://pkg.go.dev/std)
- [Yaegi](https://github.com/traefik/yaegi)
- [Go using GopherJS](./go.mdx) in LiveCodes
