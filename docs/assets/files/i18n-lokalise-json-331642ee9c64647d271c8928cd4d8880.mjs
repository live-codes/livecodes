import e from"@babel/core";import r from"@babel/parser";import t from"fs";import s from"path";import{autoGeneratedWarning as o,sortedJSONify as l}from"./i18n-export.js";let a=(e,r="")=>Object.keys(e).reduce((t,s)=>{let o=e[s];return"object"==typeof o?{...t,...a(o,`${r}${s}.`)}:{...t,[`${r}${s}`]:o}},{}),n=e=>{if(!e)throw Error("Node is undefined or null");let r={};return e.properties.forEach(e=>{r[e.key.name||e.key.value]=i(e.value)}),r},i=e=>{switch(e.type){case"ObjectExpression":return n(e);case"ArrayExpression":return e.elements.map(i);case"StringLiteral":case"NumericLiteral":case"BooleanLiteral":return e.value;case"NullLiteral":return null;default:throw Error(`Unsupported node type: ${e.type}`)}},c=async i=>{let c=s.resolve("src/livecodes/i18n/locales/"+i);if(t.existsSync(c)){if("en"===i){console.warn("This script is not intended to be run for English language.\nPlease use `npm run i18n-export` instead.");return}}else{console.error(`Language ${c} does not exist.`);return}return Promise.all(t.readdirSync(c).filter(e=>e.endsWith(".ts")).map(e=>s.resolve(c,e)).map(async p=>{try{let u;console.log(`Generating Lokalise JSON for ${p} in language ${i}...`);let m=await t.promises.readFile(p,"utf8"),d=r.parse(m,{sourceType:"module",plugins:["typescript"]});e.traverse(d,{ObjectExpression(e){u=n(e.node),e.stop()}});let f={$comment:o.substring(3)};for(let[e,r]of Object.entries(a(u)))f[e]={translation:r};let y=s.resolve(c,p.replace(".ts",".lokalise.json"));await t.promises.writeFile(y,l(f).replace(/<(\/?)(\d+)>/g,"<$1tag-$2>"))}catch(e){console.error(e)}}))};(async()=>{let e=new Set(process.argv.slice(2));if(e.has("all")){e.delete("all");let r=s.resolve("src/livecodes/i18n/locales");t.readdirSync(r).filter(e=>t.statSync(s.resolve(r,e)).isDirectory()&&"en"!==e&&"tmp"!==e).forEach(r=>e.add(r))}await Promise.all([...e].map(c))})();