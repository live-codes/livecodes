import e from"fs";import r from"path";import t from"@babel/core";import s from"@babel/parser";import{autoGeneratedWarning as o,sortedJSONify as l}from"./i18n-export.js";let a=(e,r="")=>Object.keys(e).reduce((t,s)=>{let o=e[s];return"object"==typeof o?{...t,...a(o,`${r}${s}.`)}:{...t,[`${r}${s}`]:o}},{}),n=e=>{if(!e)throw Error("Node is undefined or null");let r={};return e.properties.forEach(e=>{r[e.key.name||e.key.value]=i(e.value)}),r},i=e=>{switch(e.type){case"ObjectExpression":return n(e);case"ArrayExpression":return e.elements.map(i);case"StringLiteral":case"NumericLiteral":case"BooleanLiteral":return e.value;case"NullLiteral":return null;default:throw Error(`Unsupported node type: ${e.type}`)}},c=async i=>{let c=r.resolve("src/livecodes/i18n/locales/"+i);if(e.existsSync(c)){if("en"===i){console.warn("This script is not intended to be run for English language.\nPlease use `npm run i18n-export` instead.");return}}else{console.error(`Language ${c} does not exist.`);return}return Promise.all(e.readdirSync(c).filter(e=>e.endsWith(".ts")).map(e=>r.resolve(c,e)).map(async p=>{try{let u;console.log(`Generating Lokalise JSON for ${p} in language ${i}...`);let m=await e.promises.readFile(p,"utf8"),d=s.parse(m,{sourceType:"module",plugins:["typescript"]});t.traverse(d,{ObjectExpression(e){u=n(e.node),e.stop()}});let f={$comment:o.substring(3)};for(let[e,r]of Object.entries(a(u)))f[e]={translation:r};let y=r.resolve(c,p.replace(".ts",".lokalise.json"));await e.promises.writeFile(y,l(f).replace(/<(\/?)(\d+)>/g,"<$1tag-$2>"))}catch(e){console.error(e)}}))};(async()=>{let t=new Set(process.argv.slice(2));if(t.has("all")){t.delete("all");let s=r.resolve("src/livecodes/i18n/locales");e.readdirSync(s).filter(t=>e.statSync(r.resolve(s,t)).isDirectory()&&"en"!==t&&"tmp"!==t).forEach(e=>t.add(e))}await Promise.all([...t].map(c))})();