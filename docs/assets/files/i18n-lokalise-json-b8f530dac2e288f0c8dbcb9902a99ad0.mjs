import e from"fs";import r from"path";import s from"@babel/core";import o from"@babel/parser";import{autoGeneratedWarning as t,sortedJSONify as n}from"./i18n-export.js";const a=(e,r="")=>Object.keys(e).reduce(((s,o)=>{const t=e[o];return"object"==typeof t?{...s,...a(t,`${r}${o}.`)}:{...s,[`${r}${o}`]:t}}),{}),i=e=>{if(!e)throw new Error("Node is undefined or null");const r={};return e.properties.forEach((e=>{const s=e.key.name||e.key.value;r[s]=l(e.value)})),r},l=e=>{switch(e.type){case"ObjectExpression":return i(e);case"ArrayExpression":return e.elements.map(l);case"StringLiteral":case"NumericLiteral":case"BooleanLiteral":return e.value;case"NullLiteral":return null;default:throw new Error(`Unsupported node type: ${e.type}`)}},c=async l=>{const c=r.resolve("src/livecodes/i18n/locales/"+l);if(!e.existsSync(c))return void console.error(`Language ${c} does not exist.`);if("en"===l)return void console.warn("This script is not intended to be run for English language.\nPlease use `npm run i18n-export` instead.");const p=e.readdirSync(c).filter((e=>e.endsWith(".ts"))).map((e=>r.resolve(c,e)));return Promise.all(p.map((async p=>{try{console.log(`Generating Lokalise JSON for ${p} in language ${l}...`);const u=await e.promises.readFile(p,"utf8"),d=o.parse(u,{sourceType:"module",plugins:["typescript"]});let m;s.traverse(d,{ObjectExpression(e){m=i(e.node),e.stop()}});const f={$comment:t.substring(3)};for(const[e,r]of Object.entries(a(m)))f[e]={translation:r};const y=r.resolve(c,p.replace(".ts",".lokalise.json"));await e.promises.writeFile(y,n(f).replace(/<(\/?)(\d+)>/g,"<$1tag-$2>"))}catch(u){console.error(u)}})))};(async()=>{const s=new Set(process.argv.slice(2));if(s.has("all")){s.delete("all");const o=r.resolve("src/livecodes/i18n/locales");e.readdirSync(o).filter((s=>e.statSync(r.resolve(o,s)).isDirectory()&&"en"!==s&&"tmp"!==s)).forEach((e=>s.add(e)))}await Promise.all([...s].map(c))})();