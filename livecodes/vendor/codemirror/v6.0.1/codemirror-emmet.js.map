{
  "version": 3,
  "sources": ["../../../../../src/livecodes/editor/codemirror/codemirror-emmet.ts", "../../../../../node_modules/@emmetio/emmet/node_modules/@emmetio/scanner/scanner.es.js", "../../../../../node_modules/@emmetio/emmet/node_modules/@emmetio/abbreviation/dist/abbreviation.es.js", "../../../../../node_modules/@emmetio/emmet/node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js", "../../../../../node_modules/@emmetio/emmet/dist/emmet.es.js", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/utils.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/context.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/syntax.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/emmet.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/config.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/output.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/tracker/AbbreviationPreviewWidget.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/completion-icon.svg", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/tracker/index.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/expand.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/balance.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/comment.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/node_modules/@emmetio/scanner/scanner.es.js", "../../../../../node_modules/@emmetio/codemirror6-plugin/node_modules/@emmetio/math-expression/dist/math.es.js", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/evaluate-math.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/go-to-edit-point.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/go-to-tag-pair.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/inc-dec-number.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/remove-tag.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/select-item.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/split-join-tag.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/wrap-with-abbreviation.ts"],
  "sourcesContent": ["import { keymap } from '@codemirror/view';\nimport {\n  abbreviationTracker,\n  expandAbbreviation,\n  enterAbbreviationMode,\n  balanceOutward,\n  toggleComment,\n  evaluateMath,\n  goToNextEditPoint,\n  goToPreviousEditPoint,\n  goToTagPair,\n  incrementNumber1,\n  decrementNumber1,\n  removeTag,\n  selectNextItem,\n  selectPreviousItem,\n  splitJoinTag,\n  wrapWithAbbreviation,\n} from '@emmetio/codemirror6-plugin';\n\nexport const emmet = [\n  abbreviationTracker(),\n  wrapWithAbbreviation(),\n  keymap.of([\n    {\n      key: 'Cmd-e',\n      run: expandAbbreviation,\n    },\n    {\n      key: 'Cmd-Shift-e',\n      run: enterAbbreviationMode,\n    },\n    {\n      key: 'Cmd-Shift-d',\n      run: balanceOutward,\n    },\n    {\n      key: 'Ctrl-/',\n      run: toggleComment,\n    },\n    {\n      key: 'Ctrl-y',\n      run: evaluateMath,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowLeft',\n      run: goToPreviousEditPoint,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowRight',\n      run: goToNextEditPoint,\n    },\n    {\n      key: 'Ctrl-g',\n      run: goToTagPair,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowUp',\n      run: incrementNumber1,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowDown',\n      run: decrementNumber1,\n    },\n    {\n      key: \"Ctrl-'\",\n      run: removeTag,\n    },\n    {\n      key: \"Ctrl-Shift-'\",\n      run: splitJoinTag,\n    },\n    {\n      key: 'Ctrl-.',\n      run: selectNextItem,\n    },\n    {\n      key: 'Ctrl-,',\n      run: selectPreviousItem,\n    },\n  ]),\n];\n", "const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n", "import Scanner, { isAlphaNumericWord, isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        node.attributes = [{ name: 'href', value: [href], valueType: 'doubleQuote' }];\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n", "import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { getToken, parser, tokenize };\n", "import parse$2 from '@emmetio/abbreviation';\nexport { default as markupAbbreviation } from '@emmetio/abbreviation';\nimport parse$3 from '@emmetio/css-abbreviation';\nexport { default as stylesheetAbbreviation } from '@emmetio/css-abbreviation';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parse$2(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parse$2(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$3(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$3(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nexport default expandAbbreviation;\nexport { extractAbbreviation as extract, markup, parse as parseMarkup, parse$1 as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet };\n//# sourceMappingURL=emmet.es.js.map\n", "import type { EditorState } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { RangeObject } from './types';\n\n/** Characters to indicate tab stop start and end in generated snippet */\nexport const tabStopStart = String.fromCodePoint(0xFFF0);\nexport const tabStopEnd = String.fromCodePoint(0xFFF1);\nexport const stateKey = '$$emmet';\n\nexport interface AbbrError {\n    message: string,\n    pos: number\n}\n\nexport type DisposeFn = () => void;\n\nexport interface EmmetState {\n    id: string;\n    tracker?: DisposeFn | null;\n    tagMatch?: DisposeFn | null;\n}\n\n/**\n * Returns copy of region which starts and ends at non-space character\n */\nexport function narrowToNonSpace(state: EditorState, range: RangeObject): RangeObject {\n\n    const text = substr(state, range);\n    let startOffset = 0;\n    let endOffset = text.length;\n\n    while (startOffset < endOffset && isSpace(text[startOffset])) {\n        startOffset++;\n    }\n\n    while (endOffset > startOffset && isSpace(text[endOffset - 1])) {\n        endOffset--;\n    }\n\n    return {\n        from: range.from + startOffset,\n        to: range.from + endOffset\n    };\n}\n\n/**\n * Returns current caret position for single selection\n */\nexport function getCaret(state: EditorState): number {\n    return state.selection.main.from;\n}\n\n/**\n * Returns contents of given range or node\n */\nexport function substr(state: EditorState, range: RangeObject): string {\n    return state.doc.sliceString(range.from, range.to);\n}\n\n/**\n * Check if given range or syntax name contains given position\n */\nexport function contains(range: RangeObject, pos: number): boolean {\n    return pos >= range.from && pos <= range.to;\n}\n\n/**\n * Returns range of full CSS declaration\n */\nexport function fullCSSDeclarationRange(node: SyntaxNode): RangeObject {\n    return {\n        from: node.from,\n        to: node.nextSibling?.name === ';' ? node.nextSibling.to : node.to\n    };\n}\n\nexport function isQuote(ch: string | undefined) {\n    return ch === '\"' || ch === \"'\";\n}\n\n/**\n * Returns own (unquoted) attribute value range\n */\nexport function getAttributeValueRange(state: EditorState, node: RangeObject): RangeObject {\n    let { from, to } = node;\n    const value = substr(state, node);\n    if (isQuote(value[0])) {\n        from++;\n    }\n\n    if (isQuote(value[value.length - 1])) {\n        to--;\n    }\n\n    return { from, to };\n}\n\n/**\n * Returns given HTML element’s attributes as map\n */\nexport function getTagAttributes(state: EditorState, node: SyntaxNode): Record<string, string | null> {\n    const result: Record<string, string | null> = {};\n    for (const attr of node.getChildren('Attribute')) {\n        const attrNameNode = attr.getChild('AttributeName');\n        if (attrNameNode) {\n            const attrName = substr(state, attrNameNode);\n            const attrValueNode = attr.getChild('AttributeValue');\n            result[attrName] = attrValueNode ? substr(state, getAttributeValueRange(state, attrValueNode)) : null;\n        }\n    }\n\n    return result;\n}\nexport function isSpace(ch: string): boolean {\n    return /^[\\s\\n\\r]+$/.test(ch);\n}\n\nexport function htmlEscape(str: string): string {\n    const replaceMap: Record<string, string> = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n    };\n    return str.replace(/[<>&]/g, ch => replaceMap[ch]);\n}\n\n/**\n * Check if `a` and `b` contains the same range\n */\nexport function rangesEqual(a: RangeObject, b: RangeObject): boolean {\n    return a.from === b.from && a.to === b.to;\n}\n\n/**\n * Check if range `a` fully contains range `b`\n */\nexport function rangeContains(a: RangeObject, b: RangeObject): boolean {\n    return a.from <= b.from && a.to >= b.to;\n}\n\n/**\n * Check if given range is empty\n */\nexport function rangeEmpty(r: RangeObject): boolean {\n    return r.from === r.to;\n}\n\n/**\n * Returns last element in given array\n */\nexport function last<T>(arr: T[]): T | undefined {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * Finds and collects selections ranges from given snippet\n */\nexport function getSelectionsFromSnippet(snippet: string, base = 0): { ranges: RangeObject[], snippet: string } {\n    // Find and collect selection ranges from snippet\n    const ranges: RangeObject[] = [];\n    let result = '';\n    let sel: RangeObject | null = null;\n    let offset = 0;\n    let i = 0;\n    let ch: string;\n\n    while (i < snippet.length) {\n        ch = snippet.charAt(i++);\n        if (ch === tabStopStart || ch === tabStopEnd) {\n            result += snippet.slice(offset, i - 1);\n            offset = i;\n\n            if (ch === tabStopStart) {\n                sel = {\n                    from: base + result.length,\n                    to: base + result.length\n                };\n                ranges.push(sel);\n            } else if (sel) {\n                sel = null;\n            }\n        }\n    }\n\n    if (!ranges.length) {\n        ranges.push({\n            from: snippet.length + base,\n            to: snippet.length + base\n        });\n    }\n\n    return {\n        ranges,\n        snippet: result + snippet.slice(offset)\n    };\n}\n", "import { syntaxTree } from '@codemirror/language';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { EditorState } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { CSSContext, CSSMatch, HTMLAncestor, HTMLContext, HTMLType, RangeObject } from './types';\nimport { contains, getAttributeValueRange, substr } from './utils';\n\n// TODO use RangeObject instead of TextRange\n\ninterface InlineProp {\n    name: RangeObject;\n    value?: RangeObject;\n}\n\nconst nodeToHTMLType: Record<string, HTMLType> = {\n    OpenTag: 'open',\n    CloseTag: 'close',\n    SelfClosingTag: 'selfClose'\n};\n\nexport function getContext(state: EditorState, pos: number): HTMLContext | CSSContext | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSContext(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLContext(state, pos);\n    }\n\n    // const topLang = state.facet(language);\n    // if (topLang === htmlLanguage) {\n    //     // HTML syntax may embed CSS\n    //     return cssLanguage.isActiveAt(state, pos)\n    //         ? getCSSContext(state, pos)\n    //         : getHTMLContext(state, pos);\n    // }\n\n    // if (topLang === cssLanguage) {\n    //     return getCSSContext(state, pos);\n    // }\n\n    return;\n}\n\n/**\n * Returns CSS context for given location in source code\n */\nexport function getCSSContext(state: EditorState, pos: number, embedded?: RangeObject) {\n    const result: CSSContext = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: false,\n        embedded\n    };\n\n    const tree = syntaxTree(state).resolveInner(pos, -1);\n    const stack: CSSMatch[] = [];\n\n    for (let node: SyntaxNode | null = tree; node; node = node.parent) {\n        if (node.name === 'RuleSet') {\n            const sel = getSelectorRange(node);\n            stack.push({\n                name: substr(state, sel),\n                type: 'selector',\n                range: node\n            });\n        } else if (node.name === 'Declaration') {\n            const { name, value } = getPropertyRanges(node);\n            if (value && contains(value, pos)) {\n                // Direct hit on CSS value\n                stack.push({\n                    name: substr(state, value),\n                    type: 'propertyValue',\n                    range: value\n                });\n            }\n\n            if (name) {\n                stack.push({\n                    name: substr(state, name),\n                    type: 'propertyName',\n                    range: name\n                });\n            }\n        }\n    }\n\n    const tip = stack.shift();\n\n    // Check if stack tip contains current position: make it current\n    // context item if so\n    if (tip) {\n        const range: RangeObject = tip.type === 'selector'\n            ? { from: tip.range.from, to: tip.range.from + tip.name.length }\n            : tip.range;\n        if (contains(range, pos)) {\n            result.current = tip;\n            tip.range = range;\n        } else {\n            stack.unshift(tip);\n        }\n    }\n\n    result.ancestors = stack.reverse()\n    return result;\n}\n\nexport function getHTMLContext(state: EditorState, pos: number): HTMLContext {\n    const result: HTMLContext = {\n        type: 'html',\n        ancestors: [],\n        current: null,\n    };\n\n    const tree = syntaxTree(state).resolveInner(pos);\n\n    for (let node: SyntaxNode | null = tree; node; node = node ? node.parent : null) {\n        if (node.name in nodeToHTMLType) {\n            const m = getContextMatchFromTag(state, node);\n            if (m) {\n                result.current = {\n                    ...m,\n                    type: nodeToHTMLType[node.name]\n                };\n\n                // Skip `Element` parent from ancestors stack\n                node = node.parent;\n            }\n        } else if (node.name === 'Element') {\n            const child = node.getChild('OpenTag');\n            if (child) {\n                const m = getContextMatchFromTag(state, child);\n                if (m) {\n                    result.ancestors.push(m);\n                }\n            }\n        }\n    }\n\n    result.ancestors.reverse();\n    detectCSSContextFromHTML(state, pos, result);\n    return result;\n}\n\nfunction detectCSSContextFromHTML(state: EditorState, pos: number, ctx: HTMLContext) {\n    if (ctx.current?.type === 'open') {\n        // Maybe inline CSS? E.g. style=\"...\" attribute\n        let node: SyntaxNode | null = syntaxTree(state).resolve(ctx.current.range.from, 1);\n        while (node && node.name !== 'OpenTag') {\n            node = node.parent;\n        }\n\n        if (node) {\n            for (const attr of node.getChildren('Attribute')) {\n                if (attr.from > pos) {\n                    break;\n                }\n\n                if (contains(attr, pos) && getAttributeName(state, attr) === 'style') {\n                    const attrValue = attr.getChild('AttributeValue');\n                    if (attrValue) {\n                        const cleanValueRange = getAttributeValueRange(state, attrValue);\n                        if (contains(cleanValueRange, pos)) {\n                            ctx.css = getInlineCSSContext(substr(state, cleanValueRange), pos - cleanValueRange.from, cleanValueRange.from);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction getContextMatchFromTag(state: EditorState, node: SyntaxNode): HTMLAncestor | void {\n    const tagName = node.getChild('TagName');\n    if (tagName) {\n        return {\n            name: substr(state, tagName).toLowerCase(),\n            range: node\n        };\n    }\n}\n\n/**\n * Returns range of CSS selector from given rule block\n */\nexport function getSelectorRange(node: SyntaxNode): RangeObject {\n    let from = node.from;\n    let to = from;\n    for (let child = node.firstChild; child && child.name !== 'Block'; child = child.nextSibling) {\n        to = child.to;\n    }\n\n    return { from, to };\n}\n\n/**\n * Returns CSS property name and value ranges.\n * @param node The `name: Declaration` node\n */\nexport function getPropertyRanges(node: SyntaxNode): { name: RangeObject | undefined, value: RangeObject | undefined } {\n    let name: RangeObject | undefined;\n    let value: RangeObject | undefined;\n    let ptr = node.firstChild;\n    if (ptr?.name === 'PropertyName') {\n        name = ptr;\n        ptr = ptr.nextSibling;\n        if (ptr?.name === ':') {\n            ptr = ptr.nextSibling;\n        }\n\n        if (ptr) {\n            value = {\n                from: ptr.from,\n                to: node.lastChild!.to\n            };\n        }\n    }\n\n    return { name, value };\n}\n\nfunction getAttributeName(state: EditorState, node: SyntaxNode): string {\n    const name = node.getChild('AttributeName');\n    return name ? substr(state, name).toLowerCase() : '';\n}\n\n/**\n * Returns context for inline CSS\n */\nexport function getInlineCSSContext(code: string, pos: number, base = 0): CSSContext {\n    // Currently, CodeMirror doesn’t provide syntax highlighting so we’ll perform\n    // quick and naive persing of CSS properties\n    const result: CSSContext = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: true,\n        embedded: {\n            from: pos + base,\n            to: pos + base + code.length\n        }\n    };\n\n    const props = parseInlineProps(code, pos);\n\n    for (const prop of props) {\n        if (prop.value && contains(prop.value, pos)) {\n            result.current = {\n                name: code.substring(prop.value.from, prop.value.to).trim(),\n                type: 'propertyValue',\n                range: {\n                    from: base + prop.value.from,\n                    to: base + prop.value.to\n                }\n            };\n            result.ancestors.push({\n                name: code.substring(prop.name.from, prop.name.to).trim(),\n                type: 'propertyName',\n                range: {\n                    from: base + prop.name.from,\n                    to: base + prop.value.to\n                }\n            });\n            break;\n        } else if (contains(prop.name, pos)) {\n            const end = prop.value ? prop.value.to : prop.name.to;\n            result.current = {\n                name: code.substring(prop.name.from, prop.name.to).trim(),\n                type: 'propertyName',\n                range: {\n                    from: base + prop.name.from,\n                    to: base + end\n                }\n            };\n            break;\n        }\n    }\n\n    return result;\n}\n\nexport function parseInlineProps(code: string, limit = code.length): InlineProp[] {\n    const space = ' \\t\\n\\r';\n    const propList: InlineProp[] = [];\n    let prop: InlineProp | undefined;\n\n    for (let i = 0; i < code.length; i++) {\n        const ch = code[i];\n        if (prop) {\n            if (prop.value) {\n                if (prop.value.from !== -1) {\n                    prop.value.to = i;\n                }\n            } else {\n                prop.name.to = i;\n            }\n        }\n\n        if (ch === ';') {\n            prop = undefined;\n            if (i > limit) {\n                break;\n            }\n        } else if (ch === ':') {\n            if (prop && !prop.value) {\n                prop.value = { from: -1, to: -1 };\n            }\n        } else {\n            if (prop) {\n                if (prop.value?.from === -1 && !space.includes(ch)) {\n                    prop.value.from = prop.value.to = i;\n                }\n            } else if (!space.includes(ch)) {\n                prop = {\n                    name: { from: i, to: i }\n                };\n                propList.push(prop);\n            }\n        }\n    }\n\n    // Finalize state for trailing character\n    if (prop) {\n        if (prop.value) {\n            prop.value.to++;\n        } else {\n            prop.name.to++;\n        }\n    }\n\n    return propList;\n}\n", "import type { SyntaxType, AbbreviationContext } from 'emmet';\nimport type { EditorState } from '@codemirror/state';\nimport { language, syntaxTree } from '@codemirror/language';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { SyntaxNode } from '@lezer/common';\nimport { getContext } from './context';\nimport type { HTMLContext, CSSContext } from './types';\nimport { last, getTagAttributes } from './utils';\n\nconst xmlSyntaxes = ['xml', 'xsl', 'jsx'];\nconst htmlSyntaxes = ['html', 'htmlmixed', 'vue'];\nconst cssSyntaxes = ['css', 'scss', 'less'];\nconst jsxSyntaxes = ['jsx', 'tsx'];\nconst markupSyntaxes = ['haml', 'jade', 'pug', 'slim'].concat(htmlSyntaxes, xmlSyntaxes, jsxSyntaxes);\nconst stylesheetSyntaxes = ['sass', 'sss', 'stylus', 'postcss'].concat(cssSyntaxes);\n\nexport interface SyntaxInfo {\n    type: SyntaxType;\n    syntax?: string;\n    inline?: boolean;\n    context?: HTMLContext | CSSContext;\n}\n\nexport interface StylesheetRegion {\n    range: [number, number];\n    syntax: string;\n    inline?: boolean;\n}\n\nexport interface SyntaxCache {\n    stylesheetRegions?: StylesheetRegion[];\n}\n\nconst enum TokenType {\n    Selector = \"selector\",\n    PropertyName = \"propertyName\",\n    PropertyValue = \"propertyValue\",\n    BlockEnd = \"blockEnd\"\n}\n\nconst enum CSSAbbreviationScope {\n    /** Include all possible snippets in match */\n    Global = \"@@global\",\n    /** Include raw snippets only (e.g. no properties) in abbreviation match */\n    Section = \"@@section\",\n    /** Include properties only in abbreviation match */\n    Property = \"@@property\",\n    /** Resolve abbreviation in context of CSS property value */\n    Value = \"@@value\"\n}\n\n/**\n * Returns Emmet syntax info for given location in view.\n * Syntax info is an abbreviation type (either 'markup' or 'stylesheet') and syntax\n * name, which is used to apply syntax-specific options for output.\n *\n * By default, if given location doesn’t match any known context, this method\n * returns `null`, but if `fallback` argument is provided, it returns data for\n * given fallback syntax\n */\nexport function syntaxInfo(state: EditorState, ctx?: number | HTMLContext | CSSContext): SyntaxInfo {\n    let syntax = docSyntax(state);\n    let inline: boolean | undefined;\n    let context = typeof ctx === 'number' ? getContext(state, ctx) : ctx;\n\n    if (context?.type === 'html' && context.css) {\n        inline = true;\n        syntax = 'css';\n        context = context.css;\n    } else if (context?.type === 'css') {\n        syntax = 'css';\n    }\n\n    return {\n        type: getSyntaxType(syntax),\n        syntax,\n        inline,\n        context\n    };\n}\n\n/**\n * Returns main editor syntax\n */\nexport function docSyntax(state: EditorState): string {\n    const topLang = state.facet(language);\n    if (topLang === cssLanguage) {\n        return 'css';\n    }\n\n    if (topLang === htmlLanguage) {\n        return 'html';\n    }\n    return '';\n}\n\n/**\n * Returns Emmet abbreviation type for given syntax\n */\nexport function getSyntaxType(syntax?: string): SyntaxType {\n    return syntax && stylesheetSyntaxes.includes(syntax) ? 'stylesheet' : 'markup';\n}\n\n/**\n * Check if given syntax is XML dialect\n */\nexport function isXML(syntax?: string): boolean {\n    return syntax ? xmlSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is HTML dialect (including XML)\n */\nexport function isHTML(syntax?: string): boolean {\n    return syntax\n        ? htmlSyntaxes.includes(syntax) || isXML(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax name is supported by Emmet\n */\nexport function isSupported(syntax: string): boolean {\n    return syntax\n        ? markupSyntaxes.includes(syntax) || stylesheetSyntaxes.includes(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax is a CSS dialect. Note that it’s not the same as stylesheet\n * syntax: for example, SASS is a stylesheet but not CSS dialect (but SCSS is)\n */\nexport function isCSS(syntax?: string): boolean {\n    return syntax ? cssSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is JSX dialect\n */\nexport function isJSX(syntax?: string): boolean {\n    return syntax ? jsxSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nexport function getMarkupAbbreviationContext(state: EditorState, ctx: HTMLContext): AbbreviationContext | undefined {\n    const parent = last(ctx.ancestors);\n    if (parent) {\n        let node: SyntaxNode | null = syntaxTree(state).resolve(parent.range.from, 1);\n        while (node && node.name !== 'OpenTag') {\n            node = node.parent;\n        }\n\n        return {\n            name: parent.name,\n            attributes: node ? getTagAttributes(state, node) : {}\n        };\n    }\n\n    return;\n}\n\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nexport function getStylesheetAbbreviationContext(ctx: CSSContext): AbbreviationContext {\n    if (ctx.inline) {\n        return { name: CSSAbbreviationScope.Property }\n    }\n\n    const parent = last(ctx.ancestors);\n    let scope: string = CSSAbbreviationScope.Global;\n    if (ctx.current) {\n        if (ctx.current.type === TokenType.PropertyValue && parent) {\n            scope = parent.name;\n        } else if ((ctx.current.type === TokenType.Selector || ctx.current.type === TokenType.PropertyName) && !parent) {\n            scope = CSSAbbreviationScope.Section;\n        }\n    } else if (!parent) {\n        scope = CSSAbbreviationScope.Section;\n    }\n\n    return {\n        name: scope\n    };\n}\n", "import type { EditorState } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport type { SyntaxNode } from '@lezer/common';\nimport expandAbbreviation, { extract as extractAbbreviation, resolveConfig } from 'emmet';\nimport type { UserConfig, AbbreviationContext, ExtractedAbbreviation, Options, ExtractOptions, MarkupAbbreviation, StylesheetAbbreviation, SyntaxType } from 'emmet';\nimport { syntaxInfo, getMarkupAbbreviationContext, getStylesheetAbbreviationContext } from './syntax';\nimport { getTagAttributes, substr } from './utils';\nimport getEmmetConfig from './config';\nimport getOutputOptions, { field } from './output';\nimport type { ContextTag } from './types';\n\nexport interface ExtractedAbbreviationWithContext extends ExtractedAbbreviation {\n    context?: AbbreviationContext;\n    inline?: boolean;\n}\n\n/**\n * Cache for storing internal Emmet data.\n * TODO reset whenever user settings are changed\n */\nlet cache = {};\n\nexport const JSX_PREFIX = '<';\n\n/**\n * Expands given abbreviation into code snippet\n */\nexport function expand(state: EditorState, abbr: string | MarkupAbbreviation | StylesheetAbbreviation, config?: UserConfig) {\n    let opt: UserConfig = { cache };\n    const outputOpt: Partial<Options> = {\n        'output.field': field,\n    };\n\n    if (config) {\n        Object.assign(opt, config);\n        if (config.options) {\n            Object.assign(outputOpt, config.options);\n        }\n    }\n\n    opt.options = outputOpt;\n\n    const pluginConfig = getEmmetConfig(state);\n    if (pluginConfig.config) {\n        opt = resolveConfig(opt, pluginConfig.config);\n    }\n\n    return expandAbbreviation(abbr as string, opt);\n}\n\n/**\n * Extracts abbreviation from given source code by detecting actual syntax context.\n * For example, if host syntax is HTML, it tries to detect if location is inside\n * embedded CSS.\n *\n * It also detects if abbreviation is allowed at given location: HTML tags,\n * CSS selectors may not contain abbreviations.\n * @param code Code from which abbreviation should be extracted\n * @param pos Location at which abbreviation should be expanded\n * @param type Syntax of abbreviation to expand\n */\nexport function extract(code: string, pos: number, type: SyntaxType = 'markup', options?: Partial<ExtractOptions>): ExtractedAbbreviation | undefined {\n    return extractAbbreviation(code, pos, {\n        lookAhead: type !== 'stylesheet',\n        type,\n        ...options\n    });\n}\n\n/**\n * Returns matched HTML/XML tag for given point in view\n */\nexport function getTagContext(state: EditorState, pos: number): ContextTag | undefined {\n    let element: SyntaxNode | null = syntaxTree(state).resolve(pos, 1);\n    while (element && element.name !== 'Element') {\n        element = element.parent;\n    }\n\n    if (element) {\n        const selfClose = element.getChild('SelfClosingTag');\n        if (selfClose) {\n            return {\n                name: getTagName(state, selfClose),\n                attributes: getTagAttributes(state, selfClose),\n                open: selfClose\n            }\n        }\n\n        const openTag = element.getChild('OpenTag');\n        if (openTag) {\n            const closeTag = element.getChild('CloseTag');\n            const ctx: ContextTag = {\n                name: getTagName(state, openTag),\n                attributes: getTagAttributes(state, openTag),\n                open: openTag,\n            };\n\n            if (closeTag) {\n                ctx.close = closeTag;\n            }\n\n            return ctx;\n        }\n    }\n\n    return;\n}\n\nexport function getTagName(state: EditorState, node: SyntaxNode): string {\n    const tagName = node.getChild('TagName');\n    return tagName ? substr(state, tagName) : '';\n}\n\n/**\n * Returns Emmet options for given character location in editor\n */\nexport function getOptions(state: EditorState, pos: number): UserConfig {\n    const info = syntaxInfo(state, pos);\n    const { context } = info;\n\n    const config: UserConfig = {\n        type: info.type,\n        syntax: info.syntax || 'html',\n        options: getOutputOptions(state, info.inline)\n    };\n\n    if (context) {\n        // Set context from syntax info\n        if (context.type === 'html' && context.ancestors.length) {\n            config.context = getMarkupAbbreviationContext(state, context);\n        } else if (context.type === 'css') {\n            config.context = getStylesheetAbbreviationContext(context);\n        }\n    }\n\n    return config;\n}\n\nexport function resetCache() {\n    cache = {};\n}\n", "import type { GlobalConfig } from 'emmet';\nimport { EditorState, Extension, Facet } from '@codemirror/state';\nimport { resetCache } from './emmet';\n\nexport interface EmmetEditorOptions {\n    emmet: EmmetConfig;\n}\n\nexport type EnableForSyntax = boolean | string[];\nexport type PreviewExtensions = () => Extension;\n\nexport interface EmmetPreviewConfig {\n    /** Extensions factory for displaying HTML-like abbreviation preview  */\n    html?: PreviewExtensions;\n    /** Extensions factory for displaying CSS-like abbreviation preview  */\n    css?: PreviewExtensions;\n}\n\nexport interface EmmetConfig {\n    /** Enables abbreviation marking in editor. Works in known syntaxes only */\n    mark: EnableForSyntax;\n\n    /**\n     * Config for proview popup\n     */\n    preview: EmmetPreviewConfig;\n\n    /**\n     * Enables preview of marked abbreviation. Pass `true` to enable preview for\n     * all syntaxes or array of modes or Emmet syntax types (`markup` or `stylesheet`)\n     * where preview should be displayed\n     */\n    previewEnabled: EnableForSyntax;\n\n    /** Mark HTML tag pairs in editor */\n    markTagPairs: boolean;\n\n    /**\n     * Displays open tag preview when caret is inside its matching closing tag.\n     * Preview is displayed only if open tag has attributes.\n     * Works only if `markTagPairs` is enabled\n     */\n    previewOpenTag: boolean;\n\n    /** Allow automatic tag pair rename, works only if `markTagPairs` is enabled */\n    autoRenameTags: boolean;\n\n    /** Quotes to use in generated HTML attribute values */\n    attributeQuotes: 'single' | 'double';\n\n    /** Style for self-closing elements (like `<br>`) and boolean attributes */\n    markupStyle: 'html' | 'xhtml' | 'xml',\n\n    /**\n     * Enable automatic tag commenting. When enabled, elements generated from Emmet\n     * abbreviation with `id` and/or `class` attributes will receive a comment\n     * with these attribute values\n     */\n    comments: boolean;\n\n    /**\n     * Commenting template. Default value is `\\n<!-- /[#ID][.CLASS] -->`\n     * Outputs everything between `[` and `]` only if specified attribute name\n     * (written in UPPERCASE) exists in element. Attribute name is replaced with\n     * actual value. Use `\\n` to add a newline.\n     */\n    commentsTemplate?: string;\n\n    /**\n     * Enable BEM support. When enabled, Emmet will treat class names starting\n     * with `-` as _element_ and with `_` as _modifier_ in BEM notation.\n     * These class names will inherit `block` name from current or ancestor element.\n     * For example, the abbreviation `ul.nav.nav_secondary>li.nav__item` can be\n     * shortened to `ul.nav._secondary>li.-item` with this option enabled.\n     */\n    bem: boolean;\n\n    /**\n     * For stylesheet abbreviations, generate short HEX color values, if possible.\n     * For example, `c#0` will be expanded to `color: #000;` instead of `color: #000000`.\n     */\n    shortHex?: boolean;\n\n    /** Advanced Emmet config */\n    config?: GlobalConfig;\n\n    /**\n     * A `boost` option for CodeMirror completions\n     */\n    completionBoost?: number;\n\n    /**\n     * Function for attaching abbreviation preview\n     */\n    // attachPreview?: (editor: CodeMirror.Editor, preview: HTMLElement, pos: CodeMirror.Position) => void;\n}\n\nexport const defaultConfig: EmmetConfig = {\n    mark: true,\n    preview: { },\n    previewEnabled: true,\n    autoRenameTags: true,\n    markTagPairs: true,\n    previewOpenTag: false,\n    attributeQuotes: 'double',\n    markupStyle: 'html',\n    comments: false,\n    commentsTemplate: '<!-- /[#ID][.CLASS] -->',\n    bem: false,\n    completionBoost: 99\n};\n\nexport const config = Facet.define<Partial<EmmetConfig>, EmmetConfig>({\n    combine(value) {\n        resetCache();\n        const baseConfig: EmmetConfig = { ...defaultConfig };\n        const { preview } = baseConfig;\n        for (const item of value) {\n            Object.assign(baseConfig, item);\n            if (item.preview) {\n                baseConfig.preview = {\n                    ...preview,\n                    ...item.preview\n                };\n            }\n        }\n\n        return baseConfig;\n    }\n});\n\nexport default function getEmmetConfig(state: EditorState, opt?: Partial<EmmetConfig>): EmmetConfig {\n    let conf = state.facet(config);\n    if (opt) {\n        conf = { ...conf, ...opt };\n    }\n\n    return conf;\n}\n", "import type { Options } from 'emmet';\nimport type { EditorState, Line } from '@codemirror/state';\nimport getEmmetConfig from './config';\nimport { isHTML, docSyntax } from './syntax';\n\nexport default function getOutputOptions(state: EditorState, inline?: boolean): Partial<Options> {\n    const syntax = docSyntax(state) || 'html';\n    const config = getEmmetConfig(state);\n\n    const opt: Partial<Options> = {\n        // 'output.baseIndent': lineIndent(state.doc.lineAt(pos)),\n        // 'output.indent': getIndentation(state),\n        'output.field': field,\n        'output.indent': '\\t',\n        'output.format': !inline,\n        'output.attributeQuotes': config.attributeQuotes,\n        'stylesheet.shortHex': config.shortHex\n    };\n\n    if (syntax === 'html') {\n        opt['output.selfClosingStyle'] = config.markupStyle;\n        opt['output.compactBoolean'] = config.markupStyle === 'html';\n    }\n\n    if (isHTML(syntax)) {\n        if (config.comments) {\n            opt['comment.enabled'] = true;\n            if (config.commentsTemplate) {\n                opt['comment.after'] = config.commentsTemplate;\n            }\n        }\n\n        opt['bem.enabled'] = config.bem;\n    }\n\n    return opt;\n}\n\n/**\n * Produces tabstop for CodeMirror editor\n */\nexport function field(index: number, placeholder?: string) {\n    return placeholder ? `\\${${index}:${placeholder}}` : `\\${${index}}`;\n}\n\n/**\n * Returns indentation of given line\n */\nexport function lineIndent(line: Line): string {\n    const indent = line.text.match(/^\\s+/);\n    return indent ? indent[0] : '';\n}\n\n/**\n * Returns token used for single indentation in given editor\n */\nexport function getIndentation(state: EditorState): string {\n    const { tabSize } = state;\n    return tabSize ? ' '.repeat(tabSize) : '\\t';\n}\n", "import { EditorView } from 'codemirror';\nimport { EditorState } from '@codemirror/state';\nimport { syntaxHighlighting, defaultHighlightStyle } from '@codemirror/language';\nimport { html } from '@codemirror/lang-html';\nimport { css } from '@codemirror/lang-css';\nimport type { EmmetPreviewConfig, PreviewExtensions } from '../lib/config';\n\nexport interface HTMLElementPreview extends HTMLElement {\n    update?: (value: string) => void;\n}\n\nexport function createPreview(value: string, syntax: string, options?: EmmetPreviewConfig): HTMLElementPreview {\n    const elem = document.createElement('div') as HTMLElementPreview;\n    elem.className = 'emmet-preview';\n    if (syntax === 'error') {\n        elem.classList.add('emmet-preview_error');\n    }\n\n    let ext: PreviewExtensions = syntax === 'css' ? css : html;\n    if (options && syntax in options) {\n        ext = options[syntax as keyof EmmetPreviewConfig]!;\n    }\n\n    const view = new EditorView({\n        doc: value,\n        extensions: [\n            EditorState.readOnly.of(true),\n            syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n            syntax === 'css' ? css() : html(),\n            ext()\n        ],\n        parent: elem\n    });\n\n    elem.update = (nextValue) => {\n        const tr = view.state.update({\n            changes: {\n                from: 0,\n                to: view.state.doc.length,\n                insert: nextValue\n            }\n        });\n        view.dispatch(tr);\n    };\n\n    return elem;\n}\n", "export default \"data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjM5MyIgdmlld0JveD0iMCAwIDM5MyAzOTMiIHdpZHRoPSIzOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9Ijk4LjYwODY5JSIgeDI9IjUwJSIgeTE9IjUwJSIgeTI9IjUwJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjY2VmYmFkIi8+PHN0b3Agb2Zmc2V0PSIuODM2OTcyNTM1IiBzdG9wLWNvbG9yPSIjY2VmYmFkIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGlkPSJiIiBkPSJtMTE2IDQ4IDEwNSA2M3YzNC45ODVsLTc1LTQ0Ljk5OTI4OXY2Ny42NjcyODlsNDkuNSAyOS4zNDctNDkuNSAyOS4zNDZ2NjcuNjY4Mjg5bDc1LTQ1LjAwMDI4OXYzNC45ODZsLTEwNSA2M3ptMTQ1IDg3IDEwNSA2My0xMDUgNjN2LTM0Ljk4Nmw0Ni42OTA0ODEtMjguMDE0LTQ2LjY5MDQ4MS0yOC4wMTR6Ii8+PC9kZWZzPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJtYXRyaXgoLjcwNzEwNjc4IC0uNzA3MTA2NzggLjcwNzEwNjc4IC43MDcxMDY3OCAtODEuMzkyOTY1IDE5Ni41KSI+PGNpcmNsZSBjeD0iMTk2LjUiIGN5PSIxOTYuNSIgZmlsbD0iIzI1MjcyYiIgcj0iMTk2LjUiLz48dXNlIGZpbGw9IiM5MmMxMzEiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJ1cmwoI2EpIiB4bGluazpocmVmPSIjYiIvPjwvZz48L3N2Zz4=\"", "import type { MarkupAbbreviation, StylesheetAbbreviation, UserConfig } from 'emmet';\nimport { markupAbbreviation } from 'emmet';\nimport { ViewPlugin, Decoration, keymap, EditorView, type Tooltip, showTooltip } from '@codemirror/view';\nimport type { DecorationSet, Command, ViewUpdate } from '@codemirror/view';\nimport { StateEffect, StateField } from '@codemirror/state';\nimport type { Range, EditorState, Extension, StateCommand, Transaction } from '@codemirror/state';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { snippet, pickedCompletion, completionStatus, type CompletionResult, type Completion } from '@codemirror/autocomplete';\nimport type { CompletionSource } from '@codemirror/autocomplete';\nimport { getCSSContext, getHTMLContext } from '../lib/context';\nimport { docSyntax, getMarkupAbbreviationContext, getStylesheetAbbreviationContext, getSyntaxType, isCSS, isHTML, isJSX, isSupported } from '../lib/syntax';\nimport getOutputOptions from '../lib/output';\nimport type { CSSContext, AbbreviationError, StartTrackingParams, RangeObject } from '../lib/types';\nimport { contains, getCaret, rangeEmpty, substr } from '../lib/utils';\nimport { expand } from '../lib/emmet';\nimport { type HTMLElementPreview, createPreview } from './AbbreviationPreviewWidget';\nimport icon from '../completion-icon.svg';\nimport getEmmetConfig, { config, EmmetPreviewConfig, type EmmetConfig } from '../lib/config';\n\ninterface EmmetCompletion extends Completion {\n    tracker: AbbreviationTrackerValid;\n    previewConfig: EmmetPreviewConfig;\n    preview?: HTMLElementPreview;\n}\n\ninterface EmmetTooltip extends Tooltip {\n    tracker: AbbreviationTracker;\n}\n\ntype AbbreviationTracker = AbbreviationTrackerValid | AbbreviationTrackerError;\n\n/// CSS property and value keyword completion source.\n// Проблема мигающего автокомплита в том, что он становится ActiveSource,\n// а не ActiveResult, из-за этого помечется как Pending и не обновляется на первый\n// проход.\n// Текущая реализация укладывается в нужную концепцию,\n// но проверка автокомплита обрабатывается раньше, чем обновляется трэкер.\n// Нужно найти способ обновить трэкер раньше, чем отработает код автокомплита\nexport const emmetCompletionSource: CompletionSource = context => {\n    const tracker = context.state.field(trackerField);\n    if (tracker?.type === 'abbreviation' && tracker.preview) {\n        return {\n            from: tracker.range.from,\n            to: tracker.range.to,\n            filter: false,\n            update(current, _from, _to, context) {\n                const tracker = context.state.field(trackerField);\n                if (!tracker || tracker.type === 'error') {\n                    return null;\n                }\n\n                return {\n                    ...current,\n                    from: tracker.range.from,\n                    to: tracker.range.to,\n                    options: completionOptionsFromTracker(context.state, tracker)\n                };\n            },\n            options: completionOptionsFromTracker(context.state, tracker)\n        } as CompletionResult;\n    }\n\n    return null;\n}\n\nconst cssCompletion: Extension = cssLanguage.data.of({ autocomplete: emmetCompletionSource });\n\ninterface AbbreviationTrackerBase {\n    /** Range in editor for abbreviation */\n    range: RangeObject;\n\n    /** Actual abbreviation, tracked by current tracker */\n    abbreviation: string;\n\n    /**\n     * Abbreviation was forced, e.g. must remain in editor even if empty or contains\n     * invalid abbreviation\n     */\n    forced: boolean;\n\n    /** Indicates that current tracker shouldn’t be displayed in editor */\n    inactive: boolean;\n\n    /**\n     * Relative offset from range start where actual abbreviation starts.\n     * Used tp handle prefixes in abbreviation\n     */\n    offset: number;\n\n    config: UserConfig;\n}\n\nexport interface AbbreviationTrackerValid extends AbbreviationTrackerBase {\n    type: 'abbreviation';\n\n    /**\n     * Abbreviation is simple, e.g. contains single element.\n     * It’s suggested to not display preview for simple abbreviation\n     */\n    simple: boolean;\n\n    /** Preview of expanded abbreviation */\n    preview: string;\n}\n\nexport interface AbbreviationTrackerError extends AbbreviationTrackerBase {\n    type: 'error';\n    error: AbbreviationError;\n}\n\nexport const JSX_PREFIX = '<';\n\nconst trackerMark = Decoration.mark({ class: 'emmet-tracker' });\n\nconst resetTracker = StateEffect.define();\nconst forceTracker = StateEffect.define();\n\nexport const enterAbbreviationMode: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        effects: [forceTracker.of(null)]\n    });\n    dispatch(tr);\n    return true;\n};\n\nconst trackerField = StateField.define<AbbreviationTracker | null>({\n    create: () => null,\n    update(value, tr) {\n        const hasCompletion = tr.annotation(pickedCompletion);\n        if (hasCompletion) {\n            // When completion is applied, always reset tracker\n            return null;\n        }\n\n        for (const effect of tr.effects) {\n            if (effect.is(resetTracker)) {\n                return null;\n            }\n\n            if (effect.is(forceTracker)) {\n                const sel = tr.newSelection.main;\n                const config = getActivationContext(tr.state, sel.from);\n                if (config) {\n                    return createTracker(tr.state, sel, {\n                        forced: true,\n                        config\n                    });\n                }\n            }\n        }\n\n        if (!tr.docChanged) {\n            return value;\n        }\n        return handleUpdate(tr.state, value, tr);\n    }\n});\n\nconst abbreviationPreview = StateField.define<EmmetTooltip | null>({\n    create: getAbbreviationPreview,\n    update(tooltip, tr) {\n        if (!tr.docChanged && !tr.selection) {\n            const tracker = tr.state.field(trackerField);\n            return tracker ? tooltip : null;\n        }\n        return getAbbreviationPreview(tr.state, tooltip);\n    },\n    provide: f => showTooltip.from(f)\n});\n\nfunction getAbbreviationPreview(state: EditorState, prevTooltip?: EmmetTooltip | null): EmmetTooltip | null {\n    const tracker = state.field(trackerField);\n\n    if (tracker && !tracker.inactive && completionStatus(state) !== 'active') {\n        if (tracker.config.type === 'stylesheet') {\n            // Do not display preview for CSS since completions are populated\n            // automatically for this syntax and abbreviation will be a part of\n            // completion list\n            return null;\n        }\n\n        if (prevTooltip && prevTooltip.tracker.type !== tracker.type) {\n            prevTooltip = null;\n        }\n\n        const { range } = tracker;\n\n        if (canDisplayPreview(state, tracker)) {\n            return prevTooltip || {\n                pos: range.from,\n                above: false,\n                arrow: false,\n                tracker,\n                create() {\n                    const previewConfig = state.facet(config).preview;\n                    let preview = '';\n                    let syntax = '';\n\n                    if (tracker.type === 'error') {\n                        preview = tracker.error.message;\n                        syntax = 'error';\n                    } else {\n                        preview = tracker.preview;\n                        syntax = tracker.config.syntax || 'html';\n                    }\n\n                    const dom = createPreview(preview, syntax, previewConfig);\n                    return {\n                        dom,\n                        update({ state }) {\n                            const tracker = state.field(trackerField);\n                            if (tracker && dom.update) {\n                                const value = tracker.type === 'error'\n                                    ? tracker.error.message\n                                    : tracker.preview;\n                                dom.update(value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nconst abbreviationTracker = ViewPlugin.fromClass(class {\n    decorations: DecorationSet;\n\n    constructor() {\n        this.decorations = Decoration.none;\n    }\n\n    update(update: ViewUpdate) {\n        const { state } = update;\n\n        const tracker = state.field(trackerField);\n        const decors: Range<Decoration>[] = [];\n\n        if (tracker && !tracker.inactive) {\n            const { range } = tracker;\n\n            if (!rangeEmpty(range) ) {\n                decors.push(trackerMark.range(range.from, range.to));\n            }\n            this.decorations = Decoration.set(decors, true);\n        } else {\n            this.decorations = Decoration.none;\n        }\n    }\n}, {\n    decorations: v => v.decorations,\n});\n\nexport function expandTracker(view: EditorView, tracker: AbbreviationTracker): void {\n    const { from, to } = tracker.range;\n    const expanded = expand(view.state, tracker.abbreviation, tracker.config);\n    const fn = snippet(expanded);\n\n    view.dispatch(view.state.update({\n        effects: resetTracker.of(null)\n    }));\n    fn(view, { label: 'expand' }, from, to);\n}\n\nconst tabKeyHandler: Command = (view) => {\n    const { state } = view;\n    if (completionStatus(state)) {\n        // Must be handled by `acceptCompletion` command\n        return false;\n    }\n\n    const tracker = state.field(trackerField, false);\n    if (tracker && !tracker.inactive && contains(tracker.range, getCaret(state))) {\n        expandTracker(view, tracker);\n        return true;\n    }\n    return false;\n};\n\nconst escKeyHandler: Command = ({ state, dispatch }) => {\n    const tracker = state.field(trackerField, false);\n    if (tracker) {\n        dispatch({\n            effects: resetTracker.of(null)\n        });\n        return true;\n    }\n\n    return false;\n};\n\nconst trackerTheme = EditorView.baseTheme({\n    '.emmet-tracker': {\n        textDecoration: 'underline 1px green',\n    },\n    '.emmet-preview': {\n        fontSize: '0.9em'\n    },\n    '.emmet-preview_error': {\n        color: 'red'\n    },\n    '.cm-completionIcon-emmet::after': {\n        content: '\" \"',\n        background: `url(\"${icon}\") center/contain no-repeat`,\n        display: 'inline-block',\n        width: '11px',\n        height: '11px',\n        verticalAlign: 'middle'\n    }\n});\n\n/**\n * A factory function that creates abbreviation tracker for known syntaxes.\n * When user starts typing, it detects whether user writes abbreviation and\n * if so, starts tracking by displaying an underline. Then if user hit Tab key\n * when cursor is inside tracked abbreviation, it will expand it. Or user can\n * press Escape key to reset tracker\n */\nexport default function tracker(options?: Partial<EmmetConfig>): Extension[] {\n    return [\n        trackerField,\n        abbreviationTracker,\n        abbreviationPreview,\n        trackerTheme,\n        cssCompletion,\n        options ? config.of(options) : [],\n        keymap.of([{\n            key: 'Tab',\n            run: tabKeyHandler\n        }, {\n            key: 'Escape',\n            run: escKeyHandler\n        }])\n    ]\n}\n\nexport { resetTracker as trackerResetAction }\n\n/**\n * Check if abbreviation tracking is allowed in editor at given location\n */\nexport function allowTracking(state: EditorState): boolean {\n    return isSupported(docSyntax(state));\n}\n\n/**\n * Detects if user is typing abbreviation at given location\n * @param pos Location where user started typing\n * @param input Text entered at `pos` location\n */\nfunction typingAbbreviation(state: EditorState, pos: number, input: string): AbbreviationTracker | null {\n    if (input.length !== 1) {\n        // Expect single character enter to start abbreviation tracking\n        return null;\n    }\n\n    // Start tracking only if user starts abbreviation typing: entered first\n    // character at the word bound\n    const line = state.doc.lineAt(pos);\n    const prefix = line.text.substring(Math.max(0, pos - line.from - 1), pos - line.from);\n\n    // Check if current syntax is supported for tracking\n    if (!canStartTyping(prefix, input, getSyntaxFromPos(state, pos))) {\n        return null;\n    }\n\n    const config = getActivationContext(state, pos);\n    if (!config) {\n        return null;\n    }\n\n    if (config.type === 'stylesheet' && !canStartTyping(prefix, input, 'css')) {\n        // Additional check for stylesheet abbreviation start: it’s slightly\n        // differs from markup prefix, but we need activation context\n        // to ensure that context under caret is CSS\n        return null;\n    }\n\n    const syntax = config.syntax || 'html';\n    let from = pos;\n    let to = pos + input.length;\n    let offset = 0;\n\n    if (isJSX(syntax) && prefix === JSX_PREFIX) {\n        offset = JSX_PREFIX.length;\n        from -= offset;\n    }\n\n    return createTracker(state, { from, to }, { config });\n}\n\n/**\n * Detects and returns valid abbreviation activation context for given location\n * in editor which can be used for abbreviation expanding.\n * For example, in given HTML code:\n * `<div title=\"Sample\" style=\"\">Hello world</div>`\n * it’s not allowed to expand abbreviations inside `<div ...>` or `</div>`,\n * yet it’s allowed inside `style` attribute and between tags.\n *\n * This method ensures that given `pos` is inside location allowed for expanding\n * abbreviations and returns context data about it.\n */\nexport function getActivationContext(state: EditorState, pos: number): UserConfig | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSActivationContext(state, pos, 'css', getCSSContext(state, pos));\n    }\n\n    const syntax = docSyntax(state);\n\n    if (isHTML(syntax)) {\n        const ctx = getHTMLContext(state, pos);\n\n        if (ctx.css) {\n            return getCSSActivationContext(state, pos, 'css', ctx.css);\n        }\n\n        if (!ctx.current) {\n            return {\n                syntax,\n                type: 'markup',\n                context: getMarkupAbbreviationContext(state, ctx),\n                options: getOutputOptions(state)\n            };\n        }\n    } else {\n        return {\n            syntax,\n            type: getSyntaxType(syntax),\n            options: getOutputOptions(state)\n        };\n    }\n\n    return undefined;\n}\n\nfunction getCSSActivationContext(state: EditorState, pos: number, syntax: string, ctx: CSSContext): UserConfig | undefined {\n    const allowedContext = !ctx.current\n        || ctx.current.type === 'propertyName'\n        || ctx.current.type === 'propertyValue'\n        || isTypingBeforeSelector(state, pos, ctx);\n\n    if (allowedContext) {\n        return {\n            syntax,\n            type: 'stylesheet',\n            context: getStylesheetAbbreviationContext(ctx),\n            options: getOutputOptions(state, ctx.inline)\n        };\n    }\n\n    return;\n}\n\n/**\n * Handle edge case: start typing abbreviation before selector. In this case,\n * entered character becomes part of selector\n * Activate only if it’s a nested section and it’s a first character of selector\n */\nfunction isTypingBeforeSelector(state: EditorState, pos: number, { current }: CSSContext): boolean {\n    if (current?.type === 'selector' && current.range.from === pos - 1) {\n        // Typing abbreviation before selector is tricky one:\n        // ensure it’s on its own line\n        const line = state.doc.lineAt(current.range.from);\n        return line.text.trim().length === 1;\n    }\n\n    return false;\n}\n\nfunction isValidPrefix(prefix: string, syntax: string): boolean {\n    if (isJSX(syntax)) {\n        return prefix === JSX_PREFIX;\n    }\n\n    if (isCSS(syntax)) {\n        return prefix === '' || /^[\\s>;\"\\']$/.test(prefix);\n    }\n\n    return prefix === '' || /^[\\s>;\"\\']$/.test(prefix);\n}\n\nfunction isValidAbbreviationStart(input: string, syntax: string): boolean {\n    if (isJSX(syntax)) {\n        return /^[a-zA-Z.#\\[\\(]$/.test(input);\n    }\n\n    if (isCSS(syntax)) {\n        return /^[a-zA-Z!@#]$/.test(input);\n    }\n\n    return /^[a-zA-Z.#!@\\[\\(]$/.test(input);\n}\n\n/**\n * Creates abbreviation tracker for given range in editor. Parses contents\n * of abbreviation in range and returns either valid abbreviation tracker,\n * error tracker or `null` if abbreviation cannot be created from given range\n */\nfunction createTracker(state: EditorState, range: RangeObject, params: StartTrackingParams): AbbreviationTracker | null {\n    if (range.from > range.to) {\n        // Invalid range\n        return null;\n    }\n\n    let abbreviation = substr(state, range);\n    const { config, forced } = params;\n    if (params.offset) {\n        abbreviation = abbreviation.slice(params.offset);\n    }\n\n    // Basic validation: do not allow empty abbreviations\n    // or newlines in abbreviations\n    if ((!abbreviation && !forced) || hasInvalidChars(abbreviation)) {\n        return null;\n    }\n\n    const base: AbbreviationTrackerBase = {\n        abbreviation,\n        range,\n        config,\n        forced: !!forced,\n        inactive: false,\n        offset: params.offset || 0,\n    }\n\n    try {\n        let parsedAbbr: MarkupAbbreviation | StylesheetAbbreviation | undefined;\n        let simple = false;\n\n        if (config.type === 'markup') {\n            parsedAbbr = markupAbbreviation(abbreviation, {\n                jsx: config.syntax === 'jsx'\n            });\n            simple = isSimpleMarkupAbbreviation(parsedAbbr);\n        }\n\n        const previewConfig = createPreviewConfig(config);\n        const preview = expand(state, parsedAbbr || abbreviation, previewConfig);\n        if (!preview) {\n            // Handle edge case: abbreviation didn’t return any result for preview.\n            // Most likely it means a CSS context where given abbreviation is not applicable\n            return null;\n        }\n\n        return {\n            ...base,\n            type: 'abbreviation',\n            simple,\n            preview,\n        };\n    } catch (error) {\n        return base.forced ? {\n            ...base,\n            type: 'error',\n            error: error as AbbreviationError,\n        } : null;\n    }\n}\n\nfunction hasInvalidChars(abbreviation: string): boolean {\n    return /[\\r\\n]/.test(abbreviation);\n}\n\n/**\n * Check if given parsed markup abbreviation is simple.A simple abbreviation\n * may not be displayed to user as preview to reduce distraction\n */\nfunction isSimpleMarkupAbbreviation(abbr: MarkupAbbreviation): boolean {\n    if (abbr.children.length === 1 && !abbr.children[0].children.length) {\n        // Single element: might be a HTML element or text snippet\n        const first = abbr.children[0];\n        // XXX silly check for common snippets like `!`. Should read contents\n        // of expanded abbreviation instead\n        return !first.name || /^[a-z]/i.test(first.name);\n    }\n    return !abbr.children.length;\n}\n\nfunction createPreviewConfig(config: UserConfig) {\n    return {\n        ...config,\n        options: {\n            ...config.options,\n            'output.field': previewField,\n            'output.indent': '  ',\n            'output.baseIndent': ''\n        }\n    };\n}\n\nfunction previewField(_: number, placeholder: string) {\n    return placeholder;\n}\n\nfunction handleUpdate(state: EditorState, tracker: AbbreviationTracker | null, update: Transaction): AbbreviationTracker | null {\n    if (hasSnippet(state)) {\n        return null;\n    }\n\n    if (!tracker || tracker.inactive) {\n        // Start abbreviation tracking\n        update.changes.iterChanges((_fromA, _toA, fromB, _toB, text) => {\n            if (text.length) {\n                tracker = typingAbbreviation(state, fromB, text.toString()) || tracker;\n            }\n        });\n\n        if (!tracker || !tracker.inactive) {\n            return tracker;\n        }\n    }\n\n    // Continue abbreviation tracking\n    update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n        if (!tracker) {\n            return;\n        }\n\n        const { range } = tracker;\n        if (!contains(range, fromA)) {\n            // Update is outside of abbreviation, reset it only if it’s not inactive\n            if (!tracker.inactive) {\n                tracker = null;\n            }\n        } else if (contains(range, fromB)) {\n            const removed = toA - fromA;\n            const inserted = toB - fromA;\n            const to = range.to + inserted - removed;\n            if (to <= range.from || hasInvalidChars(text.toString())) {\n                tracker = null;\n            } else {\n                const abbrRange = tracker.inactive ? range : { from: range.from, to };\n                const nextTracker = createTracker(state, abbrRange, {\n                    config: tracker.config,\n                    forced: tracker.forced\n                });\n\n                if (!nextTracker) {\n                    // Next tracker is empty mostly due to invalid abbreviation.\n                    // To allow users to fix error, keep previous tracker\n                    // instance as inactive\n                    tracker = { ...tracker, inactive: true };\n                } else {\n                    tracker = nextTracker;\n                }\n            }\n        }\n    });\n\n    return tracker;\n}\n\nfunction getSyntaxFromPos(state: EditorState, pos: number): string {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return 'css';\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return 'html';\n    }\n\n    return '';\n}\n\nfunction canStartTyping(prefix: string, input: string, syntax: string) {\n    return isValidPrefix(prefix, syntax) && isValidAbbreviationStart(input, syntax);\n}\n\n/**\n * It’s a VERY hacky way to detect if snippet is currently active in given state.\n * Should ask package authors how to properly detect it\n */\nfunction hasSnippet(state: any): boolean {\n    if (Array.isArray(state.values)) {\n        return state.values.some((item: any) => item && item.constructor?.name === 'ActiveSnippet');\n    }\n\n    return false;\n}\n\nexport function canDisplayPreview(state: EditorState, tracker: AbbreviationTracker): boolean {\n    if (completionStatus(state) === 'active') {\n        return false;\n    }\n\n    const config = getEmmetConfig(state);\n    if (!config.previewEnabled) {\n        return false;\n    }\n\n    if (Array.isArray(config.previewEnabled)) {\n        const { type, syntax } = tracker.config;\n        if (!config.previewEnabled.includes(type!) && !config.previewEnabled.includes(syntax!)) {\n            return false;\n        }\n    }\n\n    return tracker.type === 'error' || (!tracker.simple || tracker.forced) && !!tracker.abbreviation && contains(tracker.range, getCaret(state));\n}\n\nfunction completionOptionsFromTracker(state: EditorState, tracker: AbbreviationTrackerValid, prev?: EmmetCompletion): EmmetCompletion[] {\n    const opt = state.facet(config);\n    return [{\n        label: 'Emmet abbreviation',\n        type: 'emmet',\n        boost: opt.completionBoost,\n        tracker,\n        previewConfig: opt.preview,\n        preview: prev?.preview,\n        info: completionInfo,\n        apply: (view, completion) => {\n            view.dispatch({\n                annotations: pickedCompletion.of(completion)\n            });\n            expandTracker(view, tracker);\n        }\n    }];\n}\n\nfunction completionInfo(completion: Completion): Node {\n    let { tracker, previewConfig, preview } = completion as EmmetCompletion;\n    if (preview?.update) {\n        preview.update(tracker.preview);\n    } else {\n        (completion as EmmetCompletion).preview = preview = createPreview(tracker.preview, tracker.config.syntax || 'html', previewConfig);\n    }\n\n    return preview;\n}\n", "import type { StateCommand } from '@codemirror/state';\nimport { expand, extract, getOptions } from '../lib/emmet';\nimport { getSyntaxType } from '../lib/syntax';\nimport { snippet } from '@codemirror/autocomplete';\nimport { getActivationContext } from '../tracker';\n\nexport const expandAbbreviation: StateCommand = ({ state, dispatch }) => {\n    const sel = state.selection.main;\n    const line = state.doc.lineAt(sel.anchor);\n    const options = getOptions(state, sel.anchor);\n    const abbr = extract(line.text, sel.anchor - line.from, getSyntaxType(options.syntax));\n\n    if (abbr) {\n        const start = line.from + abbr.start;\n        const expanded = expand(state, abbr.abbreviation, getActivationContext(state, start) || options);\n        const fn = snippet(expanded);\n        fn({ state, dispatch }, { label: 'expand' }, start, line.from + abbr.end);\n        return true;\n    }\n\n    return false;\n};\n\n", "import { syntaxTree } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { RangeObject } from '../lib/types';\nimport { contains, fullCSSDeclarationRange, last, narrowToNonSpace, rangeContains, rangesEqual } from '../lib/utils';\nimport { getPropertyRanges } from '../lib/context';\n\n// TODO use RangeObject instead of TextRange\n\nexport const balanceOutward: StateCommand = ({ state, dispatch }) => {\n    const nextSel: SelectionRange[] = [];\n    let hasMatch = false;\n\n    for (const sel of state.selection.ranges) {\n        const ranges = getOutwardRanges(state, sel.from);\n        if (ranges) {\n            hasMatch = true;\n            const targetRange = ranges.find(r => rangeContains(r, sel) && !rangesEqual(r, sel)) || sel;\n            nextSel.push(EditorSelection.range(targetRange.from, targetRange.to));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    if (hasMatch) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextSel)\n        });\n\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nexport const balanceInward: StateCommand = ({ state, dispatch }) => {\n    const nextSel: SelectionRange[] = [];\n    let hasMatch = false;\n    for (const sel of state.selection.ranges) {\n        const ranges = getInwardRanges(state, sel.from);\n        if (ranges) {\n            hasMatch = true;\n            // Try to find range which equals to selection: we should pick leftmost\n            let ix = ranges.findIndex(r => rangesEqual(sel, r));\n            let targetRange: RangeObject = sel;\n\n            if (ix < ranges.length - 1) {\n                targetRange = ranges[ix + 1];\n            } else if (ix !== -1) {\n                // No match found, pick closest region\n                targetRange = ranges.slice(ix).find(r => rangeContains(r, sel)) || sel;\n            }\n\n            nextSel.push(EditorSelection.range(targetRange.from, targetRange.to));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    if (hasMatch) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextSel)\n        });\n\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction getOutwardRanges(state: EditorState, pos: number): RangeObject[] | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSOutwardRanges(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLOutwardRanges(state, pos);\n    }\n\n    return;\n}\n\nfunction getInwardRanges(state: EditorState, pos: number): RangeObject[] | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSInwardRanges(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLInwardRanges(state, pos);\n    }\n\n    return;\n}\n\nfunction getHTMLOutwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    const tree = syntaxTree(state).resolveInner(pos, -1);\n\n    for (let node: SyntaxNode | null = tree; node; node = node.parent) {\n        if (node.name === 'Element') {\n            pushHTMLRanges(node, result);\n        }\n    }\n\n    return compactRanges(result, false);\n}\n\nfunction getHTMLInwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, 1);\n\n    // Find closest element\n    while (node && node.name !== 'Element') {\n        node = node.parent;\n    }\n\n    // Find all first child elements\n    while (node) {\n        pushHTMLRanges(node, result);\n        node = node.getChild('Element');\n    }\n\n    return compactRanges(result, true);\n}\n\nfunction getCSSOutwardRanges(state: EditorState, pos: number): RangeObject[]  {\n    const result: RangeObject[] = [];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, -1);\n\n    while (node) {\n        pushCSSRanges(state, node, pos, result);\n        node = node.parent;\n    }\n\n    return compactRanges(result, false);\n}\n\nfunction getCSSInwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    const knownNodes = ['Block', 'RuleSet', 'Declaration'];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, 1);\n\n    while (node && !knownNodes.includes(node.name)) {\n        node = node.parent;\n    }\n\n    while (node) {\n        pushCSSRanges(state, node, pos, result);\n        node = getChildOfType(node, knownNodes);\n    }\n\n    return result;\n}\n\n\nfunction pushHTMLRanges(node: SyntaxNode, ranges: RangeObject[]): void {\n    const selfClose = node.getChild('SelfClosingTag');\n    if (selfClose) {\n        ranges.push(selfClose);\n    } else {\n        const open = node.getChild('OpenTag');\n        if (open) {\n            const close = node.getChild('CloseTag');\n            if (close) {\n                // Inner range\n                ranges.push({ from: open.to, to: close.from });\n                // Outer range\n                ranges.push({ from: open.from, to: close.to });\n            } else {\n                ranges.push(open);\n            }\n        }\n    }\n}\n\nfunction pushCSSRanges(state: EditorState, node: SyntaxNode, pos: number, ranges: RangeObject[]): void {\n    if (node.name === 'Block') {\n        ranges.push(narrowToNonSpace(state, {\n            from: node.from + 1,\n            to: node.to - 1\n        }));\n    } else if (node.name === 'RuleSet') {\n        ranges.push(node);\n    } else if (node.name === 'Declaration') {\n        const { name, value } = getPropertyRanges(node);\n        if (value && contains(value, pos)) {\n            ranges.push(value);\n        }\n        if (name && contains(name, pos)) {\n            ranges.push(name);\n        }\n\n        ranges.push(fullCSSDeclarationRange(node));\n    }\n}\n\nfunction compactRanges(ranges: RangeObject[], inward: boolean): RangeObject[] {\n    const result: RangeObject[] = [];\n    ranges = [...ranges].sort(inward\n            ? ((a, b) => a.from - b.from || b.to - a.to)\n            : ((a, b) => b.from - a.from || a.to - b.to));\n\n    for (const range of ranges) {\n        const prev = last(result);\n        if (!prev || prev.from !== range.from || prev.to !== range.to) {\n            result.push(range)\n        }\n    }\n\n    return result;\n}\n\nfunction getChildOfType(node: SyntaxNode, types: string[]): SyntaxNode | null {\n    const cur = node.cursor();\n    if (cur.firstChild()) {\n        for (;;) {\n            for (const t of types) {\n                if (cur.node.name === t) {\n                    return cur.node;\n                }\n            }\n            if (!cur.nextSibling()) {\n                break;\n            }\n        }\n    }\n\n    return null;\n}\n", "import { syntaxTree } from '@codemirror/language';\nimport type { LRLanguage } from '@codemirror/language';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport type { ChangeSpec, EditorState, StateCommand } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport { narrowToNonSpace } from '../lib/utils';\n\ntype CommentTokens = [string, string];\n\nconst htmlComment: CommentTokens = ['<!--', '-->'];\nconst cssComment: CommentTokens = ['/*', '*/'];\n\nexport const toggleComment: StateCommand = ({ state, dispatch }) => {\n    let changes: ChangeSpec[] = [];\n\n    for (const sel of state.selection.ranges) {\n        if (cssLanguage.isActiveAt(state, sel.from)) {\n            changes = changes.concat(toggleCSSComment(state, sel.from));\n        } else if (htmlLanguage.isActiveAt(state, sel.from)) {\n            changes = changes.concat(toggleHTMLComment(state, sel.from));\n        }\n    }\n\n    if (!changes.length) {\n        return false;\n    }\n\n    const tr = state.update({ changes });\n    dispatch(tr);\n\n    return true;\n};\n\nfunction toggleHTMLComment(state: EditorState, pos: number): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    const ctx = getContextOfType(state, pos, ['Element', 'Comment']);\n    if (ctx) {\n        if (ctx.name === 'Comment') {\n            result = result.concat(stripComment(state, ctx, htmlComment))\n        } else {\n            result = result.concat(addComment(state, ctx, htmlComment, htmlLanguage));\n        }\n    }\n\n    return result;\n}\n\nfunction toggleCSSComment(state: EditorState, pos: number): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    const ctx = getContextOfType(state, pos, ['RuleSet', 'Declaration', 'Comment']);\n    if (ctx) {\n        if (ctx.name === 'Comment') {\n            result = result.concat(stripComment(state, ctx, cssComment));\n        } else {\n            result = result.concat(addComment(state, ctx, cssComment, cssLanguage));\n        }\n    }\n\n    return result;\n}\n\nfunction getContextOfType(state: EditorState, pos: number, types: string[]): SyntaxNode | undefined {\n    const names = new Set(types);\n    let node: SyntaxNode | null = syntaxTree(state).resolve(pos, 1);\n    while (node) {\n        if (names.has(node.name)) {\n            return node;\n        }\n        node = node.parent;\n    }\n\n    return;\n}\n\nfunction stripComment(state: EditorState, node: SyntaxNode, comment: CommentTokens): ChangeSpec[] {\n    const innerRange = narrowToNonSpace(state, {\n        from: node.from + comment[0].length,\n        to: node.to - comment[1].length\n    });\n    return [\n        { from: node.from, to: innerRange.from },\n        { from: innerRange.to, to: node.to },\n    ];\n}\n\nfunction addComment(state: EditorState, node: SyntaxNode, comment: CommentTokens, lang: LRLanguage): ChangeSpec[] {\n    // Add comment tokens around element\n    let { to } = node;\n    if (node.name === 'Declaration' && node.nextSibling?.name === ';') {\n        // edge case for CSS property\n        to = node.nextSibling.to;\n    }\n\n    let result: ChangeSpec[] = [\n        { from: node.from, insert: comment[0] + ' ' },\n        { from: to, insert: ' ' + comment[1] },\n    ];\n\n    // Remove nested comments\n    result = result.concat(stripChildComments(state, node, comment, lang));\n\n    if (node.name === 'RuleSet') {\n        // Edge case for CSS rule set: find nested block first\n        const block = node.getChild('Block');\n        if (block) {\n            result = result.concat(stripChildComments(state, block, comment, lang));\n        }\n    }\n\n    return result;\n}\n\nfunction stripChildComments(state: EditorState, node: SyntaxNode, comment: CommentTokens, lang: LRLanguage): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    for (const child of node.getChildren('Comment')) {\n        if (lang.isActiveAt(state, child.from)) {\n            result = result.concat(stripComment(state, child, comment));\n        }\n    }\n\n    return result;\n}\n", "const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n", "import Scanner, { isWhiteSpace, isNumber, isSpace } from '@emmetio/scanner';\n\nconst nullary = token(\"null\" /* Null */, 0);\n/**\n * Parses given expression in forward direction\n */\nfunction parse(expr) {\n    const scanner = typeof expr === 'string' ? new Scanner(expr) : expr;\n    let ch;\n    let priority = 0;\n    let expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n    const tokens = [];\n    while (!scanner.eof()) {\n        scanner.eatWhile(isWhiteSpace);\n        scanner.start = scanner.pos;\n        if (consumeNumber(scanner)) {\n            if ((expected & 1 /* Primary */) === 0) {\n                error('Unexpected number', scanner);\n            }\n            tokens.push(number(scanner.current()));\n            expected = (2 /* Operator */ | 8 /* RParen */);\n        }\n        else if (isOperator(scanner.peek())) {\n            ch = scanner.next();\n            if (isSign(ch) && (expected & 16 /* Sign */)) {\n                if (isNegativeSign(ch)) {\n                    tokens.push(op1(ch, priority));\n                }\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n            else {\n                if ((expected & 2 /* Operator */) === 0) {\n                    error('Unexpected operator', scanner);\n                }\n                tokens.push(op2(ch, priority));\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n        }\n        else if (scanner.eat(40 /* LeftParenthesis */)) {\n            if ((expected & 4 /* LParen */) === 0) {\n                error('Unexpected \"(\"', scanner);\n            }\n            priority += 10;\n            expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */ | 32 /* NullaryCall */);\n        }\n        else if (scanner.eat(41 /* RightParenthesis */)) {\n            priority -= 10;\n            if (expected & 32 /* NullaryCall */) {\n                tokens.push(nullary);\n            }\n            else if ((expected & 8 /* RParen */) === 0) {\n                error('Unexpected \")\"', scanner);\n            }\n            expected = (2 /* Operator */ | 8 /* RParen */ | 4 /* LParen */);\n        }\n        else {\n            error('Unknown character', scanner);\n        }\n    }\n    if (priority < 0 || priority >= 10) {\n        error('Unmatched \"()\"', scanner);\n    }\n    const result = orderTokens(tokens);\n    if (result === null) {\n        error('Parity', scanner);\n    }\n    return result;\n}\n/**\n * Consumes number from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */) && scanner.eatWhile(isNumber)) {\n        // short decimal notation: .025\n        return true;\n    }\n    if (scanner.eatWhile(isNumber) && (!scanner.eat(46 /* Dot */) || scanner.eatWhile(isNumber))) {\n        // either integer or decimal: 10, 10.25\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Orders parsed tokens (operands and operators) in given array so that they are\n * laid off in order of execution\n */\nfunction orderTokens(tokens) {\n    const operators = [];\n    const operands = [];\n    let nOperators = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        if (t.type === \"num\" /* Number */) {\n            operands.push(t);\n        }\n        else {\n            nOperators += t.type === \"op1\" /* Op1 */ ? 1 : 2;\n            while (operators.length) {\n                if (t.priority <= operators[operators.length - 1].priority) {\n                    operands.push(operators.pop());\n                }\n                else {\n                    break;\n                }\n            }\n            operators.push(t);\n        }\n    }\n    return nOperators + 1 === operands.length + operators.length\n        ? operands.concat(operators.reverse())\n        : null /* parity */;\n}\n/**\n * Number token factory\n */\nfunction number(value, priority) {\n    return token(\"num\" /* Number */, parseFloat(value), priority);\n}\n/**\n * Unary operator factory\n * @param value    Operator  character code\n * @param priority Operator execution priority\n */\nfunction op1(value, priority = 0) {\n    if (value === 45 /* Minus */) {\n        priority += 2;\n    }\n    return token(\"op1\" /* Op1 */, value, priority);\n}\n/**\n * Binary operator factory\n * @param value Operator  character code\n * @param priority Operator execution priority\n */\nfunction op2(value, priority = 0) {\n    if (value === 42 /* Multiply */) {\n        priority += 1;\n    }\n    else if (value === 47 /* Divide */ || value === 92 /* IntDivide */) {\n        priority += 2;\n    }\n    return token(\"op2\" /* Op2 */, value, priority);\n}\nfunction error(name, scanner) {\n    if (scanner) {\n        name += ` at column ${scanner.pos} of expression`;\n    }\n    throw new Error(name);\n}\nfunction isSign(ch) {\n    return isPositiveSign(ch) || isNegativeSign(ch);\n}\nfunction isPositiveSign(ch) {\n    return ch === 43 /* Plus */;\n}\nfunction isNegativeSign(ch) {\n    return ch === 45 /* Minus */;\n}\nfunction isOperator(ch) {\n    return ch === 43 /* Plus */ || ch === 45 /* Minus */ || ch === 42 /* Multiply */\n        || ch === 47 /* Divide */ || ch === 92 /* IntDivide */;\n}\nfunction token(type, value, priority = 0) {\n    return { type, value, priority };\n}\n\nconst defaultOptions = {\n    lookAhead: true,\n    whitespace: true\n};\nfunction extract(text, pos = text.length, options) {\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    const scanner = { text, pos };\n    let ch;\n    if (opt.lookAhead && cur(scanner) === 41 /* RightParenthesis */) {\n        // Basically, we should consume right parenthesis only with optional whitespace\n        scanner.pos++;\n        const len = text.length;\n        while (scanner.pos < len) {\n            ch = cur(scanner);\n            if (ch !== 41 /* RightParenthesis */ && !(opt.whitespace && isSpace(ch))) {\n                break;\n            }\n            scanner.pos++;\n        }\n    }\n    const end = scanner.pos;\n    let braces = 0;\n    while (scanner.pos >= 0) {\n        if (number$1(scanner)) {\n            continue;\n        }\n        ch = prev(scanner);\n        if (ch === 41 /* RightParenthesis */) {\n            braces++;\n        }\n        else if (ch === 40 /* LeftParenthesis */) {\n            if (!braces) {\n                break;\n            }\n            braces--;\n        }\n        else if (!((opt.whitespace && isSpace(ch)) || isSign(ch) || isOperator(ch))) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (scanner.pos !== end && !braces) {\n        // Trim whitespace\n        while (isSpace(cur(scanner))) {\n            scanner.pos++;\n        }\n        return [scanner.pos, end];\n    }\n    return null;\n}\n/**\n * Backward-consumes number from given scanner, if possible\n */\nfunction number$1(scanner) {\n    if (isNumber(prev(scanner))) {\n        scanner.pos--;\n        let dot = false;\n        let ch;\n        while (scanner.pos >= 0) {\n            ch = prev(scanner);\n            if (ch === 46 /* . */) {\n                if (dot) {\n                    // Decimal delimiter already consumed, abort\n                    break;\n                }\n                dot = true;\n            }\n            else if (!isNumber(ch)) {\n                break;\n            }\n            scanner.pos--;\n        }\n        return true;\n    }\n    return false;\n}\nfunction prev(scanner) {\n    return scanner.text.charCodeAt(scanner.pos - 1);\n}\nfunction cur(scanner) {\n    return scanner.text.charCodeAt(scanner.pos);\n}\n\nconst ops1 = {\n    [45 /* Minus */]: num => -num\n};\nconst ops2 = {\n    [43 /* Plus */]: (a, b) => a + b,\n    [45 /* Minus */]: (a, b) => a - b,\n    [42 /* Multiply */]: (a, b) => a * b,\n    [47 /* Divide */]: (a, b) => a / b,\n    [92 /* IntDivide */]: (a, b) => Math.floor(a / b)\n};\n/**\n * Evaluates given math expression\n * @param expr Expression to evaluate\n */\nfunction evaluate(expr) {\n    if (!Array.isArray(expr)) {\n        expr = parse(expr);\n    }\n    if (!expr || !expr.length) {\n        return null;\n    }\n    const nStack = [];\n    let n1;\n    let n2;\n    let f;\n    for (let i = 0, il = expr.length; i < il; i++) {\n        const token = expr[i];\n        if (token.type === \"num\" /* Number */) {\n            nStack.push(token.value);\n        }\n        else if (token.type === \"op2\" /* Op2 */) {\n            n2 = nStack.pop();\n            n1 = nStack.pop();\n            f = ops2[token.value];\n            nStack.push(f(n1, n2));\n        }\n        else if (token.type === \"op1\" /* Op1 */) {\n            n1 = nStack.pop();\n            f = ops1[token.value];\n            nStack.push(f(n1));\n        }\n        else {\n            throw new Error('Invalid expression');\n        }\n    }\n    if (nStack.length > 1) {\n        throw new Error('Invalid Expression (parity)');\n    }\n    return nStack[0];\n}\n\nexport default evaluate;\nexport { extract, parse };\n//# sourceMappingURL=math.es.js.map\n", "import { EditorSelection } from '@codemirror/state';\nimport type { ChangeSpec, SelectionRange, StateCommand } from '@codemirror/state';\nimport evaluate, { extract } from '@emmetio/math-expression';\n\nexport const evaluateMath: StateCommand = ({ state, dispatch }) => {\n    const changes: ChangeSpec[] = [];\n    const nextSel: SelectionRange[] = [];\n\n    for (const sel of state.selection.ranges) {\n        let { from, to } = sel;\n        if (from === to) {\n            const line = state.doc.lineAt(sel.from);\n            const expr = extract(line.text, sel.from - line.from);\n            if (expr) {\n                from = expr[0] + line.from;\n                to = expr[1] + line.from;\n            }\n        }\n\n        if (from !== to) {\n            try {\n                const result = evaluate(state.doc.sliceString(from ,to));\n                if (result !== null) {\n                    const insert = result.toFixed(4).replace(/\\.?0+$/, '');\n                    changes.push({ from, to, insert });\n                    nextSel.push(EditorSelection.range(from + insert.length, from + insert.length));\n                }\n            } catch (err) {\n                nextSel.push(sel);\n                console.error(err);\n            }\n        }\n    }\n\n    if (changes.length) {\n        const tr = state.update({\n            changes,\n            selection: EditorSelection.create(nextSel)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n", "import { EditorSelection } from '@codemirror/state';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { isQuote, isSpace } from '../lib/utils';\n\nexport const goToNextEditPoint: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        selection: getNextSel(state, 1)\n    });\n    dispatch(tr);\n    return true;\n};\n\nexport const goToPreviousEditPoint: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        selection: getNextSel(state, -1)\n    });\n    dispatch(tr);\n    return true;\n};\n\nfunction getNextSel(state: EditorState, inc: number): EditorSelection {\n    const nextSel: SelectionRange[] = [];\n    for (const sel of state.selection.ranges) {\n        const nextPos = findNewEditPoint(state, sel.from + inc, inc);\n        if (nextPos != null) {\n            nextSel.push(EditorSelection.cursor(nextPos));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    return EditorSelection.create(nextSel);\n}\n\nfunction findNewEditPoint(state: EditorState, pos: number, inc: number): number | undefined {\n    const doc = state.doc.toString();\n    const docSize = doc.length;\n    let curPos = pos;\n\n    while (curPos < docSize && curPos >= 0) {\n        curPos += inc;\n        const cur = doc[curPos];\n        const next = doc[curPos + 1];\n        const prev = doc[curPos - 1];\n\n        if (isQuote(cur) && next === cur && prev === '=') {\n            // Empty attribute value\n            return curPos + 1;\n        }\n\n        if (cur === '<' && prev === '>') {\n            // Between tags\n            return curPos;\n        }\n\n        if (isNewLine(cur)) {\n            const line = state.doc.lineAt(curPos + inc);\n            if (!line.length || isSpace(line.text)) {\n                // Empty line\n                return line.from + line.text.length;\n            }\n        }\n    }\n\n    return;\n}\n\nfunction isNewLine(ch: string) {\n    return ch === '\\r' || ch === '\\n';\n}\n", "import { EditorSelection } from '@codemirror/state';\nimport type { SelectionRange, StateCommand } from '@codemirror/state';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { getTagContext } from '../lib/emmet';\n\nexport const goToTagPair: StateCommand = ({ state, dispatch }) => {\n    const nextRanges: SelectionRange[] = [];\n    let found = false;\n    for (const sel of state.selection.ranges) {\n        const pos = sel.from;\n        let nextSel = sel;\n        if (htmlLanguage.isActiveAt(state, pos)) {\n            const ctx = getTagContext(state, pos);\n            if (ctx && ctx.open && ctx.close) {\n                found = true;\n                const { open, close } = ctx;\n                const nextPos = open.from <= pos && pos < open.to\n                    ? close.from\n                    : open.from;\n                nextSel = EditorSelection.cursor(nextPos);\n            }\n        }\n\n        nextRanges.push(nextSel);\n    }\n\n    if (found) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextRanges)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n", "import { EditorSelection } from '@codemirror/state';\nimport type { StateCommand, TransactionSpec } from '@codemirror/state';\nimport type { StateCommandTarget } from '../lib/types';\n\nexport const incrementNumber1: StateCommand = target => incDecNumber(target, 1);\nexport const decrementNumber1: StateCommand = target => incDecNumber(target, -1);\nexport const incrementNumber01: StateCommand = target => incDecNumber(target, .1);\nexport const decrementNumber01: StateCommand = target => incDecNumber(target, -.1);\nexport const incrementNumber10: StateCommand = target => incDecNumber(target, 10);\nexport const decrementNumber10: StateCommand = target => incDecNumber(target, -10);\n\nfunction incDecNumber({ state, dispatch }: StateCommandTarget, delta: number): boolean {\n    const specs: TransactionSpec[] = [];\n\n    for (const sel of state.selection.ranges) {\n        let { from, to } = sel;\n        if (from === to) {\n            // No selection, extract number\n            const line = state.doc.lineAt(from);\n            const numRange = extractNumber(line.text, from - line.from);\n            if (numRange) {\n                from = line.from + numRange[0];\n                to = line.from + numRange[1];\n            }\n        }\n\n        if (from !== to) {\n            // Try to update value in given region\n            let value = updateNumber(state.doc.sliceString(from, to), delta);\n            specs.push({\n                changes: { from, to, insert: value },\n                selection: EditorSelection.range(from, from + value.length)\n            });\n        } else {\n            specs.push({ selection: sel });\n        }\n    }\n\n    if (specs.some(s => s.changes)) {\n        const tr = state.update(...specs);\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Extracts number from text at given location\n */\nfunction extractNumber(text: string, pos: number): [number, number] | undefined {\n    let hasDot = false;\n    let end = pos;\n    let start = pos;\n    let ch: number;\n    const len = text.length;\n\n    // Read ahead for possible numbers\n    while (end < len) {\n        ch = text.charCodeAt(end);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        end++;\n    }\n\n    // Read backward for possible numerics\n    while (start >= 0) {\n        ch = text.charCodeAt(start - 1);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        start--;\n    }\n\n    // Negative number?\n    if (start > 0 && text[start - 1] === '-') {\n        start--;\n    }\n\n    if (start !== end) {\n        return [start, end];\n    }\n\n    return;\n}\n\nfunction updateNumber(num: string, delta: number, precision = 3): string {\n    const value = parseFloat(num) + delta;\n\n    if (isNaN(value)) {\n        return num;\n    }\n\n    const neg = value < 0;\n    let result = Math.abs(value).toFixed(precision);\n\n    // Trim trailing zeroes and optionally decimal number\n    result = result.replace(/\\.?0+$/, '');\n\n    // Trim leading zero if input value doesn't have it\n    if ((num[0] === '.' || num.startsWith('-.')) && result[0] === '0') {\n        result = result.slice(1);\n    }\n\n    return (neg ? '-' : '') + result;\n}\n\nfunction isDot(ch: number) {\n    return ch === 46;\n}\n\n/**\n * Check if given code is a number\n */\nexport function isNumber(code: number): boolean {\n    return code > 47 && code < 58;\n}\n", "import type { ChangeSpec, EditorState, StateCommand, TransactionSpec } from '@codemirror/state';\nimport { getTagContext } from '../lib/emmet';\nimport type { ContextTag } from '../lib/types';\nimport { lineIndent } from '../lib/output';\nimport { narrowToNonSpace, rangeEmpty, isSpace } from '../lib/utils';\n\nexport const removeTag: StateCommand = ({ state, dispatch }) => {\n    const specs: TransactionSpec[] = [];\n    for (const sel of state.selection.ranges) {\n        const tag = getTagContext(state, sel.from);\n        if (tag) {\n            specs.push(removeTagSpec(state, tag));\n        } else {\n            specs.push({ selection: sel });\n        }\n    }\n\n    if (specs.some(t => t.changes)) {\n        const tr = state.update(...specs);\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction removeTagSpec(state: EditorState, { open, close }: ContextTag): TransactionSpec {\n    const changes: ChangeSpec[] = [];\n    if (close) {\n        // Remove open and close tag and dedent inner content\n        const innerRange = narrowToNonSpace(state, { from: open.to, to: close.from });\n        if (!rangeEmpty(innerRange)) {\n            // Gracefully remove open and close tags and tweak indentation on tag contents\n            changes.push({ from: open.from, to: innerRange.from });\n\n            const lineStart = state.doc.lineAt(open.from);\n            const lineEnd = state.doc.lineAt(close.to);\n            if (lineStart.number !== lineEnd.number) {\n                // Skip two lines: first one for open tag, on second one\n                // indentation will be removed with open tag\n                let lineNum = lineStart.number + 2;\n                const baseIndent = getLineIndent(state, open.from);\n                const innerIndent = getLineIndent(state, innerRange.from);\n\n                while (lineNum <= lineEnd.number) {\n                    const line = state.doc.line(lineNum);\n                    if (isSpace(line.text.slice(0, innerIndent.length))) {\n                        changes.push({\n                            from: line.from,\n                            to: line.from + innerIndent.length,\n                            insert: baseIndent\n                        });\n                    }\n                    lineNum++;\n                }\n            }\n\n            changes.push({ from: innerRange.to, to: close.to });\n        } else {\n            changes.push({ from: open.from, to: close.to });\n        }\n    } else {\n        changes.push(open);\n    }\n\n    return { changes };\n}\n\n/**\n * Returns indentation for line found from given character location\n */\nfunction getLineIndent(state: EditorState, pos: number): string {\n    return lineIndent(state.doc.lineAt(pos));\n}\n", "import { syntaxTree } from '@codemirror/language';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { EditorSelection } from '@codemirror/state';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport type { SyntaxNode, TreeCursor } from '@lezer/common';\nimport type { RangeObject, StateCommandTarget } from '../lib/types';\nimport { fullCSSDeclarationRange, isQuote, isSpace, rangeContains, substr } from '../lib/utils';\nimport { getPropertyRanges, getSelectorRange } from '../lib/context';\n\nexport const selectNextItem: StateCommand = target => selectItemCommand(target, false);\nexport const selectPreviousItem: StateCommand = target => selectItemCommand(target, true);\n\nconst htmlParents = new Set(['OpenTag', 'CloseTag', 'SelfClosingTag']);\nconst cssEnter = new Set(['Block', 'RuleSet', 'StyleSheet']);\nconst cssParents = new Set(['RuleSet', 'Block', 'StyleSheet', 'Declaration']);\n\nfunction selectItemCommand({ state, dispatch }: StateCommandTarget, reverse: boolean): boolean {\n    let handled = false;\n    const selections: SelectionRange[] = [];\n    for (const sel of state.selection.ranges) {\n        const range = cssLanguage.isActiveAt(state, sel.from)\n            ? getCSSRange(state, sel, reverse)\n            : getHTMLRange(state, sel, reverse);\n        if (range) {\n            handled = true;\n            selections.push(EditorSelection.range(range.from, range.to));\n        } else {\n            selections.push(sel);\n        }\n    }\n\n    if (handled) {\n        const tr = state.update({\n            selection: EditorSelection.create(selections)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\nfunction getHTMLRange(state: EditorState, sel: SelectionRange, reverse?: boolean): RangeObject | undefined {\n    const node = getStartHTMLNode(state, sel);\n    const cursor = node.cursor();\n\n    do {\n        if (cursor.name === 'OpenTag' || cursor.name === 'SelfClosingTag') {\n            const ranges = getHTMLCandidates(state, cursor.node);\n            const range = findRange(sel, ranges, reverse);\n            if (range) {\n                return range;\n            }\n        }\n    } while (moveHTMLCursor(cursor, reverse));\n\n    return;\n}\n\nfunction getCSSRange(state: EditorState, sel: SelectionRange, reverse?: boolean) {\n    const node = getStartCSSNode(state, sel);\n    const cursor = node.cursor();\n\n    do {\n        const ranges = getCSSCandidates(state, cursor.node);\n        const range = findRange(sel, ranges, reverse);\n        if (range) {\n            return range;\n        }\n    } while (moveCSSCursor(cursor, reverse));\n\n    return;\n}\n\nfunction moveHTMLCursor(cursor: TreeCursor, reverse?: boolean): boolean {\n    const enter = cursor.name === 'Element';\n    return reverse ? cursor.prev(enter) : cursor.next(enter);\n}\n\nfunction moveCSSCursor(cursor: TreeCursor, reverse?: boolean): boolean {\n    const enter = cssEnter.has(cursor.name);\n    return reverse ? cursor.prev(enter) : cursor.next(enter);\n}\n\nfunction getStartHTMLNode(state: EditorState, sel: SelectionRange): SyntaxNode {\n    let node: SyntaxNode = syntaxTree(state).resolveInner(sel.to, 1);\n\n    // In case if we’re inside tag, find closest start node\n    let ctx: SyntaxNode | null = node;\n    while (ctx) {\n        if (htmlParents.has(ctx.name)) {\n            return ctx;\n        }\n        ctx = ctx.parent;\n    }\n\n    return node;\n}\n\nfunction getStartCSSNode(state: EditorState, sel: SelectionRange): SyntaxNode {\n    let node: SyntaxNode = syntaxTree(state).resolveInner(sel.to, 1);\n\n    // In case if we’re inside tag, find closest start node\n    let ctx: SyntaxNode | null = node.parent;\n    while (ctx) {\n        if (cssParents.has(ctx.name)) {\n            return ctx;\n        }\n        ctx = ctx.parent;\n    }\n\n    return node;\n}\n\n/**\n * Returns candidates for selection from given StartTag or SelfClosingTag\n */\nfunction getHTMLCandidates(state: EditorState, node: SyntaxNode): RangeObject[] {\n    let result: RangeObject[] = [];\n    let child = node.firstChild;\n    while (child) {\n        if (child.name === 'TagName') {\n            result.push(child);\n        } else if (child.name === 'Attribute') {\n            result.push(child);\n            const attrName = child.getChild('AttributeName');\n            const attrValue = attrValueRange(state, child);\n            if (attrName && attrValue) {\n                result.push(attrName, attrValue);\n                if (substr(state, attrName).toLowerCase() === 'class') {\n                    // For class names, split value into space-separated tokens\n                    result = result.concat(tokenList(substr(state, attrValue)));\n                }\n            }\n        }\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * Returns candidates for RuleSet node\n */\nfunction getCSSCandidates(state: EditorState, node: SyntaxNode): RangeObject[] {\n    let result: RangeObject[] = [];\n    if (node.name === 'RuleSet') {\n        const selector = getSelectorRange(node);\n        result.push(selector);\n        const block = node.getChild('Block');\n        if (block) {\n            for (const child of block.getChildren('Declaration')) {\n                result = result.concat(getCSSCandidates(state, child));\n            }\n        }\n    } else if (node.name === 'Declaration') {\n        result.push(fullCSSDeclarationRange(node));\n        const { name, value } = getPropertyRanges(node);\n        name && result.push(name);\n        value && result.push(value);\n    }\n\n    return result;\n}\n\nfunction attrValueRange(state: EditorState, attr: SyntaxNode): RangeObject | undefined {\n    const value = attr.getChild('AttributeValue');\n    if (value) {\n        let { from, to } = value;\n        const valueStr = substr(state, value);\n        if (isQuote(valueStr[0])) {\n            from++;\n            if (valueStr[0] === valueStr[valueStr.length - 1]) {\n                to--;\n            }\n        }\n\n        if (from !== to) {\n            return { from, to };\n        }\n    }\n\n    return;\n}\n\n/**\n * Returns ranges of tokens in given value. Tokens are space-separated words.\n */\nfunction tokenList(value: string, offset = 0): RangeObject[] {\n    const ranges: RangeObject[] = [];\n    const len = value.length;\n    let pos = 0;\n    let start = 0;\n    let end = len;\n\n    while (pos < len) {\n        end = pos;\n        const ch = value.charAt(pos++);\n        if (isSpace(ch)) {\n            if (start !== end) {\n                ranges.push({\n                    from: offset + start,\n                    to: offset + end\n                });\n            }\n\n            while (isSpace(value.charAt(pos))) {\n                pos++;\n            }\n\n            start = pos;\n        }\n    }\n\n    if (start !== pos) {\n        ranges.push({\n            from: offset + start,\n            to: offset + pos\n        });\n    }\n\n    return ranges;\n}\n\nfunction findRange(sel: SelectionRange, ranges: RangeObject[], reverse = false): RangeObject | undefined {\n    if (reverse) {\n        ranges = ranges.slice().reverse();\n    }\n\n    let needNext = false;\n    let candidate: RangeObject | undefined;\n\n    for (const r of ranges) {\n        if (needNext) {\n            return r;\n        }\n        if (r.from === sel.from && r.to === sel.to) {\n            // This range is currently selected, request next\n            needNext = true;\n        } else if (!candidate && (rangeContains(r, sel) || (reverse && r.from <= sel.from) || (!reverse && r.from >= sel.from))) {\n            candidate = r;\n        }\n    }\n\n    return !needNext ? candidate : undefined;\n}\n", "import type { ChangeSpec, EditorState, StateCommand } from '@codemirror/state';\nimport { getTagContext } from '../lib/emmet';\nimport { isSpace } from '../lib/utils';\n\nexport const splitJoinTag: StateCommand = ({ state, dispatch }) => {\n    const changes: ChangeSpec[] = [];\n    for (const sel of state.selection.ranges) {\n        const tag = getTagContext(state, sel.from);\n        if (tag) {\n            const { open, close } = tag;\n            if (close) {\n                // Join tag: remove tag contents, if any, and add closing slash\n                let closing = isSpace(getChar(state, open.to - 2)) ? '/' : ' /';\n                changes.push({\n                    from: open.to - 1,\n                    to: close.to,\n                    insert: `${closing}>`\n                });\n            } else {\n                // Split tag: add closing part and remove closing slash\n                let insert = `</${tag.name}>`;\n                let from = open.to;\n                let to = open.to;\n\n                if (getChar(state, open.to - 2) === '/') {\n                    from -= 2;\n                    if (isSpace(getChar(state, from - 1))) {\n                        from--;\n                    }\n                    insert = '>' + insert;\n                }\n\n                changes.push({ from, to, insert });\n            }\n        }\n    }\n\n    if (changes.length) {\n        const tr = state.update({ changes });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction getChar(state: EditorState, pos: number): string {\n    return state.doc.sliceString(pos, pos + 1);\n}\n", "import type { UserConfig } from 'emmet';\nimport { EditorView, keymap, ViewPlugin } from '@codemirror/view';\nimport type { ViewUpdate } from '@codemirror/view';\nimport { EditorState, StateEffect, StateField } from '@codemirror/state';\nimport type { Extension, StateCommand, } from '@codemirror/state';\nimport { undo } from '@codemirror/commands';\nimport { expand, getOptions, getTagContext } from '../lib/emmet';\nimport { getSelectionsFromSnippet, narrowToNonSpace, rangeEmpty, substr } from '../lib/utils';\nimport type { RangeObject, ContextTag } from '../lib/types';\nimport { lineIndent } from '../lib/output';\n\ninterface WrapAbbreviation {\n    abbreviation: string;\n    range: RangeObject;\n    options: UserConfig;\n    context?: ContextTag;\n}\n\nconst updateAbbreviation = StateEffect.define<WrapAbbreviation | null>();\n\nconst wrapAbbreviationField = StateField.define<WrapAbbreviation | null>({\n    create: () => null,\n    update(value, tr) {\n        for (const effect of tr.effects) {\n            if (effect.is(updateAbbreviation)) {\n                value = effect.value;\n            }\n        }\n        return value;\n    }\n});\n\nconst wrapTheme = EditorView.baseTheme({\n    '.emmet-wrap-with-abbreviation': {\n        position: 'absolute',\n        top: 0,\n        zIndex: 2,\n        width: '100%'\n    },\n    '.emmet-wrap-with-abbreviation__content': {\n        background: '#fff',\n        margin: '0 auto',\n        padding: '5px',\n        boxSizing: 'border-box',\n        width: '100%',\n        maxWidth: '30em',\n        borderBottomLeftRadius: '5px',\n        borderBottomRightRadius: '5px',\n        boxShadow: '0 3px 10px rgba(0, 0, 0, 0.3)',\n    },\n    '.emmet-wrap-with-abbreviation__content input': {\n        width: '100%',\n        boxSizing: 'border-box'\n    }\n});\n\nconst enterWrapWithAbbreviation: StateCommand = ({ state, dispatch }) => {\n    const abbr = state.field(wrapAbbreviationField);\n    if (abbr === null) {\n        const sel = state.selection.main;\n        const context = getTagContext(state, sel.from);\n        const wrapRange = getWrapRange(state, sel, context);\n        const options = getOptions(state, wrapRange.from);\n        options.text = getContent(state, wrapRange);\n\n        const tr = state.update({\n            effects: [updateAbbreviation.of({\n                abbreviation: '',\n                range: wrapRange,\n                options,\n                context\n            })]\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\nconst wrapWithAbbreviationPlugin = ViewPlugin.fromClass(class WrapWithAbbreviationViewPlugin {\n    private widget: HTMLElement | null = null;\n    private input: HTMLInputElement | null = null;\n\n    update(update: ViewUpdate) {\n        const { state, view } = update;\n        const abbr = state.field(wrapAbbreviationField);\n        if (abbr) {\n            if (!this.widget) {\n                this.createInputPanel(view);\n            }\n            this.updateAbbreviation(abbr.abbreviation);\n        } else if (this.widget) {\n            this.disposeWidget();\n            view.focus();\n        }\n    }\n\n    // TODO use @codemirror/panel instead\n    private createInputPanel(view: EditorView) {\n        const widget = document.createElement('div');\n        widget.className = 'emmet-wrap-with-abbreviation';\n\n        const content = document.createElement('div');\n        content.className = 'emmet-wrap-with-abbreviation__content';\n\n        const input = document.createElement('input');\n        input.placeholder = 'Enter abbreviation';\n\n        let updated = false;\n\n        const undoUpdate = () => {\n            if (updated) {\n                undo(view);\n                updated = false;\n            }\n        };\n\n        input.addEventListener('input', () => {\n            const abbr = view.state.field(wrapAbbreviationField);\n            if (abbr) {\n                const nextAbbreviation = input.value;\n                undoUpdate();\n\n                const nextAbbr: WrapAbbreviation = {\n                    ...abbr,\n                    abbreviation: nextAbbreviation\n                };\n\n                if (nextAbbr.abbreviation) {\n                    updated = true;\n                    const { from, to } = nextAbbr.range;\n                    const expanded = expand(view.state, nextAbbr.abbreviation, nextAbbr.options);\n                    const { ranges, snippet } = getSelectionsFromSnippet(expanded, from);\n                    const nextSel = ranges[0];\n\n                    view.dispatch({\n                        effects: [updateAbbreviation.of(nextAbbr)],\n                        changes: [{\n                            from,\n                            to,\n                            insert: snippet\n                        }],\n                        selection: {\n                            head: nextSel.from,\n                            anchor: nextSel.to\n                        }\n                    });\n                } else {\n                    view.dispatch({\n                        effects: [updateAbbreviation.of(nextAbbr)],\n                    });\n                }\n            }\n        });\n\n        input.addEventListener('keydown', evt => {\n            if (evt.key === 'Escape' || evt.key === 'Enter') {\n                if (evt.key === 'Escape') {\n                    undoUpdate();\n                }\n                evt.preventDefault();\n                view.dispatch({\n                    effects: [updateAbbreviation.of(null)]\n                });\n            }\n        });\n\n        content.append(input)\n        widget.append(content);\n        view.dom.append(widget);\n        this.widget = widget;\n        this.input = input;\n        input.focus();\n    }\n\n    private updateAbbreviation(value: string) {\n        if (this.input && this.input.value !== value) {\n            this.input.value = value;\n        }\n    }\n\n    private disposeWidget() {\n        if (this.widget) {\n            this.widget.remove();\n            this.widget = this.input = null;\n        }\n    }\n});\n\nexport function wrapWithAbbreviation(key = 'Ctrl-w'): Extension[] {\n    return [\n        wrapAbbreviationField,\n        wrapWithAbbreviationPlugin,\n        wrapTheme,\n        keymap.of([{\n            key,\n            run: enterWrapWithAbbreviation\n        }])\n    ];\n}\n\nfunction getWrapRange(editor: EditorState, range: RangeObject, context?: ContextTag): RangeObject {\n    if (rangeEmpty(range) && context) {\n        // No selection means user wants to wrap current tag container\n        const { open, close } = context;\n        const pos = range.from;\n\n        // Check how given point relates to matched tag:\n        // if it's in either open or close tag, we should wrap tag itself,\n        // otherwise we should wrap its contents\n\n        if (inRange(open, pos) || (close && inRange(close, pos))) {\n            return {\n                from: open.from,\n                to: close ? close.to : open.to\n            };\n        }\n\n        if (close) {\n            return narrowToNonSpace(editor, { from: open.to, to: close.from });\n        }\n    }\n\n    return range;\n}\n\nfunction inRange(range: RangeObject, pt: number): boolean {\n    return range.from < pt && pt < range.to;\n}\n\n/**\n * Returns contents of given region, properly de-indented\n */\nfunction getContent(state: EditorState, range: RangeObject): string | string[] {\n    const baseIndent = lineIndent(state.doc.lineAt(range.from));\n    const srcLines = substr(state, range).split('\\n');\n    const destLines = srcLines.map(line => {\n        return line.startsWith(baseIndent)\n            ? line.slice(baseIndent.length)\n            : line;\n    });\n\n    return destLines;\n}\n"],
  "mappings": "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",
  "names": ["keymap", "isNumber", "code", "isAlpha", "from", "to", "isAlphaNumericWord", "isAlphaWord", "isWhiteSpace", "isSpace", "isQuote", "Scanner", "str", "start", "end", "match", "ch", "ok", "n", "message", "pos", "ScannerError", "tokenScanner", "tokens", "peek", "scanner", "next", "slice", "readable", "consume", "test", "token", "error", "err", "abbreviation", "abbr", "options", "result", "statements", "ctx", "node", "stack", "element", "group", "isChildOperator", "isSiblingOperator", "isClimbOperator", "isGroupStart", "isBracket", "repeater", "attr", "elem", "elementName", "isEmpty", "isRepeater", "text", "getText", "shortAttribute", "attributeSet", "isCloseOperator", "isAttributeSetStart", "attributes", "attribute", "isAttributeSetEnd", "type", "isOperator", "createLiteral", "literal", "quoted", "isEquals", "quote", "allowBrackets", "brackets", "isCapitalizedLiteral", "isClassNameOperator", "isElementName", "isTextStart", "context", "isOpen", "isSingle", "isLiteral", "value", "escaped", "tokenize", "source", "getToken", "field", "repeaterPlaceholder", "repeaterNumber", "repeater$1", "whiteSpace", "literal$1", "operator", "bracket", "isAllowedOperator", "isElementName$1", "isAllowedSpace", "isAllowedRepeater", "isQuote$1", "bracketType", "isOpenBracket", "op", "operatorType", "count", "implicit", "size", "reverse", "base", "parent", "index", "name", "consumePlaceholder", "stream", "operators", "tokenVisitor", "state", "i", "lastIx", "parentIx", "parentRepeater", "stringify", "urlRegex", "emailRegex", "convert", "textInserted", "cleanText", "s", "convertGroup", "_a", "varValue", "deepest", "deepestNode", "last", "insertText", "insertHref", "convertStatement", "original", "repeat", "items", "isGroup", "convertElement", "target", "children", "stringifyName", "stringifyValue", "child", "convertAttribute", "isField", "attachRepeater", "implied", "isBoolean", "valueType", "arr", "href", "hrefAttribute", "item", "parseAbbreviation", "isValue", "mergeTokens", "shouldConsumeDashAfter", "short", "numberValue", "colorValue", "stringValue", "isIdentPrefix", "isKeyword", "consumeNumber", "rawValue", "finished", "valueStart", "color", "alpha", "isHex", "colorAlpha", "r", "g", "b", "a", "parseColor", "afterNegative", "hasDecimal", "prevPos", "hasFloat", "parser", "property", "consumeProperty", "important", "valueFragment", "valueMode", "isLiteral$1", "isFunctionStart", "isValueDelimiter", "isImportant", "consumeValue", "isFragmentDelimiter", "inArgument", "args", "consumeArguments", "isCloseBracket", "isArgumentDelimiter", "isBracket$1", "open", "t1", "t2", "parse", "mergeAttributes", "config", "lookup", "attrName", "prev", "mergeValue", "mergeDeclarations", "glue", "append", "t", "dest", "src", "walk", "fn", "ancestors", "callback", "findDeepest", "isNode", "resolveSnippets", "reversed", "resolve", "snippet", "snippetAbbr", "parse$2", "walkResolve", "topNode", "mergeNodes", "resolved", "createOutputStream", "level", "push", "processText", "_push", "pushString", "lines", "splitByLines", "il", "pushNewline", "indent", "baseIndent", "newline", "pushIndent", "pushField", "placeholder", "tagName", "strCase", "attrQuote", "isBooleanAttribute", "selfClose", "isInline", "elementMap", "implicitTag", "resolveImplicitTag", "getParentElement", "contextName", "parentName", "lowercase", "latin", "ru", "sp", "vocabularies", "reLorem", "lorem", "m", "db", "minWordCount", "maxWordCount", "wordCount", "rand", "findRepeater", "paragraph", "sample", "len", "iterations", "choice", "val", "sentence", "words", "capitalize", "word", "insertCommas", "hasComma", "totalCommas", "dict", "startWithCommon", "totalWords", "jsx", "rename", "xsl", "matchesName", "isAllowed", "reElement", "reModifier", "blockCandidates1", "className", "blockCandidates2", "bem", "expandClassNames", "expandShortNotation", "data", "getBEMData", "classNames", "cl", "ix", "uniqueClass", "findBlockName", "updateClass", "path", "prefix", "originalClass", "getBlockName", "arrClassNames", "classValue", "parseBEM", "getBEMDataFromContext", "depth", "find", "filter", "walk$1", "visitor", "current", "createWalkState", "caret", "isSnippet", "isInlineElement", "pushTokens", "out", "largestIndex", "splitByLines$1", "line", "shouldOutputAttribute", "template", "offset", "namePos", "afterPos", "isTokenStart", "isToken", "createCommentState", "commentNodeBefore", "shouldComment", "output", "commentNodeAfter", "comment", "attrs", "htmlTagRegex", "html", "format", "shouldFormat", "getIndent", "pushAttribute", "pushSnippet", "innerFormat", "hasNewline", "startsWithBlockTag", "lQuote", "rQuote", "fieldIx", "adjacentInline", "before", "after", "matches", "indentFormat", "element$1", "primary", "secondary", "collectAttributes", "shouldFormat$1", "pushPrimaryAttributes", "pushSecondaryAttributes", "pushValue", "isPrimaryAttribute", "lineLengths", "maxLength", "valueLength", "haml", "slim", "pug", "formatters", "oldTextValue", "parseOpt", "transform", "reProperty", "opt", "createSnippet", "key", "keywords", "parsed", "parseValue", "cssVal", "collectKeywords", "nest", "snippets", "snippetsSort", "cur", "isProperty", "parse$3", "v", "scoreMatch", "str1", "str2", "partialMatch", "str1Len", "str2Len", "minLength", "j", "score", "ch1", "ch2", "found", "acronym", "matchRatio", "delta", "maxScore", "sum", "shortHex", "asHex", "asRGB", "isShortHex", "toShortHex", "toHex", "values", "frac", "num", "digits", "hex", "pad", "css", "isJSON", "toCamelCase", "propertyValue", "outputImportant", "outputToken", "getSingleNumeric", "getQuote", "outputValue", "separator", "prevEnd", "_", "letter", "gradientName", "parse$1", "convertSnippets", "isValueScope", "filteredSnippets", "getSnippetsForScope", "resolveNode", "resolveGradient", "propName", "resolveValueKeywords", "findBestMatch", "resolveAsProperty", "resolveAsSnippet", "resolveNumericValue", "gradientFn", "cssValue", "inlineValue", "getUnmatchedPart", "kw", "resolveKeyword", "defaultValue", "hasField", "wrapWithField", "minScore", "reField", "inputValue", "tail", "matchedItem", "getScoringPart", "lastPos", "ref", "dep", "aliases", "unitless", "q", "markupSnippets", "stylesheetSnippets", "xslSnippets", "pugSnippets", "variables", "defaultSyntaxes", "defaultOptions", "defaultConfig", "syntaxConfig", "parseSnippets", "k", "resolveConfig", "globals", "syntax", "mergedData", "typeDefaults", "typeOverride", "syntaxDefaults", "syntaxOverride", "backwardScanner", "sol", "peek$1", "previous", "consumeWhile", "c", "consumeQuoted", "bracePairs", "isHtml", "consumeIdent", "consumeAttributeWithUnquotedValue", "consumeAttribute", "consumeAttributeWithQuotedValue", "isUnquotedValue", "isIdent", "specialChars", "defaultOptions$1", "extractAbbreviation", "offsetPastAutoClosed", "getStartOffset", "isCloseBrace", "isOpenBrace", "isAbbreviation", "compiledPrefix", "consumePair", "consumeArray", "close", "consumed", "expandAbbreviation", "resolvedConfig", "stylesheet", "markup", "tabStopStart", "tabStopEnd", "narrowToNonSpace", "range", "substr", "startOffset", "endOffset", "getCaret", "contains", "fullCSSDeclarationRange", "getAttributeValueRange", "getTagAttributes", "attrNameNode", "attrValueNode", "rangesEqual", "rangeContains", "rangeEmpty", "getSelectionsFromSnippet", "ranges", "sel", "nodeToHTMLType", "getContext", "cssLanguage", "getCSSContext", "htmlLanguage", "getHTMLContext", "embedded", "tree", "syntaxTree", "getSelectorRange", "getPropertyRanges", "tip", "getContextMatchFromTag", "__spreadProps", "__spreadValues", "detectCSSContextFromHTML", "getAttributeName", "attrValue", "cleanValueRange", "getInlineCSSContext", "ptr", "props", "parseInlineProps", "prop", "limit", "space", "propList", "xmlSyntaxes", "htmlSyntaxes", "cssSyntaxes", "jsxSyntaxes", "stylesheetSyntaxes", "syntaxInfo", "docSyntax", "inline", "getSyntaxType", "topLang", "language", "isXML", "isHTML", "isCSS", "isJSX", "getMarkupAbbreviationContext", "getStylesheetAbbreviationContext", "scope", "cache", "expand", "outputOpt", "pluginConfig", "getEmmetConfig", "extract", "getTagContext", "getTagName", "openTag", "closeTag", "getOptions", "info", "getOutputOptions", "resetCache", "Facet", "baseConfig", "preview", "conf", "lineIndent", "createPreview", "ext", "view", "EditorView", "EditorState", "syntaxHighlighting", "defaultHighlightStyle", "nextValue", "tr", "icon", "emmetCompletionSource", "tracker", "trackerField", "_from", "_to", "completionOptionsFromTracker", "cssCompletion", "JSX_PREFIX", "trackerMark", "Decoration", "resetTracker", "StateEffect", "forceTracker", "enterAbbreviationMode", "dispatch", "StateField", "pickedCompletion", "effect", "getActivationContext", "createTracker", "handleUpdate", "abbreviationPreview", "getAbbreviationPreview", "tooltip", "f", "showTooltip", "prevTooltip", "completionStatus", "canDisplayPreview", "previewConfig", "dom", "abbreviationTracker", "ViewPlugin", "__publicField", "update", "decors", "expandTracker", "expanded", "tabKeyHandler", "escKeyHandler", "trackerTheme", "keymap", "typingAbbreviation", "input", "canStartTyping", "getSyntaxFromPos", "getCSSActivationContext", "isTypingBeforeSelector", "isValidPrefix", "isValidAbbreviationStart", "params", "forced", "hasInvalidChars", "parsedAbbr", "simple", "markupAbbreviation", "isSimpleMarkupAbbreviation", "createPreviewConfig", "first", "previewField", "hasSnippet", "_fromA", "_toA", "fromB", "_toB", "fromA", "toA", "toB", "removed", "inserted", "abbrRange", "nextTracker", "completionInfo", "completion", "balanceOutward", "nextSel", "hasMatch", "getOutwardRanges", "targetRange", "EditorSelection", "getOutwardRanges", "state", "pos", "cssLanguage", "getCSSOutwardRanges", "htmlLanguage", "getHTMLOutwardRanges", "getHTMLOutwardRanges", "state", "pos", "result", "tree", "syntaxTree", "node", "pushHTMLRanges", "compactRanges", "getCSSOutwardRanges", "state", "pos", "result", "node", "syntaxTree", "pushCSSRanges", "compactRanges", "pushHTMLRanges", "node", "ranges", "selfClose", "open", "close", "pushCSSRanges", "state", "pos", "narrowToNonSpace", "name", "value", "getPropertyRanges", "contains", "fullCSSDeclarationRange", "compactRanges", "inward", "result", "a", "b", "range", "prev", "last", "htmlComment", "cssComment", "toggleComment", "state", "dispatch", "changes", "sel", "cssLanguage", "toggleCSSComment", "htmlLanguage", "toggleHTMLComment", "tr", "pos", "result", "ctx", "getContextOfType", "stripComment", "addComment", "types", "names", "node", "syntaxTree", "comment", "innerRange", "narrowToNonSpace", "lang", "to", "_a", "stripChildComments", "block", "child", "isNumber", "code", "isWhiteSpace", "isSpace", "Scanner", "str", "start", "end", "match", "ch", "ok", "n", "message", "ScannerError", "nullary", "token", "parse", "expr", "scanner", "priority", "expected", "tokens", "consumeNumber", "error", "number", "isOperator", "isSign", "isNegativeSign", "op1", "op2", "orderTokens", "operators", "operands", "nOperators", "i", "t", "value", "name", "isPositiveSign", "type", "defaultOptions", "extract", "text", "options", "opt", "cur", "len", "braces", "number$1", "prev", "dot", "ops1", "num", "ops2", "a", "b", "evaluate", "nStack", "n1", "n2", "f", "il", "evaluateMath", "nextSel", "from", "line", "insert", "EditorSelection", "err", "goToNextEditPoint", "getNextSel", "goToPreviousEditPoint", "inc", "nextPos", "findNewEditPoint", "doc", "docSize", "curPos", "next", "isQuote", "isNewLine", "goToTagPair", "nextRanges", "found", "getTagContext", "open", "close", "incrementNumber1", "target", "incDecNumber", "decrementNumber1", "incDecNumber", "state", "dispatch", "delta", "specs", "sel", "from", "to", "line", "numRange", "extractNumber", "value", "updateNumber", "EditorSelection", "s", "tr", "text", "pos", "hasDot", "end", "start", "ch", "len", "isDot", "isNumber", "num", "precision", "neg", "result", "code", "removeTag", "tag", "getTagContext", "removeTagSpec", "t", "open", "close", "changes", "innerRange", "narrowToNonSpace", "rangeEmpty", "lineStart", "lineEnd", "lineNum", "baseIndent", "getLineIndent", "innerIndent", "isSpace", "lineIndent", "selectNextItem", "target", "selectItemCommand", "selectPreviousItem", "htmlParents", "cssEnter", "cssParents", "reverse", "handled", "selections", "range", "cssLanguage", "getCSSRange", "getHTMLRange", "cursor", "getStartHTMLNode", "ranges", "getHTMLCandidates", "findRange", "moveHTMLCursor", "getStartCSSNode", "getCSSCandidates", "moveCSSCursor", "enter", "node", "syntaxTree", "ctx", "child", "attrName", "attrValue", "attrValueRange", "substr", "tokenList", "selector", "getSelectorRange", "block", "fullCSSDeclarationRange", "name", "getPropertyRanges", "attr", "valueStr", "isQuote", "offset", "needNext", "candidate", "r", "rangeContains", "splitJoinTag", "closing", "getChar", "insert", "updateAbbreviation", "StateEffect", "wrapAbbreviationField", "StateField", "effect", "wrapTheme", "EditorView", "enterWrapWithAbbreviation", "context", "wrapRange", "getWrapRange", "options", "getOptions", "getContent", "wrapWithAbbreviationPlugin", "ViewPlugin", "__publicField", "update", "view", "abbr", "widget", "content", "input", "updated", "undoUpdate", "undo", "nextAbbreviation", "nextAbbr", "__spreadProps", "__spreadValues", "expanded", "expand", "snippet", "getSelectionsFromSnippet", "nextSel", "evt", "wrapWithAbbreviation", "key", "keymap", "editor", "inRange", "pt", "emmet", "tracker", "wrapWithAbbreviation", "keymap", "expandAbbreviation", "enterAbbreviationMode", "balanceOutward", "toggleComment", "evaluateMath", "goToPreviousEditPoint", "goToNextEditPoint", "goToTagPair", "incrementNumber1", "decrementNumber1", "removeTag", "splitJoinTag", "selectNextItem", "selectPreviousItem"]
}
