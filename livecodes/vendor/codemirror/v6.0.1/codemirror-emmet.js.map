{
  "version": 3,
  "sources": ["../../../../../src/livecodes/editor/codemirror/codemirror-emmet.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/node_modules/emmet/dist/emmet.es.js", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/utils.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/context.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/types.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/output.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/emmet.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/config.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/lib/syntax.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/tracker/AbbreviationPreviewWidget.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/completion-icon.svg", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/tracker/index.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/expand.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/balance.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/comment.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/node_modules/@emmetio/scanner/scanner.js", "../../../../../node_modules/@emmetio/codemirror6-plugin/node_modules/@emmetio/math-expression/dist/math.es.js", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/evaluate-math.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/go-to-edit-point.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/go-to-tag-pair.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/inc-dec-number.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/remove-tag.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/select-item.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/split-join-tag.ts", "../../../../../node_modules/@emmetio/codemirror6-plugin/src/commands/wrap-with-abbreviation.ts"],
  "sourcesContent": ["import { keymap } from '@codemirror/view';\nimport {\n  abbreviationTracker,\n  expandAbbreviation,\n  enterAbbreviationMode,\n  balanceOutward,\n  toggleComment,\n  evaluateMath,\n  goToNextEditPoint,\n  goToPreviousEditPoint,\n  goToTagPair,\n  incrementNumber1,\n  decrementNumber1,\n  removeTag,\n  selectNextItem,\n  selectPreviousItem,\n  splitJoinTag,\n  wrapWithAbbreviation,\n} from '@emmetio/codemirror6-plugin';\n\nexport const emmet = [\n  abbreviationTracker(),\n  wrapWithAbbreviation(),\n  keymap.of([\n    {\n      key: 'Cmd-e',\n      run: expandAbbreviation,\n    },\n    {\n      key: 'Cmd-Shift-e',\n      run: enterAbbreviationMode,\n    },\n    {\n      key: 'Cmd-Shift-d',\n      run: balanceOutward,\n    },\n    {\n      key: 'Ctrl-/',\n      run: toggleComment,\n    },\n    {\n      key: 'Ctrl-y',\n      run: evaluateMath,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowLeft',\n      run: goToPreviousEditPoint,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowRight',\n      run: goToNextEditPoint,\n    },\n    {\n      key: 'Ctrl-g',\n      run: goToTagPair,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowUp',\n      run: incrementNumber1,\n    },\n    {\n      key: 'Ctrl-Alt-ArrowDown',\n      run: decrementNumber1,\n    },\n    {\n      key: \"Ctrl-'\",\n      run: removeTag,\n    },\n    {\n      key: \"Ctrl-Shift-'\",\n      run: splitJoinTag,\n    },\n    {\n      key: 'Ctrl-.',\n      run: selectNextItem,\n    },\n    {\n      key: 'Ctrl-,',\n      run: selectPreviousItem,\n    },\n  ]),\n];\n", "/**\n * Check if given code is a number\n */\nfunction isNumber$1(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha$1(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber$1(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha$1(code);\n}\n/**\n * Check for Umlauts i.e. ä, Ä, ö, Ö, ü and Ü\n */\nfunction isUmlaut(code) {\n    return code === 196\n        || code == 214\n        || code === 220\n        || code === 228\n        || code === 246\n        || code === 252;\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace$3(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace$3(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote$2(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nfunction tokenScanner$1(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$3(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable$1(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$2(scanner, test) {\n    const token = peek$3(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error$1(scanner, message, token = peek$3(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner$1(abbr);\n    const result = statements(scanner, options);\n    if (readable$1(scanner)) {\n        throw error$1(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable$1(scanner)) {\n        if (node = element$2(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume$2(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume$2(scanner, isSiblingOperator$1)) {\n                continue;\n            }\n            else if (consume$2(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume$2(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume$2(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket$2(token, 'group', false)) {\n            result.repeat = repeater$1(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element$2(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable$1(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume$2(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume$2(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume$2(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume$2(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable$1(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume$2(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume$2(scanner, isWhiteSpace$2)) {\n                throw error$1(scanner, `Unexpected \"${peek$3(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator$1(peek$3(scanner), type)) {\n        scanner.pos++;\n        // Consume multiple operators\n        let count = 1;\n        while (isOperator$1(peek$3(scanner), type)) {\n            scanner.pos++;\n            count++;\n        }\n        const attr = {\n            name: [createLiteral$1(type)]\n        };\n        if (count > 1) {\n            attr.multiple = true;\n        }\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal$1$1(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal$1$1(scanner, true)) {\n        const name = slice(scanner);\n        let value;\n        if (consume$2(scanner, isEquals)) {\n            if (quoted(scanner) || literal$1$1(scanner, true)) {\n                value = slice(scanner);\n            }\n        }\n        return { name, value };\n    }\n}\nfunction repeater$1(scanner) {\n    return isRepeater(peek$3(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek$3(scanner);\n    if (isQuote$1(quote)) {\n        scanner.pos++;\n        while (readable$1(scanner)) {\n            if (isQuote$1(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error$1(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal$1$1(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable$1(scanner)) {\n        const token = peek$3(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket$2(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote$1(token) || isOperator$1(token) || isWhiteSpace$2(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket$2(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume$2(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable$1(scanner)) {\n            const { pos } = scanner;\n            if (!consume$2(scanner, isClassNameOperator) || !consume$2(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable$1(scanner) && consume$2(scanner, isElementName$1)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume$2(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable$1(scanner)) {\n            const token = next(scanner);\n            if (isBracket$2(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket$2(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket$2(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket$2(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator$1(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote$1(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace$2(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator$1(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral$2(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral$2(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName$1(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator$1(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket$2(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket$2(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket$2(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket$2(token, 'group', true);\n}\nfunction createLiteral$1(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator$1(token, 'child');\n}\nfunction isSiblingOperator$1(token) {\n    return isOperator$1(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator$1(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator$1(token, 'close');\n}\n\nvar Chars$3;\n(function (Chars) {\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `\\\\` character */\n    Chars[Chars[\"Escape\"] = 92] = \"Escape\";\n    /** `=` character */\n    Chars[Chars[\"Equals\"] = 61] = \"Equals\";\n    /** `[` character */\n    Chars[Chars[\"SquareBracketOpen\"] = 91] = \"SquareBracketOpen\";\n    /** `]` character */\n    Chars[Chars[\"SquareBracketClose\"] = 93] = \"SquareBracketClose\";\n    /** `*` character */\n    Chars[Chars[\"Asterisk\"] = 42] = \"Asterisk\";\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `>` character */\n    Chars[Chars[\"Child\"] = 62] = \"Child\";\n    /** `^` character */\n    Chars[Chars[\"Climb\"] = 94] = \"Climb\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n})(Chars$3 || (Chars$3 = {}));\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(Chars$3.Escape)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize$1(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken$1(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken$1(scanner, ctx) {\n    return field$2(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater(scanner)\n        || whiteSpace$1(scanner)\n        || literal$2(scanner, ctx)\n        || operator$1(scanner)\n        || quote(scanner)\n        || bracket$1(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$2(scanner, ctx) {\n    const start = scanner.pos;\n    const expressionStart = ctx.expression;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === Chars$3.Slash && !ctx.quote && !ctx.expression && !ctx.attribute) {\n            // Special case for `/` character between numbers in class names\n            const prev = scanner.string.charCodeAt(scanner.pos - 1);\n            const next = scanner.string.charCodeAt(scanner.pos + 1);\n            if (isNumber$1(prev) && isNumber$1(next)) {\n                value += scanner.string[scanner.pos++];\n                continue;\n            }\n        }\n        if (ch === ctx.quote || ch === Chars$3.Dollar || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (expressionStart) {\n            // Consume nested expressions, e.g. span{{foo}}\n            if (ch === Chars$3.CurlyBracketOpen) {\n                ctx.expression++;\n            }\n            else if (ch === Chars$3.CurlyBracketClose) {\n                if (ctx.expression > expressionStart) {\n                    ctx.expression--;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else if (!ctx.quote) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$2(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$2(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === Chars$3.SingleQuote,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket$1(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket$2(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator$1(scanner) {\n    const op = operatorType$1(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$3.Asterisk)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber$1)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.Hash)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(Chars$3.Dollar)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(Chars$3.At)) {\n            // Consume numbering modifiers\n            while (scanner.eat(Chars$3.Climb)) {\n                parent++;\n            }\n            reverse = scanner.eat(Chars$3.Dash);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber$1)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field$2(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(Chars$3.Dollar) && scanner.eat(Chars$3.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars$3.Colon) ? consumePlaceholder$2(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder$2(scanner);\n        }\n        if (scanner.eat(Chars$3.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$2(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars$3.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars$3.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType$1(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === Chars$3.Asterisk && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === Chars$3.RoundBracketOpen || ch === Chars$3.RoundBracketClose) {\n        return 'group';\n    }\n    if (ch === Chars$3.SquareBracketOpen || ch === Chars$3.SquareBracketClose) {\n        return 'attribute';\n    }\n    if (ch === Chars$3.CurlyBracketOpen || ch === Chars$3.CurlyBracketClose) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType$1(ch) {\n    return (ch === Chars$3.Child && 'child')\n        || (ch === Chars$3.Sibling && 'sibling')\n        || (ch === Chars$3.Climb && 'climb')\n        || (ch === Chars$3.Dot && 'class')\n        || (ch === Chars$3.Hash && 'id')\n        || (ch === Chars$3.Slash && 'close')\n        || (ch === Chars$3.Equals && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket$2(ch) {\n    return ch === Chars$3.CurlyBracketOpen\n        || ch === Chars$3.SquareBracketOpen\n        || ch === Chars$3.RoundBracketOpen;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName(ch) {\n    return isAlphaNumericWord(ch)\n        || isUmlaut(ch)\n        || ch === Chars$3.Dash\n        || ch === Chars$3.Colon\n        || ch === Chars$3.Excl;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify$1(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last$1(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last$1(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue$1(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField$1)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote$1(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last$1(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket$2(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket$2(last$1(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue$1(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType,\n        multiple: node.multiple\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify$1(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue$1(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField$1(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify$1(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField$1(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last$1(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last$1(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize$1(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nvar OperatorType;\n(function (OperatorType) {\n    OperatorType[\"Sibling\"] = \"+\";\n    OperatorType[\"Important\"] = \"!\";\n    OperatorType[\"ArgumentDelimiter\"] = \",\";\n    OperatorType[\"ValueDelimiter\"] = \"-\";\n    OperatorType[\"PropertyDelimiter\"] = \":\";\n})(OperatorType || (OperatorType = {}));\n\nvar Chars$2;\n(function (Chars) {\n    /** `#` character */\n    Chars[Chars[\"Hash\"] = 35] = \"Hash\";\n    /** `$` character */\n    Chars[Chars[\"Dollar\"] = 36] = \"Dollar\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `.` character */\n    Chars[Chars[\"Dot\"] = 46] = \"Dot\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `,` character */\n    Chars[Chars[\"Comma\"] = 44] = \"Comma\";\n    /** `!` character */\n    Chars[Chars[\"Excl\"] = 33] = \"Excl\";\n    /** `@` character */\n    Chars[Chars[\"At\"] = 64] = \"At\";\n    /** `%` character */\n    Chars[Chars[\"Percent\"] = 37] = \"Percent\";\n    /** `_` character */\n    Chars[Chars[\"Underscore\"] = 95] = \"Underscore\";\n    /** `(` character */\n    Chars[Chars[\"RoundBracketOpen\"] = 40] = \"RoundBracketOpen\";\n    /** `)` character */\n    Chars[Chars[\"RoundBracketClose\"] = 41] = \"RoundBracketClose\";\n    /** `{` character */\n    Chars[Chars[\"CurlyBracketOpen\"] = 123] = \"CurlyBracketOpen\";\n    /** `}` character */\n    Chars[Chars[\"CurlyBracketClose\"] = 125] = \"CurlyBracketClose\";\n    /** `+` character */\n    Chars[Chars[\"Sibling\"] = 43] = \"Sibling\";\n    /** `'` character */\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    /** `\"` character */\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    /** `t` character */\n    Chars[Chars[\"Transparent\"] = 116] = \"Transparent\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n})(Chars$2 || (Chars$2 = {}));\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field$1(scanner)\n        || customProperty(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, short);\n}\nfunction field$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dollar) && scanner.eat(Chars$2.CurlyBracketOpen)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(Chars$2.Colon) ? consumePlaceholder$1(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder$1(scanner);\n        }\n        if (scanner.eat(Chars$2.CurlyBracketClose)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$1(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(Chars$2.CurlyBracketOpen)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(Chars$2.CurlyBracketClose)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal$1(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral$1);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral$1 : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(Chars$2.Dot);\n        scanner.eatWhile(isLiteral$1);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(Chars$2.Percent) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote$2(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === Chars$2.SingleQuote ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Hash)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(Chars$2.Transparent)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dot)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber$1)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes custom CSS property: --foo-bar\n */\nfunction customProperty(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(Chars$2.Dash) && scanner.eat(Chars$2.Dash)) {\n        scanner.start = start;\n        scanner.eatWhile(isKeyword);\n        return {\n            type: 'CustomProperty',\n            value: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket$1(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === Chars$2.RoundBracketOpen,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(Chars$2.Dash);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber$1);\n    const prevPos = stream.pos;\n    if (stream.eat(Chars$2.Dot)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber$1);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === Chars$2.At || code === Chars$2.Dollar;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === Chars$2.Sibling && OperatorType.Sibling)\n        || (ch === Chars$2.Excl && OperatorType.Important)\n        || (ch === Chars$2.Comma && OperatorType.ArgumentDelimiter)\n        || (ch === Chars$2.Colon && OperatorType.PropertyDelimiter)\n        || (ch === Chars$2.Dash && OperatorType.ValueDelimiter)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber$1(code) || isAlpha$1(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === Chars$2.Dash;\n}\nfunction isBracket$1(code) {\n    return code === Chars$2.RoundBracketOpen || code === Chars$2.RoundBracketClose;\n}\nfunction isLiteral$1(code) {\n    return isAlphaWord(code) || code === Chars$2.Percent || code === Chars$2.Slash;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$2(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$1(scanner, test) {\n    if (test(peek$2(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek$2(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume$1(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek$2(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume$1(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume$1(scanner, isWhiteSpace$1);\n    }\n    while (readable(scanner)) {\n        if (consume$1(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume$1(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek$2(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace$1(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume$1(scanner, isOpenBracket$1)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume$1(scanner, isCloseBracket$1)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume$1(scanner, isWhiteSpace$1) && !consume$1(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket$1(token) {\n    return isBracket(token, true);\n}\nfunction isCloseBracket$1(token) {\n    return isBracket(token, false);\n}\nfunction isWhiteSpace$1(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, OperatorType.Sibling);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, OperatorType.ArgumentDelimiter);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, OperatorType.Important);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field'\n        || token.type === 'CustomProperty';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, OperatorType.PropertyDelimiter)\n        || isOperator(token, OperatorType.ValueDelimiter);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse$2(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk$1(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds first child node that matches given `callback`\n */\nfunction find$1(node, callback) {\n    for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (callback(child)) {\n            return child;\n        }\n        const result = find$1(child, callback);\n        if (result) {\n            return result;\n        }\n    }\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const { warn } = config;\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        let snippetAbbr;\n        try {\n            // User may add invlid snippet. In this case, silently bail out\n            snippetAbbr = parseAbbreviation(snippet, config);\n        }\n        catch (err) {\n            warn === null || warn === void 0 ? void 0 : warn(`Unable to parse \"${snippet}\" snippet`, err);\n            return null;\n        }\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nconst expressionStart = '{';\nconst expressionEnd = '}';\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines$1(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? expressionStart : expressionEnd;\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines$1(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\n/**\n * Preprocessor of `<label>` element: if it contains `<input>`, remove `for` attribute\n * and `id` from input\n */\nfunction label(node) {\n    if (node.name === 'label') {\n        const input = find$1(node, n => (n.name === 'input' || n.name === 'textarea'));\n        if (input) {\n            // Remove empty `for` attribute\n            if (node.attributes) {\n                node.attributes = node.attributes.filter(attr => {\n                    return !(attr.name === 'for' && isEmptyAttribute(attr));\n                });\n            }\n            // Remove empty `id` attribute\n            if (input.attributes) {\n                input.attributes = input.attributes.filter(attr => {\n                    return !(attr.name === 'id' && isEmptyAttribute(attr));\n                });\n            }\n        }\n    }\n}\nfunction isEmptyAttribute(attr) {\n    if (!attr.value) {\n        return true;\n    }\n    if (attr.value.length === 1) {\n        const token = attr.value[0];\n        if (token && typeof token !== 'string' && !token.name) {\n            // Attribute contains field\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction walk(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\nvar TemplateChars;\n(function (TemplateChars) {\n    /** `[` character */\n    TemplateChars[TemplateChars[\"Start\"] = 91] = \"Start\";\n    /** `]` character */\n    TemplateChars[TemplateChars[\"End\"] = 93] = \"End\";\n    /* `_` character */\n    TemplateChars[TemplateChars[\"Underscore\"] = 95] = \"Underscore\";\n    /* `-` character */\n    TemplateChars[TemplateChars[\"Dash\"] = 45] = \"Dash\";\n})(TemplateChars || (TemplateChars = {}));\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek$1(scanner) === TemplateChars.Start) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek$1(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek$1(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === TemplateChars.Start) {\n                    stack++;\n                }\n                else if (code === TemplateChars.End) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek$1(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === TemplateChars.Underscore\n        || code === TemplateChars.Dash;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nconst reservedKeywords = new Set([\n    'for', 'while', 'of', 'async', 'await', 'const', 'let', 'var', 'continue',\n    'break', 'debugger', 'do', 'export', 'import', 'in', 'instanceof', 'new', 'return',\n    'switch', 'this', 'throw', 'try', 'catch', 'typeof', 'void', 'with', 'yield'\n]);\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat$1(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const attributes = config.options['markup.attributes'];\n        const valuePrefix = config.options['markup.valuePrefix'];\n        let { name, value } = attr;\n        let lQuote = attrQuote(attr, config, true);\n        let rQuote = attrQuote(attr, config);\n        if (attributes) {\n            name = getMultiValue(name, attributes, attr.multiple) || name;\n        }\n        name = attrName(name, config);\n        if (config.options['jsx.enabled'] && attr.multiple) {\n            lQuote = expressionStart;\n            rQuote = expressionEnd;\n        }\n        const prefix = valuePrefix\n            ? getMultiValue(attr.name, valuePrefix, attr.multiple)\n            : null;\n        if (prefix && (value === null || value === void 0 ? void 0 : value.length) === 1 && typeof value[0] === 'string') {\n            // Add given prefix in object notation\n            const val = value[0];\n            value = [isPropKey(val) ? `${prefix}.${val}` : `${prefix}['${val}']`];\n            if (config.options['jsx.enabled']) {\n                lQuote = expressionStart;\n                rQuote = expressionEnd;\n            }\n        }\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat$1(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat$1(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getMultiValue(key, data, multiple) {\n    return (multiple && data[`${key}*`]) || data[key];\n}\nfunction isPropKey(name) {\n    return !reservedKeywords.has(name) && /^[a-zA-Z_$][\\w_$]*$/.test(name);\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        const parseOpt = Object.assign({}, config);\n        if (config.options['jsx.enabled']) {\n            parseOpt.jsx = true;\n        }\n        if (config.options['markup.href']) {\n            parseOpt.href = true;\n        }\n        abbr = parseAbbreviation(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk$1(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.type === 'markup') {\n        label(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nvar CSSSnippetType;\n(function (CSSSnippetType) {\n    CSSSnippetType[\"Raw\"] = \"Raw\";\n    CSSSnippetType[\"Property\"] = \"Property\";\n})(CSSSnippetType || (CSSSnippetType = {}));\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: CSSSnippetType.Property,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: CSSSnippetType.Raw, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$2(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === CSSSnippetType.Property;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nconst CSSAbbreviationScope = {\n    /** Include all possible snippets in match */\n    Global: '@@global',\n    /** Include raw snippets only (e.g. no properties) in abbreviation match */\n    Section: '@@section',\n    /** Include properties only in abbreviation match */\n    Property: '@@property',\n    /** Resolve abbreviation in context of CSS property value */\n    Value: '@@value',\n};\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === CSSAbbreviationScope.Section) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal' || token.type === 'CustomProperty') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    const result = [];\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$2(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        const resolved = resolveNode(node, filteredSnippets, config);\n        if (resolved) {\n            result.push(resolved);\n        }\n    }\n    return result;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === CSSSnippetType.Property && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                const resolved = snippet.type === CSSSnippetType.Property\n                    ? resolveAsProperty(node, snippet, config)\n                    : resolveAsSnippet(node, snippet);\n                if (resolved) {\n                    node = resolved;\n                }\n                else if (config.options['stylesheet.strictMatch']) {\n                    return null;\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return null;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return null;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === CSSAbbreviationScope.Value || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === CSSAbbreviationScope.Section) {\n            return snippets.filter(s => s.type === CSSSnippetType.Raw);\n        }\n        if (config.context.name === CSSAbbreviationScope.Property) {\n            return snippets.filter(s => s.type === CSSSnippetType.Property);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:refresh\": \"meta[http-equiv=refresh content='${1:5}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"script:module\": \"script[type=module src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1}]\",\n\t\"tarea:c|textarea:cols\":\"textarea[name=${1} id=${1} cols=${2:30}]\",\n\t\"tarea:r|textarea:rows\":\"textarea[name=${1} id=${1} rows=${3:10}]\",\n\t\"tarea:cr|textarea:cols:rows\":\"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:b|button:b|button:button\" : \"button[type=button]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\t\"data\": \"data[value]\",\n\t\"meter\": \"meter[value]\",\n\t\"time\": \"time[datetime]\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n  \"bbs\": \"border-block-start\",\n  \"bbe\": \"border-block-end\",\n  \"bis\": \"border-inline-start\",\n  \"bie\": \"border-inline-end\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bg:n\": \"background: none\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:${1:#fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n  \"bs\": \"block-size\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n  \"cg\": \"column-gap\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|contents|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"g\": \"gap\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n  \"is\": \"inline-size\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n  \"mbs\": \"margin-block-start\",\n  \"mbe\": \"margin-block-end\",\n  \"mis\": \"margin-inline-start\",\n  \"mie\": \"margin-inline-end\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width:thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n  \"pbs\": \"padding-block-start\",\n  \"pbe\": \"padding-block-end\",\n  \"pis\": \"padding-inline-start\",\n  \"pie\": \"padding-inline-end\",\n  \"spbs\": \"scroll-padding-block-start\",\n  \"spbe\": \"scroll-padding-block-end\",\n  \"spis\": \"scroll-padding-inline-start\",\n  \"spie\": \"scroll-padding-inline-end\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n  \"rg\": \"row-gap\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w|wid\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wido\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions$1 = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0,\n    'stylesheet.strictMatch': false\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions$1\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true,\n            'markup.attributes': {\n                'class': 'className',\n                'class*': 'styleName',\n                'for': 'htmlFor'\n            },\n            'markup.valuePrefix': {\n                'class*': 'styles'\n            }\n        }\n    },\n    vue: {\n        options: {\n            'markup.attributes': {\n                'class*': ':class',\n            }\n        }\n    },\n    svelte: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek(scanner))\n        : match === peek(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\nvar Chars$1;\n(function (Chars) {\n    Chars[Chars[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    Chars[Chars[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    Chars[Chars[\"Escape\"] = 92] = \"Escape\";\n})(Chars$1 || (Chars$1 = {}));\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === Chars$1.SingleQuote || c === Chars$1.DoubleQuote;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek(scanner) !== Chars$1.Escape) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nvar Brackets;\n(function (Brackets) {\n    Brackets[Brackets[\"SquareL\"] = 91] = \"SquareL\";\n    Brackets[Brackets[\"SquareR\"] = 93] = \"SquareR\";\n    Brackets[Brackets[\"RoundL\"] = 40] = \"RoundL\";\n    Brackets[Brackets[\"RoundR\"] = 41] = \"RoundR\";\n    Brackets[Brackets[\"CurlyL\"] = 123] = \"CurlyL\";\n    Brackets[Brackets[\"CurlyR\"] = 125] = \"CurlyR\";\n})(Brackets || (Brackets = {}));\nconst bracePairs = {\n    [Brackets.SquareL]: Brackets.SquareR,\n    [Brackets.RoundL]: Brackets.RoundR,\n    [Brackets.CurlyL]: Brackets.CurlyR,\n};\n\nvar Chars;\n(function (Chars) {\n    Chars[Chars[\"Tab\"] = 9] = \"Tab\";\n    Chars[Chars[\"Space\"] = 32] = \"Space\";\n    /** `-` character */\n    Chars[Chars[\"Dash\"] = 45] = \"Dash\";\n    /** `/` character */\n    Chars[Chars[\"Slash\"] = 47] = \"Slash\";\n    /** `:` character */\n    Chars[Chars[\"Colon\"] = 58] = \"Colon\";\n    /** `=` character */\n    Chars[Chars[\"Equals\"] = 61] = \"Equals\";\n    /** `<` character */\n    Chars[Chars[\"AngleLeft\"] = 60] = \"AngleLeft\";\n    /** `>` character */\n    Chars[Chars[\"AngleRight\"] = 62] = \"AngleRight\";\n})(Chars || (Chars = {}));\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, Chars.AngleRight)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, Chars.Slash); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, Chars.Slash)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, Chars.AngleLeft);\n                break;\n            }\n            else if (consume(scanner, Chars.AngleLeft)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, Chars.Equals)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === Chars.Colon || ch === Chars.Dash || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === Chars.Space || ch === Chars.Tab;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== Chars.Equals && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === Brackets.CurlyL || ch === Brackets.RoundL || ch === Brackets.SquareL;\n}\nfunction isCloseBracket(ch) {\n    return ch === Brackets.CurlyR || ch === Brackets.RoundR || ch === Brackets.SquareR;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek(scanner);\n        if (stack.includes(Brackets.CurlyR)) {\n            if (ch === Brackets.CurlyR) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== Brackets.CurlyL) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(Brackets.SquareR) || stack.includes(Brackets.CurlyR)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, Brackets.SquareR, Brackets.SquareL) || consumePair(scanner, Brackets.CurlyR, Brackets.CurlyL)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === Brackets.RoundL || (syntax === 'markup' && (ch === Brackets.SquareL || ch === Brackets.CurlyL));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === Brackets.RoundR || (syntax === 'markup' && (ch === Brackets.SquareR || ch === Brackets.CurlyR));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse$1(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse(abbr, config), config);\n}\n\nexport { CSSAbbreviationScope, expandAbbreviation as default, extractAbbreviation as extract, markup, parseAbbreviation as markupAbbreviation, parse$1 as parseMarkup, parse as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet, parse$2 as stylesheetAbbreviation };\n//# sourceMappingURL=emmet.es.js.map\n", "import type { EditorState } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { RangeObject } from './types';\n\n/** Characters to indicate tab stop start and end in generated snippet */\nexport const tabStopStart = String.fromCodePoint(0xFFF0);\nexport const tabStopEnd = String.fromCodePoint(0xFFF1);\nexport const stateKey = '$$emmet';\n\nexport interface AbbrError {\n    message: string,\n    pos: number\n}\n\nexport type DisposeFn = () => void;\n\nexport interface EmmetState {\n    id: string;\n    tracker?: DisposeFn | null;\n    tagMatch?: DisposeFn | null;\n}\n\n/**\n * Returns copy of region which starts and ends at non-space character\n */\nexport function narrowToNonSpace(state: EditorState, range: RangeObject): RangeObject {\n\n    const text = substr(state, range);\n    let startOffset = 0;\n    let endOffset = text.length;\n\n    while (startOffset < endOffset && isSpace(text[startOffset])) {\n        startOffset++;\n    }\n\n    while (endOffset > startOffset && isSpace(text[endOffset - 1])) {\n        endOffset--;\n    }\n\n    return {\n        from: range.from + startOffset,\n        to: range.from + endOffset\n    };\n}\n\n/**\n * Returns current caret position for single selection\n */\nexport function getCaret(state: EditorState): number {\n    return state.selection.main.from;\n}\n\n/**\n * Returns contents of given range or node\n */\nexport function substr(state: EditorState, range: RangeObject): string {\n    return state.doc.sliceString(range.from, range.to);\n}\n\n/**\n * Check if given range or syntax name contains given position\n */\nexport function contains(range: RangeObject, pos: number): boolean {\n    return pos >= range.from && pos <= range.to;\n}\n\n/**\n * Returns range of full CSS declaration\n */\nexport function fullCSSDeclarationRange(node: SyntaxNode): RangeObject {\n    return {\n        from: node.from,\n        to: node.nextSibling?.name === ';' ? node.nextSibling.to : node.to\n    };\n}\n\nexport function isQuote(ch: string | undefined) {\n    return ch === '\"' || ch === \"'\";\n}\n\n/**\n * Returns own (unquoted) attribute value range\n */\nexport function getAttributeValueRange(state: EditorState, node: RangeObject): RangeObject {\n    let { from, to } = node;\n    const value = substr(state, node);\n    if (isQuote(value[0])) {\n        from++;\n    }\n\n    if (isQuote(value[value.length - 1])) {\n        to--;\n    }\n\n    return { from, to };\n}\n\n/**\n * Returns given HTML element’s attributes as map\n */\nexport function getTagAttributes(state: EditorState, node: SyntaxNode): Record<string, string | null> {\n    const result: Record<string, string | null> = {};\n    for (const attr of node.getChildren('Attribute')) {\n        const attrNameNode = attr.getChild('AttributeName');\n        if (attrNameNode) {\n            const attrName = substr(state, attrNameNode);\n            const attrValueNode = attr.getChild('AttributeValue');\n            result[attrName] = attrValueNode ? substr(state, getAttributeValueRange(state, attrValueNode)) : null;\n        }\n    }\n\n    return result;\n}\nexport function isSpace(ch: string): boolean {\n    return /^[\\s\\n\\r]+$/.test(ch);\n}\n\nexport function htmlEscape(str: string): string {\n    const replaceMap: Record<string, string> = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n    };\n    return str.replace(/[<>&]/g, ch => replaceMap[ch]);\n}\n\n/**\n * Check if `a` and `b` contains the same range\n */\nexport function rangesEqual(a: RangeObject, b: RangeObject): boolean {\n    return a.from === b.from && a.to === b.to;\n}\n\n/**\n * Check if range `a` fully contains range `b`\n */\nexport function rangeContains(a: RangeObject, b: RangeObject): boolean {\n    return a.from <= b.from && a.to >= b.to;\n}\n\n/**\n * Check if given range is empty\n */\nexport function rangeEmpty(r: RangeObject): boolean {\n    return r.from === r.to;\n}\n\n/**\n * Returns last element in given array\n */\nexport function last<T>(arr: T[]): T | undefined {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * Finds and collects selections ranges from given snippet\n */\nexport function getSelectionsFromSnippet(snippet: string, base = 0): { ranges: RangeObject[], snippet: string } {\n    // Find and collect selection ranges from snippet\n    const ranges: RangeObject[] = [];\n    let result = '';\n    let sel: RangeObject | null = null;\n    let offset = 0;\n    let i = 0;\n    let ch: string;\n\n    while (i < snippet.length) {\n        ch = snippet.charAt(i++);\n        if (ch === tabStopStart || ch === tabStopEnd) {\n            result += snippet.slice(offset, i - 1);\n            offset = i;\n\n            if (ch === tabStopStart) {\n                sel = {\n                    from: base + result.length,\n                    to: base + result.length\n                };\n                ranges.push(sel);\n            } else if (sel) {\n                sel = null;\n            }\n        }\n    }\n\n    if (!ranges.length) {\n        ranges.push({\n            from: snippet.length + base,\n            to: snippet.length + base\n        });\n    }\n\n    return {\n        ranges,\n        snippet: result + snippet.slice(offset)\n    };\n}\n", "import { syntaxTree } from '@codemirror/language';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { EditorState } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { CSSContext, CSSMatch, HTMLAncestor, HTMLContext, HTMLType, RangeObject } from './types';\nimport { contains, getAttributeValueRange, substr } from './utils';\n\n// TODO use RangeObject instead of TextRange\n\ninterface InlineProp {\n    name: RangeObject;\n    value?: RangeObject;\n}\n\nconst nodeToHTMLType: Record<string, HTMLType> = {\n    OpenTag: 'open',\n    CloseTag: 'close',\n    SelfClosingTag: 'selfClose'\n};\n\nexport function getContext(state: EditorState, pos: number): HTMLContext | CSSContext | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSContext(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLContext(state, pos);\n    }\n\n    // const topLang = state.facet(language);\n    // if (topLang === htmlLanguage) {\n    //     // HTML syntax may embed CSS\n    //     return cssLanguage.isActiveAt(state, pos)\n    //         ? getCSSContext(state, pos)\n    //         : getHTMLContext(state, pos);\n    // }\n\n    // if (topLang === cssLanguage) {\n    //     return getCSSContext(state, pos);\n    // }\n\n    return;\n}\n\n/**\n * Returns CSS context for given location in source code\n */\nexport function getCSSContext(state: EditorState, pos: number, embedded?: RangeObject) {\n    const result: CSSContext = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: false,\n        embedded\n    };\n\n    const tree = syntaxTree(state).resolveInner(pos, -1);\n    const stack: CSSMatch[] = [];\n\n    for (let node: SyntaxNode | null = tree; node; node = node.parent) {\n        if (node.name === 'RuleSet') {\n            const sel = getSelectorRange(node);\n            stack.push({\n                name: substr(state, sel),\n                type: 'selector',\n                range: node\n            });\n        } else if (node.name === 'Declaration') {\n            const { name, value } = getPropertyRanges(node);\n            if (value && contains(value, pos)) {\n                // Direct hit on CSS value\n                stack.push({\n                    name: substr(state, value),\n                    type: 'propertyValue',\n                    range: value\n                });\n            }\n\n            if (name) {\n                stack.push({\n                    name: substr(state, name),\n                    type: 'propertyName',\n                    range: name\n                });\n            }\n        }\n    }\n\n    const tip = stack.shift();\n\n    // Check if stack tip contains current position: make it current\n    // context item if so\n    if (tip) {\n        const range: RangeObject = tip.type === 'selector'\n            ? { from: tip.range.from, to: tip.range.from + tip.name.length }\n            : tip.range;\n        if (contains(range, pos)) {\n            result.current = tip;\n            tip.range = range;\n        } else {\n            stack.unshift(tip);\n        }\n    }\n\n    result.ancestors = stack.reverse()\n    return result;\n}\n\nexport function getHTMLContext(state: EditorState, pos: number): HTMLContext {\n    const result: HTMLContext = {\n        type: 'html',\n        ancestors: [],\n        current: null,\n    };\n\n    const tree = syntaxTree(state).resolveInner(pos);\n\n    for (let node: SyntaxNode | null = tree; node; node = node ? node.parent : null) {\n        if (node.name in nodeToHTMLType) {\n            const m = getContextMatchFromTag(state, node);\n            if (m) {\n                result.current = {\n                    ...m,\n                    type: nodeToHTMLType[node.name]\n                };\n\n                // Skip `Element` parent from ancestors stack\n                node = node.parent;\n            }\n        } else if (node.name === 'Element') {\n            const child = node.getChild('OpenTag');\n            if (child) {\n                const m = getContextMatchFromTag(state, child);\n                if (m) {\n                    result.ancestors.push(m);\n                }\n            }\n        }\n    }\n\n    result.ancestors.reverse();\n    detectCSSContextFromHTML(state, pos, result);\n    return result;\n}\n\nfunction detectCSSContextFromHTML(state: EditorState, pos: number, ctx: HTMLContext) {\n    if (ctx.current?.type === 'open') {\n        // Maybe inline CSS? E.g. style=\"...\" attribute\n        let node: SyntaxNode | null = syntaxTree(state).resolve(ctx.current.range.from, 1);\n        while (node && node.name !== 'OpenTag') {\n            node = node.parent;\n        }\n\n        if (node) {\n            for (const attr of node.getChildren('Attribute')) {\n                if (attr.from > pos) {\n                    break;\n                }\n\n                if (contains(attr, pos) && getAttributeName(state, attr) === 'style') {\n                    const attrValue = attr.getChild('AttributeValue');\n                    if (attrValue) {\n                        const cleanValueRange = getAttributeValueRange(state, attrValue);\n                        if (contains(cleanValueRange, pos)) {\n                            ctx.css = getInlineCSSContext(substr(state, cleanValueRange), pos - cleanValueRange.from, cleanValueRange.from);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction getContextMatchFromTag(state: EditorState, node: SyntaxNode): HTMLAncestor | void {\n    const tagName = node.getChild('TagName');\n    if (tagName) {\n        return {\n            name: substr(state, tagName).toLowerCase(),\n            range: node\n        };\n    }\n}\n\n/**\n * Returns range of CSS selector from given rule block\n */\nexport function getSelectorRange(node: SyntaxNode): RangeObject {\n    let from = node.from;\n    let to = from;\n    for (let child = node.firstChild; child && child.name !== 'Block'; child = child.nextSibling) {\n        to = child.to;\n    }\n\n    return { from, to };\n}\n\n/**\n * Returns CSS property name and value ranges.\n * @param node The `name: Declaration` node\n */\nexport function getPropertyRanges(node: SyntaxNode): { name: RangeObject | undefined, value: RangeObject | undefined } {\n    let name: RangeObject | undefined;\n    let value: RangeObject | undefined;\n    let ptr = node.firstChild;\n    if (ptr?.name === 'PropertyName') {\n        name = ptr;\n        ptr = ptr.nextSibling;\n        if (ptr?.name === ':') {\n            ptr = ptr.nextSibling;\n        }\n\n        if (ptr) {\n            value = {\n                from: ptr.from,\n                to: node.lastChild!.to\n            };\n        }\n    }\n\n    return { name, value };\n}\n\nfunction getAttributeName(state: EditorState, node: SyntaxNode): string {\n    const name = node.getChild('AttributeName');\n    return name ? substr(state, name).toLowerCase() : '';\n}\n\n/**\n * Returns context for inline CSS\n */\nexport function getInlineCSSContext(code: string, pos: number, base = 0): CSSContext {\n    // Currently, CodeMirror doesn’t provide syntax highlighting so we’ll perform\n    // quick and naive persing of CSS properties\n    const result: CSSContext = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: true,\n        embedded: {\n            from: pos + base,\n            to: pos + base + code.length\n        }\n    };\n\n    const props = parseInlineProps(code, pos);\n\n    for (const prop of props) {\n        if (prop.value && contains(prop.value, pos)) {\n            result.current = {\n                name: code.substring(prop.value.from, prop.value.to).trim(),\n                type: 'propertyValue',\n                range: {\n                    from: base + prop.value.from,\n                    to: base + prop.value.to\n                }\n            };\n            result.ancestors.push({\n                name: code.substring(prop.name.from, prop.name.to).trim(),\n                type: 'propertyName',\n                range: {\n                    from: base + prop.name.from,\n                    to: base + prop.value.to\n                }\n            });\n            break;\n        } else if (contains(prop.name, pos)) {\n            const end = prop.value ? prop.value.to : prop.name.to;\n            result.current = {\n                name: code.substring(prop.name.from, prop.name.to).trim(),\n                type: 'propertyName',\n                range: {\n                    from: base + prop.name.from,\n                    to: base + end\n                }\n            };\n            break;\n        }\n    }\n\n    return result;\n}\n\nexport function parseInlineProps(code: string, limit = code.length): InlineProp[] {\n    const space = ' \\t\\n\\r';\n    const propList: InlineProp[] = [];\n    let prop: InlineProp | undefined;\n\n    for (let i = 0; i < code.length; i++) {\n        const ch = code[i];\n        if (prop) {\n            if (prop.value) {\n                if (prop.value.from !== -1) {\n                    prop.value.to = i;\n                }\n            } else {\n                prop.name.to = i;\n            }\n        }\n\n        if (ch === ';') {\n            prop = undefined;\n            if (i > limit) {\n                break;\n            }\n        } else if (ch === ':') {\n            if (prop && !prop.value) {\n                prop.value = { from: -1, to: -1 };\n            }\n        } else {\n            if (prop) {\n                if (prop.value?.from === -1 && !space.includes(ch)) {\n                    prop.value.from = prop.value.to = i;\n                }\n            } else if (!space.includes(ch)) {\n                prop = {\n                    name: { from: i, to: i }\n                };\n                propList.push(prop);\n            }\n        }\n    }\n\n    // Finalize state for trailing character\n    if (prop) {\n        if (prop.value) {\n            prop.value.to++;\n        } else {\n            prop.name.to++;\n        }\n    }\n\n    return propList;\n}\n", "import type { AbbreviationContext, UserConfig } from 'emmet';\nimport type { EditorState, Transaction } from '@codemirror/state';\n\nexport enum EmmetKnownSyntax {\n  html = 'html',\n  xml = 'xml',\n  xsl = 'xsl',\n  jsx = 'jsx',\n  tsx = 'tsx',\n  vue = 'vue',\n  haml = 'haml',\n  jade = 'jade',\n  pug = 'pug',\n  slim = 'slim',\n  css = 'css',\n  scss = 'scss',\n  less = 'less',\n  sass = 'sass',\n  sss = 'sss',\n  stylus = 'stylus',\n  postcss = 'postcss'\n}\n\nexport type CSSTokenType = 'selector' | 'propertyName' | 'propertyValue';\n\nexport interface RangeObject {\n    from: number;\n    to: number;\n}\n\nexport interface ContextTag extends AbbreviationContext {\n    open: RangeObject;\n    close?: RangeObject;\n}\n\nexport interface CSSMatch {\n    /** CSS selector, property or section name */\n    name: string;\n    /** Type of ancestor element */\n    type: CSSTokenType;\n    /** Range of selector or section (just name, not entire block) */\n    range: RangeObject;\n}\n\nexport interface CSSContext<M = CSSMatch> {\n    type: 'css',\n\n    /** List of ancestor sections for current context */\n    ancestors: M[];\n\n    /** CSS match directly under given position */\n    current: M | null;\n\n    /** Whether CSS context is inline, e.g. in `style=\"\"` HTML attribute */\n    inline: boolean;\n\n    /**\n     * If current CSS context is embedded into HTML, this property contains\n     * range of CSS source in original content\n     */\n    embedded?: RangeObject;\n}\n\nexport type HTMLType = 'open' | 'close' | 'selfClose';\n\nexport interface HTMLContext {\n    type: 'html',\n    /** List of ancestor elements for current context */\n    ancestors: HTMLAncestor[];\n    /** Tag match directly under given position */\n    current: HTMLMatch | null;\n    /** CSS context, if any */\n    css?: CSSContext;\n}\n\nexport interface HTMLAncestor {\n    /** Element name */\n    name: string;\n    /** Range of element’s open tag in source code */\n    range: RangeObject;\n}\n\nexport interface HTMLMatch {\n    /** Element name */\n    name: string;\n    /** Element type */\n    type: HTMLType;\n    /** Range of matched element in source code */\n    range: RangeObject;\n}\n\nexport interface StateCommandTarget {\n    state: EditorState;\n    dispatch: (transaction: Transaction) => void;\n}\n\nexport interface AbbreviationError {\n    message: string;\n    pos: number;\n}\n\nexport interface StartTrackingParams {\n    config: UserConfig;\n    offset?: number;\n    forced?: boolean;\n}\n", "import type { Options } from 'emmet';\nimport type { EditorState, Line } from '@codemirror/state';\nimport getEmmetConfig from './config';\nimport { isHTML, docSyntax } from './syntax';\nimport { EmmetKnownSyntax } from './types';\n\nexport default function getOutputOptions(state: EditorState, inline?: boolean): Partial<Options> {\n    const syntax = docSyntax(state) || EmmetKnownSyntax.html;\n    const config = getEmmetConfig(state);\n\n    const opt: Partial<Options> = {\n        // 'output.baseIndent': lineIndent(state.doc.lineAt(pos)),\n        // 'output.indent': getIndentation(state),\n        'output.field': field,\n        'output.indent': '\\t',\n        'output.format': !inline,\n        'output.attributeQuotes': config.attributeQuotes,\n        'stylesheet.shortHex': config.shortHex\n    };\n\n    if (syntax === EmmetKnownSyntax.html) {\n        opt['output.selfClosingStyle'] = config.markupStyle;\n        opt['output.compactBoolean'] = config.markupStyle === 'html';\n    }\n\n    if (isHTML(syntax)) {\n        if (config.comments) {\n            opt['comment.enabled'] = true;\n            if (config.commentsTemplate) {\n                opt['comment.after'] = config.commentsTemplate;\n            }\n        }\n\n        opt['bem.enabled'] = config.bem;\n    }\n\n    return opt;\n}\n\n/**\n * Produces tabstop for CodeMirror editor\n */\nexport function field(index: number, placeholder?: string) {\n    return placeholder ? `\\${${index}:${placeholder}}` : `\\${${index}}`;\n}\n\n/**\n * Returns indentation of given line\n */\nexport function lineIndent(line: Line): string {\n    const indent = line.text.match(/^\\s+/);\n    return indent ? indent[0] : '';\n}\n\n/**\n * Returns token used for single indentation in given editor\n */\nexport function getIndentation(state: EditorState): string {\n    const { tabSize } = state;\n    return tabSize ? ' '.repeat(tabSize) : '\\t';\n}\n", "import type { EditorState } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport type { SyntaxNode } from '@lezer/common';\nimport expandAbbreviation, { extract as extractAbbreviation, resolveConfig } from 'emmet';\nimport type { UserConfig, AbbreviationContext, ExtractedAbbreviation, Options, ExtractOptions, MarkupAbbreviation, StylesheetAbbreviation, SyntaxType } from 'emmet';\nimport { syntaxInfo, getMarkupAbbreviationContext, getStylesheetAbbreviationContext } from './syntax';\nimport { getTagAttributes, substr } from './utils';\nimport getEmmetConfig from './config';\nimport getOutputOptions, { field } from './output';\nimport { EmmetKnownSyntax, type ContextTag } from './types';\n\nexport interface ExtractedAbbreviationWithContext extends ExtractedAbbreviation {\n    context?: AbbreviationContext;\n    inline?: boolean;\n}\n\n/**\n * Cache for storing internal Emmet data.\n * TODO reset whenever user settings are changed\n */\nlet cache = {};\n\nexport const JSX_PREFIX = '<';\n\n/**\n * Expands given abbreviation into code snippet\n */\nexport function expand(state: EditorState, abbr: string | MarkupAbbreviation | StylesheetAbbreviation, config?: UserConfig) {\n    let opt: UserConfig = { cache };\n    const outputOpt: Partial<Options> = {\n        'output.field': field,\n    };\n\n    if (config) {\n        Object.assign(opt, config);\n        if (config.options) {\n            Object.assign(outputOpt, config.options);\n        }\n    }\n\n    opt.options = outputOpt;\n\n    const pluginConfig = getEmmetConfig(state);\n    if (pluginConfig.config) {\n        opt = resolveConfig(opt, pluginConfig.config);\n    }\n\n    return expandAbbreviation(abbr as string, opt);\n}\n\n/**\n * Extracts abbreviation from given source code by detecting actual syntax context.\n * For example, if host syntax is HTML, it tries to detect if location is inside\n * embedded CSS.\n *\n * It also detects if abbreviation is allowed at given location: HTML tags,\n * CSS selectors may not contain abbreviations.\n * @param code Code from which abbreviation should be extracted\n * @param pos Location at which abbreviation should be expanded\n * @param type Syntax of abbreviation to expand\n */\nexport function extract(code: string, pos: number, type: SyntaxType = 'markup', options?: Partial<ExtractOptions>): ExtractedAbbreviation | undefined {\n    return extractAbbreviation(code, pos, {\n        lookAhead: type !== 'stylesheet',\n        type,\n        ...options\n    });\n}\n\n/**\n * Returns matched HTML/XML tag for given point in view\n */\nexport function getTagContext(state: EditorState, pos: number): ContextTag | undefined {\n    let element: SyntaxNode | null = syntaxTree(state).resolve(pos, 1);\n    while (element && element.name !== 'Element') {\n        element = element.parent;\n    }\n\n    if (element) {\n        const selfClose = element.getChild('SelfClosingTag');\n        if (selfClose) {\n            return {\n                name: getTagName(state, selfClose),\n                attributes: getTagAttributes(state, selfClose),\n                open: selfClose\n            }\n        }\n\n        const openTag = element.getChild('OpenTag');\n        if (openTag) {\n            const closeTag = element.getChild('CloseTag');\n            const ctx: ContextTag = {\n                name: getTagName(state, openTag),\n                attributes: getTagAttributes(state, openTag),\n                open: openTag,\n            };\n\n            if (closeTag) {\n                ctx.close = closeTag;\n            }\n\n            return ctx;\n        }\n    }\n\n    return;\n}\n\nexport function getTagName(state: EditorState, node: SyntaxNode): string {\n    const tagName = node.getChild('TagName');\n    return tagName ? substr(state, tagName) : '';\n}\n\n/**\n * Returns Emmet options for given character location in editor\n */\nexport function getOptions(state: EditorState, pos: number): UserConfig {\n    const info = syntaxInfo(state, pos);\n    const { context } = info;\n\n    const config: UserConfig = {\n        type: info.type,\n        syntax: info.syntax || EmmetKnownSyntax.html,\n        options: getOutputOptions(state, info.inline)\n    };\n\n    if (context) {\n        // Set context from syntax info\n        if (context.type === 'html' && context.ancestors.length) {\n            config.context = getMarkupAbbreviationContext(state, context);\n        } else if (context.type === 'css') {\n            config.context = getStylesheetAbbreviationContext(context);\n        }\n    }\n\n    return config;\n}\n\nexport function resetCache() {\n    cache = {};\n}\n", "import type { GlobalConfig } from 'emmet';\nimport { EditorState, type Extension, Facet } from '@codemirror/state';\nimport { resetCache } from './emmet';\nimport { EmmetKnownSyntax } from './types';\n\nexport interface EmmetEditorOptions {\n    emmet: EmmetConfig;\n}\n\nexport type EnableForSyntax = boolean | string[];\nexport type PreviewExtensions = () => Extension;\n\nexport interface EmmetPreviewConfig {\n    /** Extensions factory for displaying HTML-like abbreviation preview  */\n    html?: PreviewExtensions;\n    /** Extensions factory for displaying CSS-like abbreviation preview  */\n    css?: PreviewExtensions;\n\n    /** Value for `root` options of EditorView: https://codemirror.net/docs/ref/#view.EditorViewConfig.root */\n    root?: Document | ShadowRoot;\n}\n\nexport interface EmmetConfig {\n    /**\n     * A syntax of expanded abbreviations. In most cases, it must be the same syntax\n     * as in your editor. Currently, CodeMirror doesn’t provide API to get syntax\n     * name from host editor so you have to specify it manually.\n     */\n    syntax: EmmetKnownSyntax;\n\n    /** Enables abbreviation marking in editor. Works in known syntaxes only */\n    mark: EnableForSyntax;\n\n    /**\n     * Config for proview popup\n     */\n    preview: EmmetPreviewConfig;\n\n    /**\n     * Enables preview of marked abbreviation. Pass `true` to enable preview for\n     * all syntaxes or array of modes or Emmet syntax types (`markup` or `stylesheet`)\n     * where preview should be displayed\n     */\n    previewEnabled: EnableForSyntax;\n\n    /** Mark HTML tag pairs in editor */\n    markTagPairs: boolean;\n\n    /**\n     * Displays open tag preview when caret is inside its matching closing tag.\n     * Preview is displayed only if open tag has attributes.\n     * Works only if `markTagPairs` is enabled\n     */\n    previewOpenTag: boolean;\n\n    /** Allow automatic tag pair rename, works only if `markTagPairs` is enabled */\n    autoRenameTags: boolean;\n\n    /**\n     * Force Tab key to apply Emmet autocomplete option\n     */\n    autocompleteTab?: EnableForSyntax;\n\n    /** Quotes to use in generated HTML attribute values */\n    attributeQuotes: 'single' | 'double';\n\n    /** Style for self-closing elements (like `<br>`) and boolean attributes */\n    markupStyle: 'html' | 'xhtml' | 'xml',\n\n    /**\n     * Enable automatic tag commenting. When enabled, elements generated from Emmet\n     * abbreviation with `id` and/or `class` attributes will receive a comment\n     * with these attribute values\n     */\n    comments: boolean;\n\n    /**\n     * Commenting template. Default value is `\\n<!-- /[#ID][.CLASS] -->`\n     * Outputs everything between `[` and `]` only if specified attribute name\n     * (written in UPPERCASE) exists in element. Attribute name is replaced with\n     * actual value. Use `\\n` to add a newline.\n     */\n    commentsTemplate?: string;\n\n    /**\n     * Enable BEM support. When enabled, Emmet will treat class names starting\n     * with `-` as _element_ and with `_` as _modifier_ in BEM notation.\n     * These class names will inherit `block` name from current or ancestor element.\n     * For example, the abbreviation `ul.nav.nav_secondary>li.nav__item` can be\n     * shortened to `ul.nav._secondary>li.-item` with this option enabled.\n     */\n    bem: boolean;\n\n    /**\n     * For stylesheet abbreviations, generate short HEX color values, if possible.\n     * For example, `c#0` will be expanded to `color: #000;` instead of `color: #000000`.\n     */\n    shortHex?: boolean;\n\n    /** Advanced Emmet config */\n    config?: GlobalConfig;\n\n    /**\n     * A `boost` option for CodeMirror completions\n     */\n    completionBoost?: number;\n\n    /**\n     * Function for attaching abbreviation preview\n     */\n    // attachPreview?: (editor: CodeMirror.Editor, preview: HTMLElement, pos: CodeMirror.Position) => void;\n}\n\nexport const defaultConfig: EmmetConfig = {\n    syntax: EmmetKnownSyntax.html,\n    mark: true,\n    preview: { },\n    previewEnabled: true,\n    autoRenameTags: true,\n    markTagPairs: true,\n    previewOpenTag: false,\n    attributeQuotes: 'double',\n    markupStyle: 'html',\n    comments: false,\n    commentsTemplate: '<!-- /[#ID][.CLASS] -->',\n    bem: false,\n    completionBoost: 99\n};\n\nexport const config = Facet.define<Partial<EmmetConfig>, EmmetConfig>({\n    combine(value) {\n        resetCache();\n        const baseConfig: EmmetConfig = { ...defaultConfig };\n        const { preview } = baseConfig;\n        for (const item of value) {\n            Object.assign(baseConfig, item);\n            if (item.preview) {\n                baseConfig.preview = {\n                    ...preview,\n                    ...item.preview\n                };\n            }\n        }\n\n        return baseConfig;\n    }\n});\n\nexport default function getEmmetConfig(state: EditorState, opt?: Partial<EmmetConfig>): EmmetConfig {\n    let conf = state.facet(config);\n    if (opt) {\n        conf = { ...conf, ...opt };\n    }\n\n    return conf;\n}\n", "import type { SyntaxType, AbbreviationContext } from 'emmet';\nimport type { EditorState } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport type { SyntaxNode } from '@lezer/common';\nimport { getContext } from './context';\nimport { HTMLContext, CSSContext, EmmetKnownSyntax } from './types';\nimport { last, getTagAttributes } from './utils';\nimport getEmmetConfig from './config';\n\nconst htmlSyntaxes: EmmetKnownSyntax[] = [EmmetKnownSyntax.html, EmmetKnownSyntax.vue];\nconst jsxSyntaxes: EmmetKnownSyntax[] = [EmmetKnownSyntax.jsx, EmmetKnownSyntax.tsx];\nconst xmlSyntaxes: EmmetKnownSyntax[] = [EmmetKnownSyntax.xml, EmmetKnownSyntax.xsl, ...jsxSyntaxes];\nconst cssSyntaxes: EmmetKnownSyntax[] = [EmmetKnownSyntax.css, EmmetKnownSyntax.scss, EmmetKnownSyntax.less];\nconst markupSyntaxes: EmmetKnownSyntax[] = [EmmetKnownSyntax.haml, EmmetKnownSyntax.jade, EmmetKnownSyntax.pug, EmmetKnownSyntax.slim, ...htmlSyntaxes, ...xmlSyntaxes, ...jsxSyntaxes];\nconst stylesheetSyntaxes: EmmetKnownSyntax[] = [EmmetKnownSyntax.sass, EmmetKnownSyntax.sss, EmmetKnownSyntax.stylus, EmmetKnownSyntax.postcss, ...cssSyntaxes];\n\nexport interface SyntaxInfo {\n    type: SyntaxType;\n    syntax?: string;\n    inline?: boolean;\n    context?: HTMLContext | CSSContext;\n}\n\nexport interface StylesheetRegion {\n    range: [number, number];\n    syntax: string;\n    inline?: boolean;\n}\n\nexport interface SyntaxCache {\n    stylesheetRegions?: StylesheetRegion[];\n}\n\nconst enum TokenType {\n    Selector = \"selector\",\n    PropertyName = \"propertyName\",\n    PropertyValue = \"propertyValue\",\n    BlockEnd = \"blockEnd\"\n}\n\nconst enum CSSAbbreviationScope {\n    /** Include all possible snippets in match */\n    Global = \"@@global\",\n    /** Include raw snippets only (e.g. no properties) in abbreviation match */\n    Section = \"@@section\",\n    /** Include properties only in abbreviation match */\n    Property = \"@@property\",\n    /** Resolve abbreviation in context of CSS property value */\n    Value = \"@@value\"\n}\n\n/**\n * Returns Emmet syntax info for given location in view.\n * Syntax info is an abbreviation type (either 'markup' or 'stylesheet') and syntax\n * name, which is used to apply syntax-specific options for output.\n *\n * By default, if given location doesn’t match any known context, this method\n * returns `null`, but if `fallback` argument is provided, it returns data for\n * given fallback syntax\n */\nexport function syntaxInfo(state: EditorState, ctx?: number | HTMLContext | CSSContext): SyntaxInfo {\n    let syntax = docSyntax(state);\n    let inline: boolean | undefined;\n    let context = typeof ctx === 'number' ? getContext(state, ctx) : ctx;\n\n    if (context?.type === 'html' && context.css) {\n        inline = true;\n        syntax = EmmetKnownSyntax.css;\n        context = context.css;\n    } else if (context?.type === 'css') {\n        syntax = EmmetKnownSyntax.css;\n    }\n\n    return {\n        type: getSyntaxType(syntax),\n        syntax,\n        inline,\n        context\n    };\n}\n\n/**\n * Returns main editor syntax\n */\nexport function docSyntax(state: EditorState): EmmetKnownSyntax {\n    return getEmmetConfig(state).syntax;\n}\n\n/**\n * Returns Emmet abbreviation type for given syntax\n */\nexport function getSyntaxType(syntax?: EmmetKnownSyntax): SyntaxType {\n    return syntax && stylesheetSyntaxes.includes(syntax) ? 'stylesheet' : 'markup';\n}\n\n/**\n * Check if given syntax is XML dialect\n */\nexport function isXML(syntax: string): syntax is EmmetKnownSyntax {\n    return xmlSyntaxes.includes(syntax as EmmetKnownSyntax);\n}\n\n/**\n * Check if given syntax is HTML dialect (including XML)\n */\nexport function isHTML(syntax: string): syntax is EmmetKnownSyntax {\n    return htmlSyntaxes.includes(syntax as EmmetKnownSyntax) || isXML(syntax);\n}\n\n/**\n * Check if given syntax name is supported by Emmet\n */\nexport function isSupported(syntax: string): syntax is EmmetKnownSyntax {\n    return markupSyntaxes.includes(syntax as EmmetKnownSyntax)\n        || stylesheetSyntaxes.includes(syntax as EmmetKnownSyntax);\n}\n\n/**\n * Check if given syntax is a CSS dialect. Note that it’s not the same as stylesheet\n * syntax: for example, SASS is a stylesheet but not CSS dialect (but SCSS is)\n */\nexport function isCSS(syntax: string): syntax is EmmetKnownSyntax {\n    return cssSyntaxes.includes(syntax as EmmetKnownSyntax);\n}\n\n/**\n * Check if given syntax is JSX dialect\n */\nexport function isJSX(syntax: string): syntax is EmmetKnownSyntax {\n    return jsxSyntaxes.includes(syntax as EmmetKnownSyntax);\n}\n\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nexport function getMarkupAbbreviationContext(state: EditorState, ctx: HTMLContext): AbbreviationContext | undefined {\n    const parent = last(ctx.ancestors);\n    if (parent) {\n        let node: SyntaxNode | null = syntaxTree(state).resolve(parent.range.from, 1);\n        while (node && node.name !== 'OpenTag') {\n            node = node.parent;\n        }\n\n        return {\n            name: parent.name,\n            attributes: node ? getTagAttributes(state, node) : {}\n        };\n    }\n\n    return;\n}\n\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nexport function getStylesheetAbbreviationContext(ctx: CSSContext): AbbreviationContext {\n    if (ctx.inline) {\n        return { name: CSSAbbreviationScope.Property }\n    }\n\n    const parent = last(ctx.ancestors);\n    let scope: string = CSSAbbreviationScope.Global;\n    if (ctx.current) {\n        if (ctx.current.type === TokenType.PropertyValue && parent) {\n            scope = parent.name;\n        } else if ((ctx.current.type === TokenType.Selector || ctx.current.type === TokenType.PropertyName) && !parent) {\n            scope = CSSAbbreviationScope.Section;\n        }\n    } else if (!parent) {\n        scope = CSSAbbreviationScope.Section;\n    }\n\n    return {\n        name: scope\n    };\n}\n", "import { EditorView } from 'codemirror';\nimport { EditorState } from '@codemirror/state';\nimport { syntaxHighlighting, defaultHighlightStyle } from '@codemirror/language';\nimport { html } from '@codemirror/lang-html';\nimport { css } from '@codemirror/lang-css';\nimport type { EmmetPreviewConfig, PreviewExtensions } from '../lib/config';\nimport { EmmetKnownSyntax } from '../plugin';\n\nexport interface HTMLElementPreview extends HTMLElement {\n    update?: (value: string) => void;\n}\n\nexport function createPreview(value: string, syntax: string, options?: EmmetPreviewConfig): HTMLElementPreview {\n    const elem = document.createElement('div') as HTMLElementPreview;\n    elem.className = 'emmet-preview';\n    if (syntax === 'error') {\n        elem.classList.add('emmet-preview_error');\n    }\n\n    let ext: PreviewExtensions = syntax === EmmetKnownSyntax.css ? css : html;\n    if (options && syntax in options) {\n        ext = options[syntax as keyof EmmetPreviewConfig] as PreviewExtensions;\n    }\n\n    const view = new EditorView({\n        doc: value,\n        root: options?.root,\n        extensions: [\n            EditorState.readOnly.of(true),\n            syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n            syntax === EmmetKnownSyntax.css ? css() : html(),\n            ext()\n        ],\n        parent: elem\n    });\n\n    elem.update = (nextValue) => {\n        const tr = view.state.update({\n            changes: {\n                from: 0,\n                to: view.state.doc.length,\n                insert: nextValue\n            }\n        });\n        view.dispatch(tr);\n    };\n\n    return elem;\n}\n", "export default \"data:image/svg+xml,%3csvg%20height='393'%20viewBox='0%200%20393%20393'%20width='393'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3clinearGradient%20id='a'%20x1='98.60869%25'%20x2='50%25'%20y1='50%25'%20y2='50%25'%3e%3cstop%20offset='0'%20stop-color='%23cefbad'/%3e%3cstop%20offset='.836972535'%20stop-color='%23cefbad'/%3e%3cstop%20offset='1'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3cpath%20id='b'%20d='m116%2048%20105%2063v34.985l-75-44.999289v67.667289l49.5%2029.347-49.5%2029.346v67.668289l75-45.000289v34.986l-105%2063zm145%2087%20105%2063-105%2063v-34.986l46.690481-28.014-46.690481-28.014z'/%3e%3c/defs%3e%3cg%20fill='none'%20fill-rule='evenodd'%20transform='matrix(.70710678%20-.70710678%20.70710678%20.70710678%20-81.392965%20196.5)'%3e%3ccircle%20cx='196.5'%20cy='196.5'%20fill='%2325272b'%20r='196.5'/%3e%3cuse%20fill='%2392c131'%20xlink:href='%23b'/%3e%3cuse%20fill='url(%23a)'%20xlink:href='%23b'/%3e%3c/g%3e%3c/svg%3e\"", "import type { MarkupAbbreviation, StylesheetAbbreviation, UserConfig } from 'emmet';\nimport { markupAbbreviation } from 'emmet';\nimport { ViewPlugin, Decoration, keymap, EditorView, showTooltip } from '@codemirror/view';\nimport type { DecorationSet, Command, Tooltip, ViewUpdate } from '@codemirror/view';\nimport { StateEffect, StateField } from '@codemirror/state';\nimport type { Range, EditorState, Extension, StateCommand, Transaction } from '@codemirror/state';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { snippet, pickedCompletion, completionStatus, selectedCompletion, acceptCompletion } from '@codemirror/autocomplete';\nimport type { CompletionResult, Completion, CompletionSource } from '@codemirror/autocomplete';\nimport { getCSSContext, getHTMLContext } from '../lib/context';\nimport { docSyntax, getMarkupAbbreviationContext, getStylesheetAbbreviationContext, getSyntaxType, isCSS, isHTML, isJSX, isSupported } from '../lib/syntax';\nimport getOutputOptions from '../lib/output';\nimport { type CSSContext, type AbbreviationError, type StartTrackingParams, type RangeObject, EmmetKnownSyntax } from '../lib/types';\nimport { contains, getCaret, rangeEmpty, substr } from '../lib/utils';\nimport { expand } from '../lib/emmet';\nimport { type HTMLElementPreview, createPreview } from './AbbreviationPreviewWidget';\nimport icon from '../completion-icon.svg';\nimport getEmmetConfig, { config, type EmmetPreviewConfig, type EmmetConfig } from '../lib/config';\n\ninterface EmmetCompletion extends Completion {\n    tracker: AbbreviationTrackerValid;\n    previewConfig: EmmetPreviewConfig;\n    preview?: HTMLElementPreview;\n}\n\ninterface EmmetTooltip extends Tooltip {\n    tracker: AbbreviationTracker;\n}\n\ntype AbbreviationTracker = AbbreviationTrackerValid | AbbreviationTrackerError;\n\n/// CSS property and value keyword completion source.\n// Проблема мигающего автокомплита в том, что он становится ActiveSource,\n// а не ActiveResult, из-за этого помечется как Pending и не обновляется на первый\n// проход.\n// Текущая реализация укладывается в нужную концепцию,\n// но проверка автокомплита обрабатывается раньше, чем обновляется трэкер.\n// Нужно найти способ обновить трэкер раньше, чем отработает код автокомплита\nexport const emmetCompletionSource: CompletionSource = context => {\n    const tracker = context.state.field(trackerField);\n    if (tracker?.type === 'abbreviation' && tracker.preview && contains(tracker.range, context.pos)) {\n        return {\n            from: tracker.range.from,\n            to: tracker.range.to,\n            filter: false,\n            update(current, _from, _to, context) {\n                const tracker = context.state.field(trackerField);\n                if (!tracker || tracker.type === 'error' || !contains(tracker.range, context.pos)) {\n                    return null;\n                }\n\n                return {\n                    ...current,\n                    from: tracker.range.from,\n                    to: tracker.range.to,\n                    options: completionOptionsFromTracker(context.state, tracker)\n                };\n            },\n            options: completionOptionsFromTracker(context.state, tracker)\n        } as CompletionResult;\n    }\n\n    return null;\n}\n\nconst cssCompletion: Extension = cssLanguage.data.of({ autocomplete: emmetCompletionSource });\n\ninterface AbbreviationTrackerBase {\n    /** Range in editor for abbreviation */\n    range: RangeObject;\n\n    /** Actual abbreviation, tracked by current tracker */\n    abbreviation: string;\n\n    /**\n     * Abbreviation was forced, e.g. must remain in editor even if empty or contains\n     * invalid abbreviation\n     */\n    forced: boolean;\n\n    /** Indicates that current tracker shouldn’t be displayed in editor */\n    inactive: boolean;\n\n    /**\n     * Relative offset from range start where actual abbreviation starts.\n     * Used tp handle prefixes in abbreviation\n     */\n    offset: number;\n\n    config: UserConfig;\n}\n\nexport interface AbbreviationTrackerValid extends AbbreviationTrackerBase {\n    type: 'abbreviation';\n\n    /**\n     * Abbreviation is simple, e.g. contains single element.\n     * It’s suggested to not display preview for simple abbreviation\n     */\n    simple: boolean;\n\n    /** Preview of expanded abbreviation */\n    preview: string;\n}\n\nexport interface AbbreviationTrackerError extends AbbreviationTrackerBase {\n    type: 'error';\n    error: AbbreviationError;\n}\n\nexport const JSX_PREFIX = '<';\n\nconst trackerMark = Decoration.mark({ class: 'emmet-tracker' });\n\nconst resetTracker = StateEffect.define();\nconst forceTracker = StateEffect.define();\n\nexport const enterAbbreviationMode: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        effects: [forceTracker.of(null)]\n    });\n    dispatch(tr);\n    return true;\n};\n\nconst trackerField = StateField.define<AbbreviationTracker | null>({\n    create: () => null,\n    update(value, tr) {\n        const hasCompletion = tr.annotation(pickedCompletion);\n        if (hasCompletion) {\n            // When completion is applied, always reset tracker\n            return null;\n        }\n\n        for (const effect of tr.effects) {\n            if (effect.is(resetTracker)) {\n                return null;\n            }\n\n            if (effect.is(forceTracker)) {\n                const sel = tr.newSelection.main;\n                const config = getActivationContext(tr.state, sel.from);\n                if (config) {\n                    return createTracker(tr.state, sel, {\n                        forced: true,\n                        config\n                    });\n                }\n            }\n        }\n\n        if (!tr.docChanged) {\n            return value;\n        }\n        return handleUpdate(tr.state, value, tr);\n    }\n});\n\nconst abbreviationPreview = StateField.define<EmmetTooltip | null>({\n    create: getAbbreviationPreview,\n    update(tooltip, tr) {\n        if (!tr.docChanged && !tr.selection) {\n            const tracker = tr.state.field(trackerField);\n            return tracker ? tooltip : null;\n        }\n        return getAbbreviationPreview(tr.state, tooltip);\n    },\n    provide: f => showTooltip.from(f)\n});\n\nfunction getAbbreviationPreview(state: EditorState, prevTooltip?: EmmetTooltip | null): EmmetTooltip | null {\n    const tracker = state.field(trackerField);\n\n    if (tracker && !tracker.inactive && completionStatus(state) !== 'active') {\n        if (tracker.config.type === 'stylesheet') {\n            // Do not display preview for CSS since completions are populated\n            // automatically for this syntax and abbreviation will be a part of\n            // completion list\n            return null;\n        }\n\n        if (prevTooltip && prevTooltip.tracker.type !== tracker.type) {\n            prevTooltip = null;\n        }\n\n        const { range } = tracker;\n\n        if (canDisplayPreview(state, tracker)) {\n            return prevTooltip || {\n                pos: range.from,\n                above: false,\n                arrow: false,\n                tracker,\n                create() {\n                    const previewConfig = state.facet(config).preview;\n                    let preview = '';\n                    let syntax = '';\n\n                    if (tracker.type === 'error') {\n                        preview = tracker.error.message;\n                        syntax = 'error';\n                    } else {\n                        preview = tracker.preview;\n                        syntax = tracker.config.syntax || EmmetKnownSyntax.html;\n                    }\n\n                    const dom = createPreview(preview, syntax, previewConfig);\n                    return {\n                        dom,\n                        update({ state }) {\n                            const tracker = state.field(trackerField);\n                            if (tracker && dom.update) {\n                                const value = tracker.type === 'error'\n                                    ? tracker.error.message\n                                    : tracker.preview;\n                                dom.update(value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nconst abbreviationTracker = ViewPlugin.fromClass(class {\n    decorations: DecorationSet;\n\n    constructor() {\n        this.decorations = Decoration.none;\n    }\n\n    update(update: ViewUpdate) {\n        const { state } = update;\n\n        const tracker = state.field(trackerField);\n        const decors: Range<Decoration>[] = [];\n\n        if (tracker && !tracker.inactive) {\n            const { range } = tracker;\n\n            if (!rangeEmpty(range) ) {\n                decors.push(trackerMark.range(range.from, range.to));\n            }\n            this.decorations = Decoration.set(decors, true);\n        } else {\n            this.decorations = Decoration.none;\n        }\n    }\n}, {\n    decorations: v => v.decorations,\n});\n\nexport function expandTracker(view: EditorView, tracker: AbbreviationTracker): void {\n    const { from, to } = tracker.range;\n    const expanded = expand(view.state, tracker.abbreviation, tracker.config);\n    const fn = snippet(expanded);\n\n    view.dispatch(view.state.update({\n        effects: resetTracker.of(null)\n    }));\n    fn(view, { label: 'expand' }, from, to);\n}\n\nconst tabKeyHandler: Command = (view) => {\n    const { state } = view;\n    const completion = selectedCompletion(state)\n    const tracker = state.field(trackerField, false);\n\n    if (completion && tracker) {\n        // Check if we can use Tab key to apply Emmet completion\n        if (completion.type === 'emmet') {\n            const { autocompleteTab } = getEmmetConfig(state);\n            if (!autocompleteTab) {\n                return false;\n            }\n\n            if (Array.isArray(autocompleteTab)) {\n                const { type, syntax } = tracker.config\n                if (!autocompleteTab.includes(type!) && !autocompleteTab.includes(syntax!)) {\n                    return false;\n                }\n            }\n\n            // Accept completion\n            acceptCompletion(view);\n            return true;\n        } else {\n            // Must be handled by `acceptCompletion` command\n            return false;\n        }\n    }\n\n    if (tracker && !tracker.inactive && contains(tracker.range, getCaret(state))) {\n        expandTracker(view, tracker);\n        return true;\n    }\n    return false;\n};\n\nconst escKeyHandler: Command = ({ state, dispatch }) => {\n    const tracker = state.field(trackerField, false);\n    if (tracker) {\n        dispatch({\n            effects: resetTracker.of(null)\n        });\n        return true;\n    }\n\n    return false;\n};\n\nconst trackerTheme = EditorView.baseTheme({\n    '.emmet-tracker': {\n        textDecoration: 'underline 1px green',\n    },\n    '.emmet-preview': {\n        fontSize: '0.9em'\n    },\n    '.emmet-preview_error': {\n        color: 'red'\n    },\n    '.cm-completionIcon-emmet::after': {\n        content: '\" \"',\n        background: `url(\"${icon}\") center/contain no-repeat`,\n        display: 'inline-block',\n        width: '11px',\n        height: '11px',\n        verticalAlign: 'middle'\n    }\n});\n\n/**\n * A factory function that creates abbreviation tracker for known syntaxes.\n * When user starts typing, it detects whether user writes abbreviation and\n * if so, starts tracking by displaying an underline. Then if user hit Tab key\n * when cursor is inside tracked abbreviation, it will expand it. Or user can\n * press Escape key to reset tracker\n */\nexport default function tracker(options?: Partial<EmmetConfig>): Extension[] {\n    return [\n        trackerField,\n        abbreviationTracker,\n        abbreviationPreview,\n        trackerTheme,\n        cssCompletion,\n        options ? config.of(options) : [],\n        keymap.of([{\n            key: 'Tab',\n            run: tabKeyHandler\n        }, {\n            key: 'Escape',\n            run: escKeyHandler\n        }])\n    ]\n}\n\nexport { resetTracker as trackerResetAction }\n\n/**\n * Check if abbreviation tracking is allowed in editor at given location\n */\nexport function allowTracking(state: EditorState): boolean {\n    return isSupported(docSyntax(state));\n}\n\n/**\n * Detects if user is typing abbreviation at given location\n * @param pos Location where user started typing\n * @param input Text entered at `pos` location\n */\nfunction typingAbbreviation(state: EditorState, pos: number, input: string): AbbreviationTracker | null {\n    if (input.length !== 1) {\n        // Expect single character enter to start abbreviation tracking\n        return null;\n    }\n\n    // Start tracking only if user starts abbreviation typing: entered first\n    // character at the word bound\n    const line = state.doc.lineAt(pos);\n    const prefix = line.text.substring(Math.max(0, pos - line.from - 1), pos - line.from);\n\n    // Check if current syntax is supported for tracking\n    if (!canStartTyping(prefix, input, getSyntaxFromPos(state, pos))) {\n        return null;\n    }\n\n    const config = getActivationContext(state, pos);\n    if (!config) {\n        return null;\n    }\n\n    // Additional check for stylesheet abbreviation start: it’s slightly\n    // differs from markup prefix, but we need activation context\n    // to ensure that context under caret is CSS\n    if (config.type === 'stylesheet') {\n        if (!canStartTyping(prefix, input, EmmetKnownSyntax.css)) {\n            return null;\n        }\n\n        // Do not trigger abbreviation tracking inside CSS property value.\n        // Allow it for colors only\n        const ctxName = config.context?.name;\n        if (ctxName && !ctxName.startsWith('@@') && input !== '#') {\n            return null;\n        }\n    }\n\n    const syntax = config.syntax || EmmetKnownSyntax.html;\n    let from = pos;\n    let to = pos + input.length;\n    let offset = 0;\n\n    if (isJSX(syntax) && prefix === JSX_PREFIX) {\n        offset = JSX_PREFIX.length;\n        from -= offset;\n    }\n\n    return createTracker(state, { from, to }, { config });\n}\n\n/**\n * Detects and returns valid abbreviation activation context for given location\n * in editor which can be used for abbreviation expanding.\n * For example, in given HTML code:\n * `<div title=\"Sample\" style=\"\">Hello world</div>`\n * it’s not allowed to expand abbreviations inside `<div ...>` or `</div>`,\n * yet it’s allowed inside `style` attribute and between tags.\n *\n * This method ensures that given `pos` is inside location allowed for expanding\n * abbreviations and returns context data about it.\n */\nexport function getActivationContext(state: EditorState, pos: number): UserConfig | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSActivationContext(state, pos, EmmetKnownSyntax.css, getCSSContext(state, pos));\n    }\n\n    const syntax = docSyntax(state);\n\n    if (isHTML(syntax)) {\n        const ctx = getHTMLContext(state, pos);\n\n        if (ctx.css) {\n            return getCSSActivationContext(state, pos, EmmetKnownSyntax.css, ctx.css);\n        }\n\n        if (!ctx.current) {\n            return {\n                syntax,\n                type: 'markup',\n                context: getMarkupAbbreviationContext(state, ctx),\n                options: getOutputOptions(state)\n            };\n        }\n    } else {\n        return {\n            syntax,\n            type: getSyntaxType(syntax),\n            options: getOutputOptions(state)\n        };\n    }\n\n    return undefined;\n}\n\nfunction getCSSActivationContext(state: EditorState, pos: number, syntax: EmmetKnownSyntax, ctx: CSSContext): UserConfig | undefined {\n    const allowedContext = !ctx.current\n        || ctx.current.type === 'propertyName'\n        || ctx.current.type === 'propertyValue'\n        || isTypingBeforeSelector(state, pos, ctx);\n\n    if (allowedContext) {\n        return {\n            syntax,\n            type: 'stylesheet',\n            context: getStylesheetAbbreviationContext(ctx),\n            options: getOutputOptions(state, ctx.inline)\n        };\n    }\n\n    return;\n}\n\n/**\n * Handle edge case: start typing abbreviation before selector. In this case,\n * entered character becomes part of selector\n * Activate only if it’s a nested section and it’s a first character of selector\n */\nfunction isTypingBeforeSelector(state: EditorState, pos: number, { current }: CSSContext): boolean {\n    if (current?.type === 'selector' && current.range.from === pos - 1) {\n        // Typing abbreviation before selector is tricky one:\n        // ensure it’s on its own line\n        const line = state.doc.lineAt(current.range.from);\n        return line.text.trim().length === 1;\n    }\n\n    return false;\n}\n\nfunction isValidPrefix(prefix: string, syntax: string): boolean {\n    if (isJSX(syntax)) {\n        return prefix === JSX_PREFIX;\n    }\n\n    if (isCSS(syntax)) {\n        return prefix === '' || /^[\\s>;\"\\']$/.test(prefix);\n    }\n\n    return prefix === '' || /^[\\s>;\"\\']$/.test(prefix);\n}\n\nfunction isValidAbbreviationStart(input: string, syntax: string): boolean {\n    if (isJSX(syntax)) {\n        return /^[a-zA-Z.#\\[\\(]$/.test(input);\n    }\n\n    if (isCSS(syntax)) {\n        return /^[a-zA-Z!@#]$/.test(input);\n    }\n\n    return /^[a-zA-Z.#!@\\[\\(]$/.test(input);\n}\n\n/**\n * Creates abbreviation tracker for given range in editor. Parses contents\n * of abbreviation in range and returns either valid abbreviation tracker,\n * error tracker or `null` if abbreviation cannot be created from given range\n */\nfunction createTracker(state: EditorState, range: RangeObject, params: StartTrackingParams): AbbreviationTracker | null {\n    if (range.from > range.to) {\n        // Invalid range\n        return null;\n    }\n\n    let abbreviation = substr(state, range);\n    const { config, forced } = params;\n    if (params.offset) {\n        abbreviation = abbreviation.slice(params.offset);\n    }\n\n    // Basic validation: do not allow empty abbreviations\n    // or newlines in abbreviations\n    if ((!abbreviation && !forced) || hasInvalidChars(abbreviation)) {\n        return null;\n    }\n\n    const base: AbbreviationTrackerBase = {\n        abbreviation,\n        range,\n        config,\n        forced: !!forced,\n        inactive: false,\n        offset: params.offset || 0,\n    }\n\n    try {\n        let parsedAbbr: MarkupAbbreviation | StylesheetAbbreviation | undefined;\n        let simple = false;\n\n        if (config.type === 'markup') {\n            parsedAbbr = markupAbbreviation(abbreviation, {\n                jsx: config.syntax === 'jsx'\n            });\n            simple = isSimpleMarkupAbbreviation(parsedAbbr);\n        }\n\n        const previewConfig = createPreviewConfig(config);\n        const preview = expand(state, parsedAbbr || abbreviation, previewConfig);\n        if (!preview) {\n            // Handle edge case: abbreviation didn’t return any result for preview.\n            // Most likely it means a CSS context where given abbreviation is not applicable\n            return null;\n        }\n\n        return {\n            ...base,\n            type: 'abbreviation',\n            simple,\n            preview,\n        };\n    } catch (error) {\n        return base.forced ? {\n            ...base,\n            type: 'error',\n            error: error as AbbreviationError,\n        } : null;\n    }\n}\n\nfunction hasInvalidChars(abbreviation: string): boolean {\n    return /[\\r\\n]/.test(abbreviation);\n}\n\n/**\n * Check if given parsed markup abbreviation is simple.A simple abbreviation\n * may not be displayed to user as preview to reduce distraction\n */\nfunction isSimpleMarkupAbbreviation(abbr: MarkupAbbreviation): boolean {\n    if (abbr.children.length === 1 && !abbr.children[0].children.length) {\n        // Single element: might be a HTML element or text snippet\n        const first = abbr.children[0];\n        // XXX silly check for common snippets like `!`. Should read contents\n        // of expanded abbreviation instead\n        return !first.name || /^[a-z]/i.test(first.name);\n    }\n    return !abbr.children.length;\n}\n\nfunction createPreviewConfig(config: UserConfig) {\n    return {\n        ...config,\n        options: {\n            ...config.options,\n            'output.field': previewField,\n            'output.indent': '  ',\n            'output.baseIndent': ''\n        }\n    };\n}\n\nfunction previewField(_: number, placeholder: string) {\n    return placeholder;\n}\n\nfunction handleUpdate(state: EditorState, tracker: AbbreviationTracker | null, update: Transaction): AbbreviationTracker | null {\n    if (hasSnippet(state)) {\n        return null;\n    }\n\n    if (!tracker || tracker.inactive) {\n        // Start abbreviation tracking\n        update.changes.iterChanges((_fromA, _toA, fromB, _toB, text) => {\n            if (text.length) {\n                tracker = typingAbbreviation(state, fromB, text.toString()) || tracker;\n            }\n        });\n\n        if (!tracker || !tracker.inactive) {\n            return tracker;\n        }\n    }\n\n    // Continue abbreviation tracking\n    update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n        if (!tracker) {\n            return;\n        }\n\n        const { range } = tracker;\n        if (!contains(range, fromA)) {\n            // Update is outside of abbreviation, reset it only if it’s not inactive\n            if (!tracker.inactive) {\n                tracker = null;\n            }\n        } else if (contains(range, fromB)) {\n            const removed = toA - fromA;\n            const inserted = toB - fromA;\n            const to = range.to + inserted - removed;\n            if (to <= range.from || hasInvalidChars(text.toString())) {\n                tracker = null;\n            } else {\n                const abbrRange = tracker.inactive ? range : { from: range.from, to };\n                const nextTracker = createTracker(state, abbrRange, {\n                    config: tracker.config,\n                    forced: tracker.forced\n                });\n\n                if (!nextTracker) {\n                    // Next tracker is empty mostly due to invalid abbreviation.\n                    // To allow users to fix error, keep previous tracker\n                    // instance as inactive\n                    tracker = { ...tracker, inactive: true };\n                } else {\n                    tracker = nextTracker;\n                }\n            }\n        }\n    });\n\n    return tracker;\n}\n\nfunction getSyntaxFromPos(state: EditorState, pos: number): EmmetKnownSyntax {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return EmmetKnownSyntax.css;\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return EmmetKnownSyntax.html;\n    }\n\n    return '' as EmmetKnownSyntax;\n}\n\nfunction canStartTyping(prefix: string, input: string, syntax: EmmetKnownSyntax) {\n    return isValidPrefix(prefix, syntax) && isValidAbbreviationStart(input, syntax);\n}\n\n/**\n * It’s a VERY hacky way to detect if snippet is currently active in given state.\n * Should ask package authors how to properly detect it\n */\nfunction hasSnippet(state: any): boolean {\n    if (Array.isArray(state.values)) {\n        return state.values.some((item: any) => item && item.constructor?.name === 'ActiveSnippet');\n    }\n\n    return false;\n}\n\nexport function canDisplayPreview(state: EditorState, tracker: AbbreviationTracker): boolean {\n    if (completionStatus(state) === 'active') {\n        return false;\n    }\n\n    const config = getEmmetConfig(state);\n    if (!config.previewEnabled) {\n        return false;\n    }\n\n    if (Array.isArray(config.previewEnabled)) {\n        const { type, syntax } = tracker.config;\n        if (!config.previewEnabled.includes(type!) && !config.previewEnabled.includes(syntax!)) {\n            return false;\n        }\n    }\n\n    return tracker.type === 'error' || (!tracker.simple || tracker.forced) && !!tracker.abbreviation && contains(tracker.range, getCaret(state));\n}\n\nfunction completionOptionsFromTracker(state: EditorState, tracker: AbbreviationTrackerValid, prev?: EmmetCompletion): EmmetCompletion[] {\n    const opt = state.facet(config);\n    return [{\n        label: 'Emmet abbreviation',\n        type: 'emmet',\n        boost: opt.completionBoost,\n        tracker,\n        previewConfig: opt.preview,\n        preview: prev?.preview,\n        info: completionInfo,\n        apply: (view, completion) => {\n            view.dispatch({\n                annotations: pickedCompletion.of(completion)\n            });\n            expandTracker(view, tracker);\n        }\n    }];\n}\n\nfunction completionInfo(completion: Completion): Node {\n    let { tracker, previewConfig, preview } = completion as EmmetCompletion;\n    if (preview?.update) {\n        preview.update(tracker.preview);\n    } else {\n        (completion as EmmetCompletion).preview = preview = createPreview(tracker.preview, tracker.config.syntax || EmmetKnownSyntax.html, previewConfig);\n    }\n\n    return preview;\n}\n", "import type { StateCommand } from '@codemirror/state';\nimport { expand, extract, getOptions } from '../lib/emmet';\nimport { getSyntaxType } from '../lib/syntax';\nimport { snippet } from '@codemirror/autocomplete';\nimport { getActivationContext } from '../tracker';\nimport type { EmmetKnownSyntax } from '../lib/types';\n\nexport const expandAbbreviation: StateCommand = ({ state, dispatch }) => {\n    const sel = state.selection.main;\n    const line = state.doc.lineAt(sel.anchor);\n    const options = getOptions(state, sel.anchor);\n    const abbr = extract(line.text, sel.anchor - line.from, getSyntaxType(options.syntax as EmmetKnownSyntax));\n\n    if (abbr) {\n        const start = line.from + abbr.start;\n        const expanded = expand(state, abbr.abbreviation, getActivationContext(state, start) || options);\n        const fn = snippet(expanded);\n        fn({ state, dispatch }, { label: 'expand' }, start, line.from + abbr.end);\n        return true;\n    }\n\n    return false;\n};\n\n", "import { syntaxTree } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { RangeObject } from '../lib/types';\nimport { contains, fullCSSDeclarationRange, last, narrowToNonSpace, rangeContains, rangesEqual } from '../lib/utils';\nimport { getPropertyRanges } from '../lib/context';\n\n// TODO use RangeObject instead of TextRange\n\nexport const balanceOutward: StateCommand = ({ state, dispatch }) => {\n    const nextSel: SelectionRange[] = [];\n    let hasMatch = false;\n\n    for (const sel of state.selection.ranges) {\n        const ranges = getOutwardRanges(state, sel.from);\n        if (ranges) {\n            hasMatch = true;\n            const targetRange = ranges.find(r => rangeContains(r, sel) && !rangesEqual(r, sel)) || sel;\n            nextSel.push(EditorSelection.range(targetRange.from, targetRange.to));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    if (hasMatch) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextSel)\n        });\n\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nexport const balanceInward: StateCommand = ({ state, dispatch }) => {\n    const nextSel: SelectionRange[] = [];\n    let hasMatch = false;\n    for (const sel of state.selection.ranges) {\n        const ranges = getInwardRanges(state, sel.from);\n        if (ranges) {\n            hasMatch = true;\n            // Try to find range which equals to selection: we should pick leftmost\n            let ix = ranges.findIndex(r => rangesEqual(sel, r));\n            let targetRange: RangeObject = sel;\n\n            if (ix < ranges.length - 1) {\n                targetRange = ranges[ix + 1];\n            } else if (ix !== -1) {\n                // No match found, pick closest region\n                targetRange = ranges.slice(ix).find(r => rangeContains(r, sel)) || sel;\n            }\n\n            nextSel.push(EditorSelection.range(targetRange.from, targetRange.to));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    if (hasMatch) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextSel)\n        });\n\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction getOutwardRanges(state: EditorState, pos: number): RangeObject[] | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSOutwardRanges(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLOutwardRanges(state, pos);\n    }\n\n    return;\n}\n\nfunction getInwardRanges(state: EditorState, pos: number): RangeObject[] | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSInwardRanges(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLInwardRanges(state, pos);\n    }\n\n    return;\n}\n\nfunction getHTMLOutwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    const tree = syntaxTree(state).resolveInner(pos, -1);\n\n    for (let node: SyntaxNode | null = tree; node; node = node.parent) {\n        if (node.name === 'Element') {\n            pushHTMLRanges(node, result);\n        }\n    }\n\n    return compactRanges(result, false);\n}\n\nfunction getHTMLInwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, 1);\n\n    // Find closest element\n    while (node && node.name !== 'Element') {\n        node = node.parent;\n    }\n\n    // Find all first child elements\n    while (node) {\n        pushHTMLRanges(node, result);\n        node = node.getChild('Element');\n    }\n\n    return compactRanges(result, true);\n}\n\nfunction getCSSOutwardRanges(state: EditorState, pos: number): RangeObject[]  {\n    const result: RangeObject[] = [];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, -1);\n\n    while (node) {\n        pushCSSRanges(state, node, pos, result);\n        node = node.parent;\n    }\n\n    return compactRanges(result, false);\n}\n\nfunction getCSSInwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    const knownNodes = ['Block', 'RuleSet', 'Declaration'];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, 1);\n\n    while (node && !knownNodes.includes(node.name)) {\n        node = node.parent;\n    }\n\n    while (node) {\n        pushCSSRanges(state, node, pos, result);\n        node = getChildOfType(node, knownNodes);\n    }\n\n    return result;\n}\n\n\nfunction pushHTMLRanges(node: SyntaxNode, ranges: RangeObject[]): void {\n    const selfClose = node.getChild('SelfClosingTag');\n    if (selfClose) {\n        ranges.push(selfClose);\n    } else {\n        const open = node.getChild('OpenTag');\n        if (open) {\n            const close = node.getChild('CloseTag');\n            if (close) {\n                // Inner range\n                ranges.push({ from: open.to, to: close.from });\n                // Outer range\n                ranges.push({ from: open.from, to: close.to });\n            } else {\n                ranges.push(open);\n            }\n        }\n    }\n}\n\nfunction pushCSSRanges(state: EditorState, node: SyntaxNode, pos: number, ranges: RangeObject[]): void {\n    if (node.name === 'Block') {\n        ranges.push(narrowToNonSpace(state, {\n            from: node.from + 1,\n            to: node.to - 1\n        }));\n    } else if (node.name === 'RuleSet') {\n        ranges.push(node);\n    } else if (node.name === 'Declaration') {\n        const { name, value } = getPropertyRanges(node);\n        if (value && contains(value, pos)) {\n            ranges.push(value);\n        }\n        if (name && contains(name, pos)) {\n            ranges.push(name);\n        }\n\n        ranges.push(fullCSSDeclarationRange(node));\n    }\n}\n\nfunction compactRanges(ranges: RangeObject[], inward: boolean): RangeObject[] {\n    const result: RangeObject[] = [];\n    ranges = [...ranges].sort(inward\n            ? ((a, b) => a.from - b.from || b.to - a.to)\n            : ((a, b) => b.from - a.from || a.to - b.to));\n\n    for (const range of ranges) {\n        const prev = last(result);\n        if (!prev || prev.from !== range.from || prev.to !== range.to) {\n            result.push(range)\n        }\n    }\n\n    return result;\n}\n\nfunction getChildOfType(node: SyntaxNode, types: string[]): SyntaxNode | null {\n    const cur = node.cursor();\n    if (cur.firstChild()) {\n        for (;;) {\n            for (const t of types) {\n                if (cur.node.name === t) {\n                    return cur.node;\n                }\n            }\n            if (!cur.nextSibling()) {\n                break;\n            }\n        }\n    }\n\n    return null;\n}\n", "import { syntaxTree } from '@codemirror/language';\nimport type { LRLanguage } from '@codemirror/language';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport type { ChangeSpec, EditorState, StateCommand } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport { narrowToNonSpace } from '../lib/utils';\n\ntype CommentTokens = [string, string];\n\nconst htmlComment: CommentTokens = ['<!--', '-->'];\nconst cssComment: CommentTokens = ['/*', '*/'];\n\nexport const toggleComment: StateCommand = ({ state, dispatch }) => {\n    let changes: ChangeSpec[] = [];\n\n    for (const sel of state.selection.ranges) {\n        if (cssLanguage.isActiveAt(state, sel.from)) {\n            changes = changes.concat(toggleCSSComment(state, sel.from));\n        } else if (htmlLanguage.isActiveAt(state, sel.from)) {\n            changes = changes.concat(toggleHTMLComment(state, sel.from));\n        }\n    }\n\n    if (!changes.length) {\n        return false;\n    }\n\n    const tr = state.update({ changes });\n    dispatch(tr);\n\n    return true;\n};\n\nfunction toggleHTMLComment(state: EditorState, pos: number): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    const ctx = getContextOfType(state, pos, ['Element', 'Comment']);\n    if (ctx) {\n        if (ctx.name === 'Comment') {\n            result = result.concat(stripComment(state, ctx, htmlComment))\n        } else {\n            result = result.concat(addComment(state, ctx, htmlComment, htmlLanguage));\n        }\n    }\n\n    return result;\n}\n\nfunction toggleCSSComment(state: EditorState, pos: number): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    const ctx = getContextOfType(state, pos, ['RuleSet', 'Declaration', 'Comment']);\n    if (ctx) {\n        if (ctx.name === 'Comment') {\n            result = result.concat(stripComment(state, ctx, cssComment));\n        } else {\n            result = result.concat(addComment(state, ctx, cssComment, cssLanguage));\n        }\n    }\n\n    return result;\n}\n\nfunction getContextOfType(state: EditorState, pos: number, types: string[]): SyntaxNode | undefined {\n    const names = new Set(types);\n    let node: SyntaxNode | null = syntaxTree(state).resolve(pos, 1);\n    while (node) {\n        if (names.has(node.name)) {\n            return node;\n        }\n        node = node.parent;\n    }\n\n    return;\n}\n\nfunction stripComment(state: EditorState, node: SyntaxNode, comment: CommentTokens): ChangeSpec[] {\n    const innerRange = narrowToNonSpace(state, {\n        from: node.from + comment[0].length,\n        to: node.to - comment[1].length\n    });\n    return [\n        { from: node.from, to: innerRange.from },\n        { from: innerRange.to, to: node.to },\n    ];\n}\n\nfunction addComment(state: EditorState, node: SyntaxNode, comment: CommentTokens, lang: LRLanguage): ChangeSpec[] {\n    // Add comment tokens around element\n    let { to } = node;\n    if (node.name === 'Declaration' && node.nextSibling?.name === ';') {\n        // edge case for CSS property\n        to = node.nextSibling.to;\n    }\n\n    let result: ChangeSpec[] = [\n        { from: node.from, insert: comment[0] + ' ' },\n        { from: to, insert: ' ' + comment[1] },\n    ];\n\n    // Remove nested comments\n    result = result.concat(stripChildComments(state, node, comment, lang));\n\n    if (node.name === 'RuleSet') {\n        // Edge case for CSS rule set: find nested block first\n        const block = node.getChild('Block');\n        if (block) {\n            result = result.concat(stripChildComments(state, block, comment, lang));\n        }\n    }\n\n    return result;\n}\n\nfunction stripChildComments(state: EditorState, node: SyntaxNode, comment: CommentTokens, lang: LRLanguage): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    for (const child of node.getChildren('Comment')) {\n        if (lang.isActiveAt(state, child.from)) {\n            result = result.concat(stripComment(state, child, comment));\n        }\n    }\n\n    return result;\n}\n", "const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check for Umlauts i.e. ä, Ä, ö, Ö, ü and Ü\n */\nfunction isUmlaut(code) {\n    return code === 196\n        || code == 214\n        || code === 220\n        || code === 228\n        || code === 246\n        || code === 252;\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport { ScannerError, Scanner as default, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isUmlaut, isWhiteSpace };\n//# sourceMappingURL=scanner.js.map\n", "import Scanner, { isWhiteSpace, isNumber, isSpace } from '@emmetio/scanner';\n\nconst nullary = token(\"null\" /* Null */, 0);\n/**\n * Parses given expression in forward direction\n */\nfunction parse(expr) {\n    const scanner = typeof expr === 'string' ? new Scanner(expr) : expr;\n    let ch;\n    let priority = 0;\n    let expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n    const tokens = [];\n    while (!scanner.eof()) {\n        scanner.eatWhile(isWhiteSpace);\n        scanner.start = scanner.pos;\n        if (consumeNumber(scanner)) {\n            if ((expected & 1 /* Primary */) === 0) {\n                error('Unexpected number', scanner);\n            }\n            tokens.push(number(scanner.current()));\n            expected = (2 /* Operator */ | 8 /* RParen */);\n        }\n        else if (isOperator(scanner.peek())) {\n            ch = scanner.next();\n            if (isSign(ch) && (expected & 16 /* Sign */)) {\n                if (isNegativeSign(ch)) {\n                    tokens.push(op1(ch, priority));\n                }\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n            else {\n                if ((expected & 2 /* Operator */) === 0) {\n                    error('Unexpected operator', scanner);\n                }\n                tokens.push(op2(ch, priority));\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n        }\n        else if (scanner.eat(40 /* LeftParenthesis */)) {\n            if ((expected & 4 /* LParen */) === 0) {\n                error('Unexpected \"(\"', scanner);\n            }\n            priority += 10;\n            expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */ | 32 /* NullaryCall */);\n        }\n        else if (scanner.eat(41 /* RightParenthesis */)) {\n            priority -= 10;\n            if (expected & 32 /* NullaryCall */) {\n                tokens.push(nullary);\n            }\n            else if ((expected & 8 /* RParen */) === 0) {\n                error('Unexpected \")\"', scanner);\n            }\n            expected = (2 /* Operator */ | 8 /* RParen */ | 4 /* LParen */);\n        }\n        else {\n            error('Unknown character', scanner);\n        }\n    }\n    if (priority < 0 || priority >= 10) {\n        error('Unmatched \"()\"', scanner);\n    }\n    const result = orderTokens(tokens);\n    if (result === null) {\n        error('Parity', scanner);\n    }\n    return result;\n}\n/**\n * Consumes number from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */) && scanner.eatWhile(isNumber)) {\n        // short decimal notation: .025\n        return true;\n    }\n    if (scanner.eatWhile(isNumber) && (!scanner.eat(46 /* Dot */) || scanner.eatWhile(isNumber))) {\n        // either integer or decimal: 10, 10.25\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Orders parsed tokens (operands and operators) in given array so that they are\n * laid off in order of execution\n */\nfunction orderTokens(tokens) {\n    const operators = [];\n    const operands = [];\n    let nOperators = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        if (t.type === \"num\" /* Number */) {\n            operands.push(t);\n        }\n        else {\n            nOperators += t.type === \"op1\" /* Op1 */ ? 1 : 2;\n            while (operators.length) {\n                if (t.priority <= operators[operators.length - 1].priority) {\n                    operands.push(operators.pop());\n                }\n                else {\n                    break;\n                }\n            }\n            operators.push(t);\n        }\n    }\n    return nOperators + 1 === operands.length + operators.length\n        ? operands.concat(operators.reverse())\n        : null /* parity */;\n}\n/**\n * Number token factory\n */\nfunction number(value, priority) {\n    return token(\"num\" /* Number */, parseFloat(value), priority);\n}\n/**\n * Unary operator factory\n * @param value    Operator  character code\n * @param priority Operator execution priority\n */\nfunction op1(value, priority = 0) {\n    if (value === 45 /* Minus */) {\n        priority += 2;\n    }\n    return token(\"op1\" /* Op1 */, value, priority);\n}\n/**\n * Binary operator factory\n * @param value Operator  character code\n * @param priority Operator execution priority\n */\nfunction op2(value, priority = 0) {\n    if (value === 42 /* Multiply */) {\n        priority += 1;\n    }\n    else if (value === 47 /* Divide */ || value === 92 /* IntDivide */) {\n        priority += 2;\n    }\n    return token(\"op2\" /* Op2 */, value, priority);\n}\nfunction error(name, scanner) {\n    if (scanner) {\n        name += ` at column ${scanner.pos} of expression`;\n    }\n    throw new Error(name);\n}\nfunction isSign(ch) {\n    return isPositiveSign(ch) || isNegativeSign(ch);\n}\nfunction isPositiveSign(ch) {\n    return ch === 43 /* Plus */;\n}\nfunction isNegativeSign(ch) {\n    return ch === 45 /* Minus */;\n}\nfunction isOperator(ch) {\n    return ch === 43 /* Plus */ || ch === 45 /* Minus */ || ch === 42 /* Multiply */\n        || ch === 47 /* Divide */ || ch === 92 /* IntDivide */;\n}\nfunction token(type, value, priority = 0) {\n    return { type, value, priority };\n}\n\nconst defaultOptions = {\n    lookAhead: true,\n    whitespace: true\n};\nfunction extract(text, pos = text.length, options) {\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    const scanner = { text, pos };\n    let ch;\n    if (opt.lookAhead && cur(scanner) === 41 /* RightParenthesis */) {\n        // Basically, we should consume right parenthesis only with optional whitespace\n        scanner.pos++;\n        const len = text.length;\n        while (scanner.pos < len) {\n            ch = cur(scanner);\n            if (ch !== 41 /* RightParenthesis */ && !(opt.whitespace && isSpace(ch))) {\n                break;\n            }\n            scanner.pos++;\n        }\n    }\n    const end = scanner.pos;\n    let braces = 0;\n    while (scanner.pos >= 0) {\n        if (number$1(scanner)) {\n            continue;\n        }\n        ch = prev(scanner);\n        if (ch === 41 /* RightParenthesis */) {\n            braces++;\n        }\n        else if (ch === 40 /* LeftParenthesis */) {\n            if (!braces) {\n                break;\n            }\n            braces--;\n        }\n        else if (!((opt.whitespace && isSpace(ch)) || isSign(ch) || isOperator(ch))) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (scanner.pos !== end && !braces) {\n        // Trim whitespace\n        while (isSpace(cur(scanner))) {\n            scanner.pos++;\n        }\n        return [scanner.pos, end];\n    }\n    return null;\n}\n/**\n * Backward-consumes number from given scanner, if possible\n */\nfunction number$1(scanner) {\n    if (isNumber(prev(scanner))) {\n        scanner.pos--;\n        let dot = false;\n        let ch;\n        while (scanner.pos >= 0) {\n            ch = prev(scanner);\n            if (ch === 46 /* . */) {\n                if (dot) {\n                    // Decimal delimiter already consumed, abort\n                    break;\n                }\n                dot = true;\n            }\n            else if (!isNumber(ch)) {\n                break;\n            }\n            scanner.pos--;\n        }\n        return true;\n    }\n    return false;\n}\nfunction prev(scanner) {\n    return scanner.text.charCodeAt(scanner.pos - 1);\n}\nfunction cur(scanner) {\n    return scanner.text.charCodeAt(scanner.pos);\n}\n\nconst ops1 = {\n    [45 /* Minus */]: num => -num\n};\nconst ops2 = {\n    [43 /* Plus */]: (a, b) => a + b,\n    [45 /* Minus */]: (a, b) => a - b,\n    [42 /* Multiply */]: (a, b) => a * b,\n    [47 /* Divide */]: (a, b) => a / b,\n    [92 /* IntDivide */]: (a, b) => Math.floor(a / b)\n};\n/**\n * Evaluates given math expression\n * @param expr Expression to evaluate\n */\nfunction evaluate(expr) {\n    if (!Array.isArray(expr)) {\n        expr = parse(expr);\n    }\n    if (!expr || !expr.length) {\n        return null;\n    }\n    const nStack = [];\n    let n1;\n    let n2;\n    let f;\n    for (let i = 0, il = expr.length; i < il; i++) {\n        const token = expr[i];\n        if (token.type === \"num\" /* Number */) {\n            nStack.push(token.value);\n        }\n        else if (token.type === \"op2\" /* Op2 */) {\n            n2 = nStack.pop();\n            n1 = nStack.pop();\n            f = ops2[token.value];\n            nStack.push(f(n1, n2));\n        }\n        else if (token.type === \"op1\" /* Op1 */) {\n            n1 = nStack.pop();\n            f = ops1[token.value];\n            nStack.push(f(n1));\n        }\n        else {\n            throw new Error('Invalid expression');\n        }\n    }\n    if (nStack.length > 1) {\n        throw new Error('Invalid Expression (parity)');\n    }\n    return nStack[0];\n}\n\nexport default evaluate;\nexport { extract, parse };\n//# sourceMappingURL=math.es.js.map\n", "import { EditorSelection } from '@codemirror/state';\nimport type { ChangeSpec, SelectionRange, StateCommand } from '@codemirror/state';\nimport evaluate, { extract } from '@emmetio/math-expression';\n\nexport const evaluateMath: StateCommand = ({ state, dispatch }) => {\n    const changes: ChangeSpec[] = [];\n    const nextSel: SelectionRange[] = [];\n\n    for (const sel of state.selection.ranges) {\n        let { from, to } = sel;\n        if (from === to) {\n            const line = state.doc.lineAt(sel.from);\n            const expr = extract(line.text, sel.from - line.from);\n            if (expr) {\n                from = expr[0] + line.from;\n                to = expr[1] + line.from;\n            }\n        }\n\n        if (from !== to) {\n            try {\n                const result = evaluate(state.doc.sliceString(from ,to));\n                if (result !== null) {\n                    const insert = result.toFixed(4).replace(/\\.?0+$/, '');\n                    changes.push({ from, to, insert });\n                    nextSel.push(EditorSelection.range(from + insert.length, from + insert.length));\n                }\n            } catch (err) {\n                nextSel.push(sel);\n                console.error(err);\n            }\n        }\n    }\n\n    if (changes.length) {\n        const tr = state.update({\n            changes,\n            selection: EditorSelection.create(nextSel)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n", "import { EditorSelection } from '@codemirror/state';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { isQuote, isSpace } from '../lib/utils';\n\nexport const goToNextEditPoint: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        selection: getNextSel(state, 1)\n    });\n    dispatch(tr);\n    return true;\n};\n\nexport const goToPreviousEditPoint: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        selection: getNextSel(state, -1)\n    });\n    dispatch(tr);\n    return true;\n};\n\nfunction getNextSel(state: EditorState, inc: number): EditorSelection {\n    const nextSel: SelectionRange[] = [];\n    for (const sel of state.selection.ranges) {\n        const nextPos = findNewEditPoint(state, sel.from + inc, inc);\n        if (nextPos != null) {\n            nextSel.push(EditorSelection.cursor(nextPos));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    return EditorSelection.create(nextSel);\n}\n\nfunction findNewEditPoint(state: EditorState, pos: number, inc: number): number | undefined {\n    const doc = state.doc.toString();\n    const docSize = doc.length;\n    let curPos = pos;\n\n    while (curPos < docSize && curPos >= 0) {\n        curPos += inc;\n        const cur = doc[curPos];\n        const next = doc[curPos + 1];\n        const prev = doc[curPos - 1];\n\n        if (isQuote(cur) && next === cur && prev === '=') {\n            // Empty attribute value\n            return curPos + 1;\n        }\n\n        if (cur === '<' && prev === '>') {\n            // Between tags\n            return curPos;\n        }\n\n        if (isNewLine(cur)) {\n            const line = state.doc.lineAt(curPos + inc);\n            if (!line.length || isSpace(line.text)) {\n                // Empty line\n                return line.from + line.text.length;\n            }\n        }\n    }\n\n    return;\n}\n\nfunction isNewLine(ch: string) {\n    return ch === '\\r' || ch === '\\n';\n}\n", "import { EditorSelection } from '@codemirror/state';\nimport type { SelectionRange, StateCommand } from '@codemirror/state';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { getTagContext } from '../lib/emmet';\n\nexport const goToTagPair: StateCommand = ({ state, dispatch }) => {\n    const nextRanges: SelectionRange[] = [];\n    let found = false;\n    for (const sel of state.selection.ranges) {\n        const pos = sel.from;\n        let nextSel = sel;\n        if (htmlLanguage.isActiveAt(state, pos)) {\n            const ctx = getTagContext(state, pos);\n            if (ctx && ctx.open && ctx.close) {\n                found = true;\n                const { open, close } = ctx;\n                const nextPos = open.from <= pos && pos < open.to\n                    ? close.from\n                    : open.from;\n                nextSel = EditorSelection.cursor(nextPos);\n            }\n        }\n\n        nextRanges.push(nextSel);\n    }\n\n    if (found) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextRanges)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n", "import { EditorSelection } from '@codemirror/state';\nimport type { StateCommand, TransactionSpec } from '@codemirror/state';\nimport type { StateCommandTarget } from '../lib/types';\n\nexport const incrementNumber1: StateCommand = target => incDecNumber(target, 1);\nexport const decrementNumber1: StateCommand = target => incDecNumber(target, -1);\nexport const incrementNumber01: StateCommand = target => incDecNumber(target, .1);\nexport const decrementNumber01: StateCommand = target => incDecNumber(target, -.1);\nexport const incrementNumber10: StateCommand = target => incDecNumber(target, 10);\nexport const decrementNumber10: StateCommand = target => incDecNumber(target, -10);\n\nfunction incDecNumber({ state, dispatch }: StateCommandTarget, delta: number): boolean {\n    const specs: TransactionSpec[] = [];\n\n    for (const sel of state.selection.ranges) {\n        let { from, to } = sel;\n        if (from === to) {\n            // No selection, extract number\n            const line = state.doc.lineAt(from);\n            const numRange = extractNumber(line.text, from - line.from);\n            if (numRange) {\n                from = line.from + numRange[0];\n                to = line.from + numRange[1];\n            }\n        }\n\n        if (from !== to) {\n            // Try to update value in given region\n            let value = updateNumber(state.doc.sliceString(from, to), delta);\n            specs.push({\n                changes: { from, to, insert: value },\n                selection: EditorSelection.range(from, from + value.length)\n            });\n        } else {\n            specs.push({ selection: sel });\n        }\n    }\n\n    if (specs.some(s => s.changes)) {\n        const tr = state.update(...specs);\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Extracts number from text at given location\n */\nfunction extractNumber(text: string, pos: number): [number, number] | undefined {\n    let hasDot = false;\n    let end = pos;\n    let start = pos;\n    let ch: number;\n    const len = text.length;\n\n    // Read ahead for possible numbers\n    while (end < len) {\n        ch = text.charCodeAt(end);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        end++;\n    }\n\n    // Read backward for possible numerics\n    while (start >= 0) {\n        ch = text.charCodeAt(start - 1);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        start--;\n    }\n\n    // Negative number?\n    if (start > 0 && text[start - 1] === '-') {\n        start--;\n    }\n\n    if (start !== end) {\n        return [start, end];\n    }\n\n    return;\n}\n\nfunction updateNumber(num: string, delta: number, precision = 3): string {\n    const value = parseFloat(num) + delta;\n\n    if (isNaN(value)) {\n        return num;\n    }\n\n    const neg = value < 0;\n    let result = Math.abs(value).toFixed(precision);\n\n    // Trim trailing zeroes and optionally decimal number\n    result = result.replace(/\\.?0+$/, '');\n\n    // Trim leading zero if input value doesn't have it\n    if ((num[0] === '.' || num.startsWith('-.')) && result[0] === '0') {\n        result = result.slice(1);\n    }\n\n    return (neg ? '-' : '') + result;\n}\n\nfunction isDot(ch: number) {\n    return ch === 46;\n}\n\n/**\n * Check if given code is a number\n */\nexport function isNumber(code: number): boolean {\n    return code > 47 && code < 58;\n}\n", "import type { ChangeSpec, EditorState, StateCommand, TransactionSpec } from '@codemirror/state';\nimport { getTagContext } from '../lib/emmet';\nimport type { ContextTag } from '../lib/types';\nimport { lineIndent } from '../lib/output';\nimport { narrowToNonSpace, rangeEmpty, isSpace } from '../lib/utils';\n\nexport const removeTag: StateCommand = ({ state, dispatch }) => {\n    const specs: TransactionSpec[] = [];\n    for (const sel of state.selection.ranges) {\n        const tag = getTagContext(state, sel.from);\n        if (tag) {\n            specs.push(removeTagSpec(state, tag));\n        } else {\n            specs.push({ selection: sel });\n        }\n    }\n\n    if (specs.some(t => t.changes)) {\n        const tr = state.update(...specs);\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction removeTagSpec(state: EditorState, { open, close }: ContextTag): TransactionSpec {\n    const changes: ChangeSpec[] = [];\n    if (close) {\n        // Remove open and close tag and dedent inner content\n        const innerRange = narrowToNonSpace(state, { from: open.to, to: close.from });\n        if (!rangeEmpty(innerRange)) {\n            // Gracefully remove open and close tags and tweak indentation on tag contents\n            changes.push({ from: open.from, to: innerRange.from });\n\n            const lineStart = state.doc.lineAt(open.from);\n            const lineEnd = state.doc.lineAt(close.to);\n            if (lineStart.number !== lineEnd.number) {\n                // Skip two lines: first one for open tag, on second one\n                // indentation will be removed with open tag\n                let lineNum = lineStart.number + 2;\n                const baseIndent = getLineIndent(state, open.from);\n                const innerIndent = getLineIndent(state, innerRange.from);\n\n                while (lineNum <= lineEnd.number) {\n                    const line = state.doc.line(lineNum);\n                    if (isSpace(line.text.slice(0, innerIndent.length))) {\n                        changes.push({\n                            from: line.from,\n                            to: line.from + innerIndent.length,\n                            insert: baseIndent\n                        });\n                    }\n                    lineNum++;\n                }\n            }\n\n            changes.push({ from: innerRange.to, to: close.to });\n        } else {\n            changes.push({ from: open.from, to: close.to });\n        }\n    } else {\n        changes.push(open);\n    }\n\n    return { changes };\n}\n\n/**\n * Returns indentation for line found from given character location\n */\nfunction getLineIndent(state: EditorState, pos: number): string {\n    return lineIndent(state.doc.lineAt(pos));\n}\n", "import { syntaxTree } from '@codemirror/language';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { EditorSelection } from '@codemirror/state';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport type { SyntaxNode, TreeCursor } from '@lezer/common';\nimport type { RangeObject, StateCommandTarget } from '../lib/types';\nimport { fullCSSDeclarationRange, isQuote, isSpace, rangeContains, substr } from '../lib/utils';\nimport { getPropertyRanges, getSelectorRange } from '../lib/context';\n\nexport const selectNextItem: StateCommand = target => selectItemCommand(target, false);\nexport const selectPreviousItem: StateCommand = target => selectItemCommand(target, true);\n\nconst htmlParents = new Set(['OpenTag', 'CloseTag', 'SelfClosingTag']);\nconst cssEnter = new Set(['Block', 'RuleSet', 'StyleSheet']);\nconst cssParents = new Set(['RuleSet', 'Block', 'StyleSheet', 'Declaration']);\n\nfunction selectItemCommand({ state, dispatch }: StateCommandTarget, reverse: boolean): boolean {\n    let handled = false;\n    const selections: SelectionRange[] = [];\n    for (const sel of state.selection.ranges) {\n        const range = cssLanguage.isActiveAt(state, sel.from)\n            ? getCSSRange(state, sel, reverse)\n            : getHTMLRange(state, sel, reverse);\n        if (range) {\n            handled = true;\n            selections.push(EditorSelection.range(range.from, range.to));\n        } else {\n            selections.push(sel);\n        }\n    }\n\n    if (handled) {\n        const tr = state.update({\n            selection: EditorSelection.create(selections)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\nfunction getHTMLRange(state: EditorState, sel: SelectionRange, reverse?: boolean): RangeObject | undefined {\n    const node = getStartHTMLNode(state, sel);\n    const cursor = node.cursor();\n\n    do {\n        if (cursor.name === 'OpenTag' || cursor.name === 'SelfClosingTag') {\n            const ranges = getHTMLCandidates(state, cursor.node);\n            const range = findRange(sel, ranges, reverse);\n            if (range) {\n                return range;\n            }\n        }\n    } while (moveHTMLCursor(cursor, reverse));\n\n    return;\n}\n\nfunction getCSSRange(state: EditorState, sel: SelectionRange, reverse?: boolean) {\n    const node = getStartCSSNode(state, sel);\n    const cursor = node.cursor();\n\n    do {\n        const ranges = getCSSCandidates(state, cursor.node);\n        const range = findRange(sel, ranges, reverse);\n        if (range) {\n            return range;\n        }\n    } while (moveCSSCursor(cursor, reverse));\n\n    return;\n}\n\nfunction moveHTMLCursor(cursor: TreeCursor, reverse?: boolean): boolean {\n    const enter = cursor.name === 'Element';\n    return reverse ? cursor.prev(enter) : cursor.next(enter);\n}\n\nfunction moveCSSCursor(cursor: TreeCursor, reverse?: boolean): boolean {\n    const enter = cssEnter.has(cursor.name);\n    return reverse ? cursor.prev(enter) : cursor.next(enter);\n}\n\nfunction getStartHTMLNode(state: EditorState, sel: SelectionRange): SyntaxNode {\n    let node: SyntaxNode = syntaxTree(state).resolveInner(sel.to, 1);\n\n    // In case if we’re inside tag, find closest start node\n    let ctx: SyntaxNode | null = node;\n    while (ctx) {\n        if (htmlParents.has(ctx.name)) {\n            return ctx;\n        }\n        ctx = ctx.parent;\n    }\n\n    return node;\n}\n\nfunction getStartCSSNode(state: EditorState, sel: SelectionRange): SyntaxNode {\n    let node: SyntaxNode = syntaxTree(state).resolveInner(sel.to, 1);\n\n    // In case if we’re inside tag, find closest start node\n    let ctx: SyntaxNode | null = node.parent;\n    while (ctx) {\n        if (cssParents.has(ctx.name)) {\n            return ctx;\n        }\n        ctx = ctx.parent;\n    }\n\n    return node;\n}\n\n/**\n * Returns candidates for selection from given StartTag or SelfClosingTag\n */\nfunction getHTMLCandidates(state: EditorState, node: SyntaxNode): RangeObject[] {\n    let result: RangeObject[] = [];\n    let child = node.firstChild;\n    while (child) {\n        if (child.name === 'TagName') {\n            result.push(child);\n        } else if (child.name === 'Attribute') {\n            result.push(child);\n            const attrName = child.getChild('AttributeName');\n            const attrValue = attrValueRange(state, child);\n            if (attrName && attrValue) {\n                result.push(attrName, attrValue);\n                if (substr(state, attrName).toLowerCase() === 'class') {\n                    // For class names, split value into space-separated tokens\n                    result = result.concat(tokenList(substr(state, attrValue)));\n                }\n            }\n        }\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * Returns candidates for RuleSet node\n */\nfunction getCSSCandidates(state: EditorState, node: SyntaxNode): RangeObject[] {\n    let result: RangeObject[] = [];\n    if (node.name === 'RuleSet') {\n        const selector = getSelectorRange(node);\n        result.push(selector);\n        const block = node.getChild('Block');\n        if (block) {\n            for (const child of block.getChildren('Declaration')) {\n                result = result.concat(getCSSCandidates(state, child));\n            }\n        }\n    } else if (node.name === 'Declaration') {\n        result.push(fullCSSDeclarationRange(node));\n        const { name, value } = getPropertyRanges(node);\n        name && result.push(name);\n        value && result.push(value);\n    }\n\n    return result;\n}\n\nfunction attrValueRange(state: EditorState, attr: SyntaxNode): RangeObject | undefined {\n    const value = attr.getChild('AttributeValue');\n    if (value) {\n        let { from, to } = value;\n        const valueStr = substr(state, value);\n        if (isQuote(valueStr[0])) {\n            from++;\n            if (valueStr[0] === valueStr[valueStr.length - 1]) {\n                to--;\n            }\n        }\n\n        if (from !== to) {\n            return { from, to };\n        }\n    }\n\n    return;\n}\n\n/**\n * Returns ranges of tokens in given value. Tokens are space-separated words.\n */\nfunction tokenList(value: string, offset = 0): RangeObject[] {\n    const ranges: RangeObject[] = [];\n    const len = value.length;\n    let pos = 0;\n    let start = 0;\n    let end = len;\n\n    while (pos < len) {\n        end = pos;\n        const ch = value.charAt(pos++);\n        if (isSpace(ch)) {\n            if (start !== end) {\n                ranges.push({\n                    from: offset + start,\n                    to: offset + end\n                });\n            }\n\n            while (isSpace(value.charAt(pos))) {\n                pos++;\n            }\n\n            start = pos;\n        }\n    }\n\n    if (start !== pos) {\n        ranges.push({\n            from: offset + start,\n            to: offset + pos\n        });\n    }\n\n    return ranges;\n}\n\nfunction findRange(sel: SelectionRange, ranges: RangeObject[], reverse = false): RangeObject | undefined {\n    if (reverse) {\n        ranges = ranges.slice().reverse();\n    }\n\n    let needNext = false;\n    let candidate: RangeObject | undefined;\n\n    for (const r of ranges) {\n        if (needNext) {\n            return r;\n        }\n        if (r.from === sel.from && r.to === sel.to) {\n            // This range is currently selected, request next\n            needNext = true;\n        } else if (!candidate && (rangeContains(r, sel) || (reverse && r.from <= sel.from) || (!reverse && r.from >= sel.from))) {\n            candidate = r;\n        }\n    }\n\n    return !needNext ? candidate : undefined;\n}\n", "import type { ChangeSpec, EditorState, StateCommand } from '@codemirror/state';\nimport { getTagContext } from '../lib/emmet';\nimport { isSpace } from '../lib/utils';\n\nexport const splitJoinTag: StateCommand = ({ state, dispatch }) => {\n    const changes: ChangeSpec[] = [];\n    for (const sel of state.selection.ranges) {\n        const tag = getTagContext(state, sel.from);\n        if (tag) {\n            const { open, close } = tag;\n            if (close) {\n                // Join tag: remove tag contents, if any, and add closing slash\n                let closing = isSpace(getChar(state, open.to - 2)) ? '/' : ' /';\n                changes.push({\n                    from: open.to - 1,\n                    to: close.to,\n                    insert: `${closing}>`\n                });\n            } else {\n                // Split tag: add closing part and remove closing slash\n                let insert = `</${tag.name}>`;\n                let from = open.to;\n                let to = open.to;\n\n                if (getChar(state, open.to - 2) === '/') {\n                    from -= 2;\n                    if (isSpace(getChar(state, from - 1))) {\n                        from--;\n                    }\n                    insert = '>' + insert;\n                }\n\n                changes.push({ from, to, insert });\n            }\n        }\n    }\n\n    if (changes.length) {\n        const tr = state.update({ changes });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction getChar(state: EditorState, pos: number): string {\n    return state.doc.sliceString(pos, pos + 1);\n}\n", "import type { UserConfig } from 'emmet';\nimport { EditorView, keymap, ViewPlugin } from '@codemirror/view';\nimport type { ViewUpdate } from '@codemirror/view';\nimport { EditorState, StateEffect, StateField } from '@codemirror/state';\nimport type { Extension, StateCommand, } from '@codemirror/state';\nimport { undo } from '@codemirror/commands';\nimport { expand, getOptions, getTagContext } from '../lib/emmet';\nimport { getSelectionsFromSnippet, narrowToNonSpace, rangeEmpty, substr } from '../lib/utils';\nimport type { RangeObject, ContextTag } from '../lib/types';\nimport { lineIndent } from '../lib/output';\n\ninterface WrapAbbreviation {\n    abbreviation: string;\n    range: RangeObject;\n    options: UserConfig;\n    context?: ContextTag;\n}\n\nconst updateAbbreviation = StateEffect.define<WrapAbbreviation | null>();\n\nconst wrapAbbreviationField = StateField.define<WrapAbbreviation | null>({\n    create: () => null,\n    update(value, tr) {\n        for (const effect of tr.effects) {\n            if (effect.is(updateAbbreviation)) {\n                value = effect.value;\n            }\n        }\n        return value;\n    }\n});\n\nconst wrapTheme = EditorView.baseTheme({\n    '.emmet-wrap-with-abbreviation': {\n        position: 'absolute',\n        top: 0,\n        zIndex: 2,\n        width: '100%'\n    },\n    '.emmet-wrap-with-abbreviation__content': {\n        background: '#fff',\n        margin: '0 auto',\n        padding: '5px',\n        boxSizing: 'border-box',\n        width: '100%',\n        maxWidth: '30em',\n        borderBottomLeftRadius: '5px',\n        borderBottomRightRadius: '5px',\n        boxShadow: '0 3px 10px rgba(0, 0, 0, 0.3)',\n    },\n    '.emmet-wrap-with-abbreviation__content input': {\n        width: '100%',\n        boxSizing: 'border-box'\n    }\n});\n\nconst enterWrapWithAbbreviation: StateCommand = ({ state, dispatch }) => {\n    const abbr = state.field(wrapAbbreviationField);\n    if (abbr === null) {\n        const sel = state.selection.main;\n        const context = getTagContext(state, sel.from);\n        const wrapRange = getWrapRange(state, sel, context);\n        const options = getOptions(state, wrapRange.from);\n        options.text = getContent(state, wrapRange);\n\n        const tr = state.update({\n            effects: [updateAbbreviation.of({\n                abbreviation: '',\n                range: wrapRange,\n                options,\n                context\n            })]\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\nconst wrapWithAbbreviationPlugin = ViewPlugin.fromClass(class WrapWithAbbreviationViewPlugin {\n    private widget: HTMLElement | null = null;\n    private input: HTMLInputElement | null = null;\n\n    update(update: ViewUpdate) {\n        const { state, view } = update;\n        const abbr = state.field(wrapAbbreviationField);\n        if (abbr) {\n            if (!this.widget) {\n                this.createInputPanel(view);\n            }\n            this.updateAbbreviation(abbr.abbreviation);\n        } else if (this.widget) {\n            this.disposeWidget();\n            view.focus();\n        }\n    }\n\n    // TODO use @codemirror/panel instead\n    private createInputPanel(view: EditorView) {\n        const widget = document.createElement('div');\n        widget.className = 'emmet-wrap-with-abbreviation';\n\n        const content = document.createElement('div');\n        content.className = 'emmet-wrap-with-abbreviation__content';\n\n        const input = document.createElement('input');\n        input.placeholder = 'Enter abbreviation';\n\n        let updated = false;\n\n        const undoUpdate = () => {\n            if (updated) {\n                undo(view);\n                updated = false;\n            }\n        };\n\n        input.addEventListener('input', () => {\n            const abbr = view.state.field(wrapAbbreviationField);\n            if (abbr) {\n                const nextAbbreviation = input.value;\n                undoUpdate();\n\n                const nextAbbr: WrapAbbreviation = {\n                    ...abbr,\n                    abbreviation: nextAbbreviation\n                };\n\n                if (nextAbbr.abbreviation) {\n                    updated = true;\n                    const { from, to } = nextAbbr.range;\n                    const expanded = expand(view.state, nextAbbr.abbreviation, nextAbbr.options);\n                    const { ranges, snippet } = getSelectionsFromSnippet(expanded, from);\n                    const nextSel = ranges[0];\n\n                    view.dispatch({\n                        effects: [updateAbbreviation.of(nextAbbr)],\n                        changes: [{\n                            from,\n                            to,\n                            insert: snippet\n                        }],\n                        selection: {\n                            head: nextSel.from,\n                            anchor: nextSel.to\n                        }\n                    });\n                } else {\n                    view.dispatch({\n                        effects: [updateAbbreviation.of(nextAbbr)],\n                    });\n                }\n            }\n        });\n\n        input.addEventListener('keydown', evt => {\n            if (evt.key === 'Escape' || evt.key === 'Enter') {\n                if (evt.key === 'Escape') {\n                    undoUpdate();\n                }\n                evt.preventDefault();\n                view.dispatch({\n                    effects: [updateAbbreviation.of(null)]\n                });\n            }\n        });\n\n        content.append(input)\n        widget.append(content);\n        view.dom.append(widget);\n        this.widget = widget;\n        this.input = input;\n        input.focus();\n    }\n\n    private updateAbbreviation(value: string) {\n        if (this.input && this.input.value !== value) {\n            this.input.value = value;\n        }\n    }\n\n    private disposeWidget() {\n        if (this.widget) {\n            this.widget.remove();\n            this.widget = this.input = null;\n        }\n    }\n});\n\nexport function wrapWithAbbreviation(key = 'Ctrl-w'): Extension[] {\n    return [\n        wrapAbbreviationField,\n        wrapWithAbbreviationPlugin,\n        wrapTheme,\n        keymap.of([{\n            key,\n            run: enterWrapWithAbbreviation\n        }])\n    ];\n}\n\nfunction getWrapRange(editor: EditorState, range: RangeObject, context?: ContextTag): RangeObject {\n    if (rangeEmpty(range) && context) {\n        // No selection means user wants to wrap current tag container\n        const { open, close } = context;\n        const pos = range.from;\n\n        // Check how given point relates to matched tag:\n        // if it's in either open or close tag, we should wrap tag itself,\n        // otherwise we should wrap its contents\n\n        if (inRange(open, pos) || (close && inRange(close, pos))) {\n            return {\n                from: open.from,\n                to: close ? close.to : open.to\n            };\n        }\n\n        if (close) {\n            return narrowToNonSpace(editor, { from: open.to, to: close.from });\n        }\n    }\n\n    return range;\n}\n\nfunction inRange(range: RangeObject, pt: number): boolean {\n    return range.from < pt && pt < range.to;\n}\n\n/**\n * Returns contents of given region, properly de-indented\n */\nfunction getContent(state: EditorState, range: RangeObject): string | string[] {\n    const baseIndent = lineIndent(state.doc.lineAt(range.from));\n    const srcLines = substr(state, range).split('\\n');\n    const destLines = srcLines.map(line => {\n        return line.startsWith(baseIndent)\n            ? line.slice(baseIndent.length)\n            : line;\n    });\n\n    return destLines;\n}\n"],
  "mappings": "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",
  "names": ["keymap", "isNumber$1", "code", "isAlpha$1", "from", "to", "isAlphaNumericWord", "isAlphaWord", "isUmlaut", "isWhiteSpace$3", "isSpace", "isQuote$2", "Scanner$1", "Scanner", "str", "start", "end", "match", "ch", "ok", "n", "message", "pos", "ScannerError", "tokenScanner$1", "tokens", "peek$3", "scanner", "next", "slice", "readable$1", "consume$2", "test", "token", "error$1", "err", "abbreviation", "abbr", "options", "result", "statements", "ctx", "node", "stack", "element$2", "group", "isChildOperator", "isSiblingOperator$1", "isClimbOperator", "isGroupStart", "isBracket$2", "repeater$1", "attr", "elem", "elementName", "isEmpty", "isRepeater", "text", "getText", "shortAttribute", "attributeSet", "isCloseOperator", "isAttributeSetStart", "attributes", "attribute", "isAttributeSetEnd", "isWhiteSpace$2", "type", "isOperator$1", "count", "createLiteral$1", "literal$1$1", "quoted", "name", "value", "isEquals", "quote", "isQuote$1", "allowBrackets", "brackets", "isCapitalizedLiteral", "isClassNameOperator", "isElementName$1", "isTextStart", "context", "isOpen", "isSingle", "isLiteral$2", "Chars$3", "Chars", "escaped", "tokenize$1", "source", "getToken$1", "field$2", "repeaterPlaceholder", "repeaterNumber", "repeater", "whiteSpace$1", "literal$2", "operator$1", "bracket$1", "expressionStart", "prev", "isAllowedOperator", "isElementName", "isAllowedSpace", "isAllowedRepeater", "bracketType", "isOpenBracket$2", "op", "operatorType$1", "implicit", "size", "reverse", "base", "parent", "index", "consumePlaceholder$2", "stream", "operators", "tokenVisitor", "state", "i", "lastIx", "parentIx", "parentRepeater", "stringify$1", "urlRegex", "emailRegex", "convert", "textInserted", "cleanText", "s", "convertGroup", "_a", "varValue", "deepest", "deepestNode", "last$1", "insertText", "insertHref", "convertStatement", "original", "repeat", "items", "isGroup", "convertElement", "target", "children", "stringifyName", "stringifyValue$1", "child", "convertAttribute", "isField$1", "attachRepeater", "implied", "isBoolean", "valueType", "arr", "href", "hrefAttribute", "item", "parseAbbreviation", "OperatorType", "Chars$2", "tokenize", "isValue", "getToken", "mergeTokens", "shouldConsumeDashAfter", "operator", "short", "field$1", "customProperty", "numberValue", "colorValue", "stringValue", "bracket", "whiteSpace", "literal$1", "consumePlaceholder$1", "isIdentPrefix", "isKeyword", "isLiteral$1", "createLiteral", "consumeNumber", "rawValue", "finished", "valueStart", "color", "alpha", "isHex", "colorAlpha", "r", "g", "b", "a", "parseColor", "isBracket$1", "operatorType", "afterNegative", "hasDecimal", "prevPos", "hasFloat", "last", "tokenScanner", "peek$2", "readable", "consume$1", "error", "parser", "property", "consumeProperty", "isSiblingOperator", "important", "valueFragment", "valueMode", "isLiteral", "isFunctionStart", "isValueDelimiter", "isWhiteSpace$1", "isImportant", "consumeValue", "isFragmentDelimiter", "inArgument", "args", "consumeArguments", "isOpenBracket$1", "isCloseBracket$1", "isArgumentDelimiter", "isBracket", "open", "isOperator", "t1", "t2", "parse$2", "mergeAttributes", "config", "lookup", "attrName", "mergeValue", "mergeDeclarations", "glue", "append", "t", "dest", "src", "walk$1", "fn", "ancestors", "callback", "find$1", "findDeepest", "isNode", "resolveSnippets", "reversed", "warn", "resolve", "snippet", "snippetAbbr", "walkResolve", "topNode", "mergeNodes", "resolved", "expressionEnd", "createOutputStream", "level", "push", "processText", "_push", "pushString", "lines", "splitByLines$1", "il", "pushNewline", "indent", "baseIndent", "newline", "pushIndent", "pushField", "placeholder", "field", "tagName", "strCase", "attrQuote", "isBooleanAttribute", "selfClose", "isInline", "elementMap", "implicitTag", "resolveImplicitTag", "getParentElement", "contextName", "parentName", "lowercase", "latin", "ru", "sp", "vocabularies", "reLorem", "lorem", "m", "db", "minWordCount", "maxWordCount", "wordCount", "rand", "findRepeater", "paragraph", "sample", "len", "iterations", "choice", "val", "sentence", "words", "capitalize", "word", "insertCommas", "hasComma", "totalCommas", "dict", "startWithCommon", "totalWords", "element", "xsl", "matchesName", "isAllowed", "reElement", "reModifier", "blockCandidates1", "className", "blockCandidates2", "bem", "expandClassNames", "expandShortNotation", "data", "getBEMData", "classNames", "cl", "ix", "uniqueClass", "findBlockName", "updateClass", "path", "prefix", "originalClass", "getBlockName", "arrClassNames", "classValue", "stringifyValue", "parseBEM", "getBEMDataFromContext", "depth", "find", "filter", "label", "input", "isEmptyAttribute", "walk", "visitor", "current", "createWalkState", "caret", "isSnippet", "isInlineElement", "isField", "pushTokens", "out", "largestIndex", "splitByLines", "line", "shouldOutputAttribute", "TemplateChars", "template", "offset", "consumePlaceholder", "peek$1", "namePos", "afterPos", "isTokenStart", "isToken", "createCommentState", "commentNodeBefore", "shouldComment", "output", "commentNodeAfter", "comment", "attrs", "htmlTagRegex", "reservedKeywords", "html", "element$1", "format", "shouldFormat$1", "getIndent", "pushAttribute", "pushSnippet", "innerFormat", "hasNewline", "startsWithBlockTag", "valuePrefix", "lQuote", "rQuote", "getMultiValue", "isPropKey", "fieldIx", "adjacentInline", "before", "after", "matches", "key", "multiple", "indentFormat", "primary", "secondary", "collectAttributes", "shouldFormat", "pushPrimaryAttributes", "pushSecondaryAttributes", "pushValue", "isPrimaryAttribute", "lineLengths", "maxLength", "valueLength", "haml", "slim", "pug", "formatters", "parse$1", "oldTextValue", "parseOpt", "transform", "stringify", "CSSSnippetType", "reProperty", "opt", "createSnippet", "keywords", "parsed", "parseValue", "cssVal", "collectKeywords", "nest", "snippets", "snippetsSort", "cur", "isProperty", "v", "scoreMatch", "str1", "str2", "partialMatch", "str1Len", "str2Len", "minLength", "j", "score", "ch1", "ch2", "found", "acronym", "matchRatio", "delta", "maxScore", "sum", "shortHex", "asHex", "asRGB", "isShortHex", "toShortHex", "toHex", "values", "frac", "num", "digits", "hex", "pad", "CSSAbbreviationScope", "css", "isJSON", "toCamelCase", "propertyValue", "outputImportant", "outputToken", "getSingleNumeric", "getQuote", "outputValue", "separator", "prevEnd", "_", "letter", "gradientName", "parse", "convertSnippets", "isValueScope", "filteredSnippets", "getSnippetsForScope", "resolveNode", "resolveGradient", "propName", "resolveValueKeywords", "findBestMatch", "resolveAsProperty", "resolveAsSnippet", "resolveNumericValue", "gradientFn", "cssValue", "inlineValue", "getUnmatchedPart", "kw", "resolveKeyword", "defaultValue", "hasField", "wrapWithField", "minScore", "reField", "inputValue", "literal", "tail", "matchedItem", "getScoringPart", "lastPos", "ref", "dep", "aliases", "unitless", "q", "markupSnippets", "stylesheetSnippets", "xslSnippets", "pugSnippets", "variables", "defaultSyntaxes", "defaultOptions$1", "defaultConfig", "syntaxConfig", "parseSnippets", "k", "resolveConfig", "globals", "syntax", "mergedData", "typeDefaults", "typeOverride", "syntaxDefaults", "syntaxOverride", "backwardScanner", "sol", "peek", "previous", "consume", "consumeWhile", "Chars$1", "isQuote", "c", "consumeQuoted", "Brackets", "bracePairs", "isHtml", "isWhiteSpace", "consumeIdent", "consumeAttributeWithUnquotedValue", "consumeAttribute", "consumeAttributeWithQuotedValue", "isCloseBracket", "isOpenBracket", "isUnquotedValue", "isIdent", "isAlpha", "isNumber", "specialChars", "defaultOptions", "extractAbbreviation", "offsetPastAutoClosed", "getStartOffset", "isCloseBrace", "isOpenBrace", "isAbbreviation", "compiledPrefix", "consumePair", "consumeArray", "close", "consumed", "expandAbbreviation", "resolvedConfig", "stylesheet", "markup", "tabStopStart", "tabStopEnd", "narrowToNonSpace", "range", "substr", "startOffset", "endOffset", "getCaret", "contains", "fullCSSDeclarationRange", "getAttributeValueRange", "getTagAttributes", "attrNameNode", "attrValueNode", "rangesEqual", "rangeContains", "rangeEmpty", "getSelectionsFromSnippet", "ranges", "sel", "nodeToHTMLType", "getContext", "cssLanguage", "getCSSContext", "htmlLanguage", "getHTMLContext", "embedded", "tree", "syntaxTree", "getSelectorRange", "getPropertyRanges", "tip", "getContextMatchFromTag", "__spreadProps", "__spreadValues", "detectCSSContextFromHTML", "getAttributeName", "attrValue", "cleanValueRange", "getInlineCSSContext", "ptr", "props", "parseInlineProps", "prop", "limit", "space", "propList", "EmmetKnownSyntax", "getOutputOptions", "inline", "docSyntax", "getEmmetConfig", "isHTML", "lineIndent", "cache", "expand", "outputOpt", "pluginConfig", "extract", "getTagContext", "getTagName", "openTag", "closeTag", "getOptions", "info", "syntaxInfo", "getMarkupAbbreviationContext", "getStylesheetAbbreviationContext", "resetCache", "Facet", "baseConfig", "preview", "htmlSyntaxes", "jsxSyntaxes", "xmlSyntaxes", "cssSyntaxes", "stylesheetSyntaxes", "getSyntaxType", "isXML", "isCSS", "isJSX", "scope", "createPreview", "ext", "view", "EditorView", "EditorState", "syntaxHighlighting", "defaultHighlightStyle", "nextValue", "tr", "icon", "emmetCompletionSource", "tracker", "trackerField", "_from", "_to", "completionOptionsFromTracker", "cssCompletion", "JSX_PREFIX", "trackerMark", "Decoration", "resetTracker", "StateEffect", "forceTracker", "enterAbbreviationMode", "dispatch", "StateField", "pickedCompletion", "effect", "getActivationContext", "createTracker", "handleUpdate", "abbreviationPreview", "getAbbreviationPreview", "tooltip", "f", "showTooltip", "prevTooltip", "completionStatus", "canDisplayPreview", "previewConfig", "dom", "abbreviationTracker", "ViewPlugin", "__publicField", "update", "decors", "expandTracker", "expanded", "tabKeyHandler", "completion", "selectedCompletion", "autocompleteTab", "acceptCompletion", "escKeyHandler", "trackerTheme", "keymap", "typingAbbreviation", "canStartTyping", "getSyntaxFromPos", "ctxName", "getCSSActivationContext", "isTypingBeforeSelector", "isValidPrefix", "isValidAbbreviationStart", "params", "forced", "hasInvalidChars", "parsedAbbr", "simple", "markupAbbreviation", "isSimpleMarkupAbbreviation", "createPreviewConfig", "first", "previewField", "hasSnippet", "_fromA", "_toA", "fromB", "_toB", "fromA", "toA", "toB", "removed", "inserted", "abbrRange", "nextTracker", "completionInfo", "balanceOutward", "nextSel", "hasMatch", "getOutwardRanges", "targetRange", "EditorSelection", "getOutwardRanges", "state", "pos", "cssLanguage", "getCSSOutwardRanges", "htmlLanguage", "getHTMLOutwardRanges", "getHTMLOutwardRanges", "state", "pos", "result", "tree", "syntaxTree", "node", "pushHTMLRanges", "compactRanges", "getCSSOutwardRanges", "state", "pos", "result", "node", "syntaxTree", "pushCSSRanges", "compactRanges", "pushHTMLRanges", "node", "ranges", "selfClose", "open", "close", "pushCSSRanges", "state", "pos", "narrowToNonSpace", "name", "value", "getPropertyRanges", "contains", "fullCSSDeclarationRange", "compactRanges", "inward", "result", "a", "b", "range", "prev", "last", "htmlComment", "cssComment", "toggleComment", "state", "dispatch", "changes", "sel", "cssLanguage", "toggleCSSComment", "htmlLanguage", "toggleHTMLComment", "tr", "pos", "result", "ctx", "getContextOfType", "stripComment", "addComment", "types", "names", "node", "syntaxTree", "comment", "innerRange", "narrowToNonSpace", "lang", "to", "_a", "stripChildComments", "block", "child", "isNumber", "code", "isWhiteSpace", "isSpace", "Scanner", "str", "start", "end", "match", "ch", "ok", "n", "message", "ScannerError", "nullary", "token", "parse", "expr", "scanner", "priority", "expected", "tokens", "consumeNumber", "error", "number", "isOperator", "isSign", "isNegativeSign", "op1", "op2", "orderTokens", "operators", "operands", "nOperators", "t", "value", "name", "isPositiveSign", "type", "defaultOptions", "extract", "text", "options", "opt", "cur", "len", "braces", "number$1", "prev", "dot", "ops1", "num", "ops2", "a", "b", "evaluate", "nStack", "n1", "n2", "f", "i", "il", "evaluateMath", "nextSel", "from", "line", "insert", "EditorSelection", "err", "goToNextEditPoint", "getNextSel", "goToPreviousEditPoint", "inc", "nextPos", "findNewEditPoint", "doc", "docSize", "curPos", "next", "isQuote", "isNewLine", "goToTagPair", "nextRanges", "found", "getTagContext", "open", "close", "incrementNumber1", "target", "incDecNumber", "decrementNumber1", "incDecNumber", "state", "dispatch", "delta", "specs", "sel", "from", "to", "line", "numRange", "extractNumber", "value", "updateNumber", "EditorSelection", "s", "tr", "text", "pos", "hasDot", "end", "start", "ch", "len", "isDot", "isNumber", "num", "precision", "neg", "result", "code", "removeTag", "tag", "getTagContext", "removeTagSpec", "t", "open", "close", "changes", "innerRange", "narrowToNonSpace", "rangeEmpty", "lineStart", "lineEnd", "lineNum", "baseIndent", "getLineIndent", "innerIndent", "isSpace", "lineIndent", "selectNextItem", "target", "selectItemCommand", "selectPreviousItem", "htmlParents", "cssEnter", "cssParents", "reverse", "handled", "selections", "range", "cssLanguage", "getCSSRange", "getHTMLRange", "cursor", "getStartHTMLNode", "ranges", "getHTMLCandidates", "findRange", "moveHTMLCursor", "getStartCSSNode", "getCSSCandidates", "moveCSSCursor", "enter", "node", "syntaxTree", "ctx", "child", "attrName", "attrValue", "attrValueRange", "substr", "tokenList", "selector", "getSelectorRange", "block", "fullCSSDeclarationRange", "name", "getPropertyRanges", "attr", "valueStr", "isQuote", "offset", "needNext", "candidate", "r", "rangeContains", "splitJoinTag", "closing", "getChar", "insert", "updateAbbreviation", "StateEffect", "wrapAbbreviationField", "StateField", "effect", "wrapTheme", "EditorView", "enterWrapWithAbbreviation", "context", "wrapRange", "getWrapRange", "options", "getOptions", "getContent", "wrapWithAbbreviationPlugin", "ViewPlugin", "__publicField", "update", "view", "abbr", "widget", "content", "input", "updated", "undoUpdate", "undo", "nextAbbreviation", "nextAbbr", "__spreadProps", "__spreadValues", "expanded", "expand", "snippet", "getSelectionsFromSnippet", "nextSel", "evt", "wrapWithAbbreviation", "key", "keymap", "editor", "inRange", "pt", "emmet", "tracker", "wrapWithAbbreviation", "keymap", "expandAbbreviation", "enterAbbreviationMode", "balanceOutward", "toggleComment", "evaluateMath", "goToPreviousEditPoint", "goToNextEditPoint", "goToTagPair", "incrementNumber1", "decrementNumber1", "removeTag", "splitJoinTag", "selectNextItem", "selectPreviousItem"]
}
