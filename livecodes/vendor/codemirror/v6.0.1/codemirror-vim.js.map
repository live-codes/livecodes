{
  "version": 3,
  "sources": ["../../../../../node_modules/@replit/codemirror-vim/dist/index.js"],
  "sourcesContent": ["import { EditorSelection, MapMode, Prec, RangeSetBuilder, StateEffect, StateField } from '@codemirror/state';\nimport { foldCode, matchBrackets, indentUnit, ensureSyntaxTree, StringStream } from '@codemirror/language';\nimport { EditorView, Direction, ViewPlugin, Decoration, showPanel } from '@codemirror/view';\nimport { SearchQuery, setSearchQuery, RegExpCursor } from '@codemirror/search';\nimport { indentMore, indentLess, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorCharBackward, cursorCharLeft, insertNewlineAndIndent, indentSelection, deleteCharBackward, deleteCharForward, undo, redo } from '@codemirror/commands';\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      leaveVimMode: leaveVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n      registers['+'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+') {\n          navigator.clipboard.writeText(text);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          if (cm.state.vim) clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        if (actionArgs.registerName === '+') {\n          navigator.clipboard.readText().then((value) => {\n            this.continuePaste(cm, actionArgs, vim, value, register);\n          });\n        } else {\n          var text = register.toString();\n          this.continuePaste(cm, actionArgs, vim, text, register);\n        }\n      },\n      continuePaste: function(cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n            text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line + 1,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    /**\n     * Based on {@link findSentence}. The internal functions have the same names,\n     * but their behaviour is different. findSentence() crosses line breaks and \n     * is used for jumping to sentence beginnings before or after the current cursor position, \n     * whereas getSentence() is for getting the beginning or end of the sentence \n     * at the current cursor position, either including (a) or excluding (i) whitespace.\n     */\n    function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the pos member to represent the\n        next valid position or sets the line to null if there are\n        no more valid positions.\n       */\n      function nextChar(curr) {\n        if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n        else {\n          curr.pos += curr.dir;\n        }\n      }\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the sentence end\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        if (curr.line === \"\") {\n          return { ln: curr.ln, pos: curr.pos };\n        }\n\n        var lastSentencePos = curr.pos;\n\n        // Move one step to skip character we start on\n        nextChar(curr);\n\n        while (curr.line !== null) {\n          lastSentencePos = curr.pos;\n          if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n            if (!inclusive) {\n              return { ln: curr.ln, pos: curr.pos + 1 };\n            } \n            else {\n              nextChar(curr);\n              while (curr.line !== null ) {\n                if (isWhiteSpaceString(curr.line[curr.pos])) {\n                  lastSentencePos = curr.pos;\n                  nextChar(curr);\n                } \n                else {\n                  break;\n                }\n              }\n              return { ln: curr.ln, pos: lastSentencePos + 1 };\n            }\n          }\n          nextChar(curr);\n        }\n        return { ln: curr.ln, pos: lastSentencePos + 1 };\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the sentence start\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        if (curr.line === \"\") {\n          return { ln: curr.ln, pos: curr.pos };\n        }\n\n        var lastSentencePos = curr.pos;\n\n        // Move one step to skip character we start on\n        nextChar(curr);\n\n        while (curr.line !== null) {\n          if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n            lastSentencePos = curr.pos;\n          }\n\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n            if (!inclusive) {\n              return { ln: curr.ln, pos: lastSentencePos };\n            } \n            else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1 };\n              } \n              else {\n                return { ln: curr.ln, pos: lastSentencePos };\n              }\n            }\n          }\n\n          nextChar(curr);\n        }\n        curr.line = line;\n        if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n          return { ln: curr.ln, pos: curr.pos };\n        } \n        else {\n          return { ln: curr.ln, pos: lastSentencePos };\n        }\n\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n       /*\n         Takes an index object\n         {\n           line: the line string,\n           ln: line number,\n           pos: index in line,\n           dir: direction of traversal (-1 or 1)\n         }\n         and modifies the line, ln, and pos members to represent the\n         next valid position or sets them to null if there are\n         no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction indexFromPos(doc, pos) {\n    var ch = pos.ch;\n    var lineNumber = pos.line + 1;\n    if (lineNumber < 1) {\n        lineNumber = 1;\n        ch = 0;\n    }\n    if (lineNumber > doc.lines) {\n        lineNumber = doc.lines;\n        ch = Number.MAX_VALUE;\n    }\n    var line = doc.line(lineNumber);\n    return Math.min(line.from + Math.max(0, ch), line.to);\n}\nfunction posFromIndex(doc, offset) {\n    let line = doc.lineAt(offset);\n    return { line: line.number - 1, ch: offset - line.from };\n}\nclass Pos {\n    constructor(line, ch) {\n        this.line = line;\n        this.ch = ch;\n    }\n}\nfunction on(emitter, type, f) {\n    if (emitter.addEventListener) {\n        emitter.addEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers || (emitter._handlers = {});\n        map[type] = (map[type] || []).concat(f);\n    }\n}\nfunction off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n        emitter.removeEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers, arr = map && map[type];\n        if (arr) {\n            var index = arr.indexOf(f);\n            if (index > -1) {\n                map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n            }\n        }\n    }\n}\nfunction signal(emitter, type, ...args) {\n    var _a;\n    var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nfunction signalTo(handlers, ...args) {\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nvar specialKey = {\n    Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n    Enter: 'CR', ' ': 'Space'\n};\nvar ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1, CapsLock: 1, AltGraph: 1 };\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\w\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) {\n    wordChar = /[\\w]/;\n}\n// workaround for missing api for merging transactions\nfunction dispatchChange(cm, transaction) {\n    var view = cm.cm6;\n    var type = \"input.type.compose\";\n    if (cm.curOp) {\n        if (!cm.curOp.lastChange)\n            type = \"input.type.compose.start\";\n    }\n    if (transaction.annotations) {\n        try {\n            transaction.annotations.some(function (note) {\n                if (note.value == \"input\")\n                    note.value = type;\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    else {\n        transaction.userEvent = type;\n    }\n    return view.dispatch(transaction);\n}\nfunction runHistoryCommand(cm, revert) {\n    var _a;\n    if (cm.curOp) {\n        cm.curOp.$changeStart = undefined;\n    }\n    (revert ? undo : redo)(cm.cm6);\n    let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;\n    // vim mode expects the changed text to be either selected or cursor placed at the start\n    if (changeStartIndex != null) {\n        cm.cm6.dispatch({ selection: { anchor: changeStartIndex } });\n    }\n}\nclass CodeMirror {\n    constructor(cm6) {\n        this.state = {};\n        this.marks = Object.create(null);\n        this.$mid = 0; // marker id counter\n        this.options = {};\n        this._handlers = {};\n        // TODO change vim.js to not use obscure api\n        this.doc = {\n            history: {\n                done: [\n                    {\n                        changes: [\n                            {\n                                cm: this,\n                                get to() {\n                                    return this.cm.posFromIndex(this.cm.$lastChangeEndOffset);\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }\n        };\n        this.$lastChangeEndOffset = 0;\n        this.virtualSelection = null;\n        this.cm6 = cm6;\n        this.onChange = this.onChange.bind(this);\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    // --------------------------\n    openDialog(template, callback, options) {\n        return openDialog(this, template, callback, options);\n    }\n    ;\n    openNotification(template, options) {\n        return openNotification(this, template, options);\n    }\n    ;\n    ;\n    on(type, f) { on(this, type, f); }\n    off(type, f) { off(this, type, f); }\n    signal(type, e, handlers) { signal(this, type, e, handlers); }\n    indexFromPos(pos) {\n        return indexFromPos(this.cm6.state.doc, pos);\n    }\n    ;\n    posFromIndex(offset) {\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    foldCode(pos) {\n        let view = this.cm6;\n        let ranges = view.state.selection.ranges;\n        let doc = this.cm6.state.doc;\n        let index = indexFromPos(doc, pos);\n        let tmpRanges = EditorSelection.create([EditorSelection.range(index, index)], 0).ranges;\n        view.state.selection.ranges = tmpRanges;\n        foldCode(view);\n        view.state.selection.ranges = ranges;\n    }\n    firstLine() { return 0; }\n    ;\n    lastLine() { return this.cm6.state.doc.lines - 1; }\n    ;\n    lineCount() { return this.cm6.state.doc.lines; }\n    ;\n    setCursor(line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var offset = indexFromPos(this.cm6.state.doc, { line, ch });\n        this.cm6.dispatch({ selection: { anchor: offset } }, { scrollIntoView: !this.curOp });\n        if (this.curOp && !this.curOp.isVimOp)\n            this.onBeforeEndOperation();\n    }\n    ;\n    getCursor(p) {\n        var sel = this.cm6.state.selection.main;\n        var offset = p == \"head\" || !p\n            ? sel.head\n            : p == \"anchor\"\n                ? sel.anchor\n                : p == \"start\"\n                    ? sel.from\n                    : p == \"end\"\n                        ? sel.to\n                        : null;\n        if (offset == null)\n            throw new Error(\"Invalid cursor type\");\n        return this.posFromIndex(offset);\n    }\n    ;\n    listSelections() {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.selection.ranges.map(r => {\n            return {\n                anchor: posFromIndex(doc, r.anchor),\n                head: posFromIndex(doc, r.head),\n            };\n        });\n    }\n    ;\n    setSelections(p, primIndex) {\n        var doc = this.cm6.state.doc;\n        var ranges = p.map(x => {\n            return EditorSelection.range(indexFromPos(doc, x.anchor), indexFromPos(doc, x.head));\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, primIndex)\n        });\n    }\n    ;\n    setSelection(anchor, head, options) {\n        var doc = this.cm6.state.doc;\n        var ranges = [EditorSelection.range(indexFromPos(doc, anchor), indexFromPos(doc, head))];\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, 0)\n        });\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    }\n    ;\n    getLine(row) {\n        var doc = this.cm6.state.doc;\n        if (row < 0 || row >= doc.lines)\n            return \"\";\n        return this.cm6.state.doc.line(row + 1).text;\n    }\n    ;\n    getLineHandle(row) {\n        return { text: this.getLine(row), row: row };\n    }\n    getLineNumber(handle) {\n        return handle.row;\n    }\n    getRange(s, e) {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.sliceDoc(indexFromPos(doc, s), indexFromPos(doc, e));\n    }\n    ;\n    replaceRange(text, s, e) {\n        if (!e)\n            e = s;\n        var doc = this.cm6.state.doc;\n        var from = indexFromPos(doc, s);\n        var to = indexFromPos(doc, e);\n        dispatchChange(this, { changes: { from, to, insert: text } });\n    }\n    ;\n    replaceSelection(text) {\n        dispatchChange(this, this.cm6.state.replaceSelection(text));\n    }\n    ;\n    replaceSelections(replacements) {\n        var ranges = this.cm6.state.selection.ranges;\n        var changes = ranges.map((r, i) => {\n            return { from: r.from, to: r.to, insert: replacements[i] || \"\" };\n        });\n        dispatchChange(this, { changes });\n    }\n    ;\n    getSelection() {\n        return this.getSelections().join(\"\\n\");\n    }\n    ;\n    getSelections() {\n        var cm = this.cm6;\n        return cm.state.selection.ranges.map(r => cm.state.sliceDoc(r.from, r.to));\n    }\n    ;\n    somethingSelected() {\n        return this.cm6.state.selection.ranges.some(r => !r.empty);\n    }\n    ;\n    getInputField() {\n        return this.cm6.contentDOM;\n    }\n    ;\n    clipPos(p) {\n        var doc = this.cm6.state.doc;\n        var ch = p.ch;\n        var lineNumber = p.line + 1;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            ch = 0;\n        }\n        if (lineNumber > doc.lines) {\n            lineNumber = doc.lines;\n            ch = Number.MAX_VALUE;\n        }\n        var line = doc.line(lineNumber);\n        ch = Math.min(Math.max(0, ch), line.to - line.from);\n        return new Pos(lineNumber - 1, ch);\n    }\n    ;\n    getValue() {\n        return this.cm6.state.doc.toString();\n    }\n    ;\n    setValue(text) {\n        var cm = this.cm6;\n        return cm.dispatch({\n            changes: { from: 0, to: cm.state.doc.length, insert: text },\n            selection: EditorSelection.range(0, 0)\n        });\n    }\n    ;\n    focus() {\n        return this.cm6.focus();\n    }\n    ;\n    blur() {\n        return this.cm6.contentDOM.blur();\n    }\n    ;\n    defaultTextHeight() {\n        return this.cm6.defaultLineHeight;\n    }\n    ;\n    findMatchingBracket(pos) {\n        var state = this.cm6.state;\n        var offset = indexFromPos(state.doc, pos);\n        var m = matchBrackets(state, offset + 1, -1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        m = matchBrackets(state, offset, 1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        return { to: undefined };\n    }\n    ;\n    scanForBracket(pos, dir, style, config) {\n        return scanForBracket(this, pos, dir, style, config);\n    }\n    ;\n    indentLine(line, more) {\n        // todo how to indent only one line instead of selection\n        if (more)\n            this.indentMore();\n        else\n            this.indentLess();\n    }\n    ;\n    indentMore() {\n        indentMore(this.cm6);\n    }\n    ;\n    indentLess() {\n        indentLess(this.cm6);\n    }\n    ;\n    execCommand(name) {\n        if (name == \"indentAuto\")\n            CodeMirror.commands.indentAuto(this);\n        else if (name == \"goLineLeft\")\n            cursorLineBoundaryBackward(this.cm6);\n        else if (name == \"goLineRight\") {\n            cursorLineBoundaryForward(this.cm6);\n            cursorCharBackward(this.cm6);\n        }\n        else\n            console.log(name + \" is not implemented\");\n    }\n    ;\n    setBookmark(cursor, options) {\n        var assoc = (options === null || options === void 0 ? void 0 : options.insertLeft) ? 1 : -1;\n        var offset = this.indexFromPos(cursor);\n        var bm = new Marker(this, offset, assoc);\n        return bm;\n    }\n    ;\n    addOverlay({ query }) {\n        let cm6Query = new SearchQuery({\n            regexp: true,\n            search: query.source,\n            caseSensitive: !/i/.test(query.flags),\n        });\n        if (cm6Query.valid) {\n            cm6Query.forVim = true;\n            this.cm6Query = cm6Query;\n            let effect = setSearchQuery.of(cm6Query);\n            this.cm6.dispatch({ effects: effect });\n            return cm6Query;\n        }\n    }\n    ;\n    removeOverlay(overlay) {\n        if (!this.cm6Query)\n            return;\n        this.cm6Query.forVim = false;\n        let effect = setSearchQuery.of(this.cm6Query);\n        this.cm6.dispatch({ effects: effect });\n    }\n    ;\n    getSearchCursor(query, pos) {\n        var cm = this;\n        var last = null;\n        var lastCM5Result = null;\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var firstOffset = indexFromPos(cm.cm6.state.doc, pos);\n        var source = query.source.replace(/(\\\\.|{(?:\\d+(?:,\\d*)?|,\\d+)})|[{}]/g, function (a, b) {\n            if (!b)\n                return \"\\\\\" + a;\n            return b;\n        });\n        function rCursor(doc, from = 0, to = doc.length) {\n            return new RegExpCursor(doc, source, { ignoreCase: query.ignoreCase }, from, to);\n        }\n        function nextMatch(from) {\n            var doc = cm.cm6.state.doc;\n            if (from > doc.length)\n                return null;\n            let res = rCursor(doc, from).next();\n            return res.done ? null : res.value;\n        }\n        var ChunkSize = 10000;\n        function prevMatchInRange(from, to) {\n            var doc = cm.cm6.state.doc;\n            for (let size = 1;; size++) {\n                let start = Math.max(from, to - size * ChunkSize);\n                let cursor = rCursor(doc, start, to), range = null;\n                while (!cursor.next().done)\n                    range = cursor.value;\n                if (range && (start == from || range.from > start + 10))\n                    return range;\n                if (start == from)\n                    return null;\n            }\n        }\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                var doc = cm.cm6.state.doc;\n                if (back) {\n                    let endAt = last ? (last.from == last.to ? last.to - 1 : last.from) : firstOffset;\n                    last = prevMatchInRange(0, endAt);\n                }\n                else {\n                    let startFrom = last ? (last.from == last.to ? last.to + 1 : last.to) : firstOffset;\n                    last = nextMatch(startFrom);\n                }\n                lastCM5Result = last && {\n                    from: posFromIndex(doc, last.from),\n                    to: posFromIndex(doc, last.to),\n                    match: last.match,\n                };\n                return last && last.match;\n            },\n            from: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from; },\n            to: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to; },\n            replace: function (text) {\n                if (last) {\n                    dispatchChange(cm, {\n                        changes: { from: last.from, to: last.to, insert: text }\n                    });\n                    last.to = last.from + text.length;\n                    if (lastCM5Result) {\n                        lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);\n                    }\n                }\n            }\n        };\n    }\n    ;\n    findPosV(start, amount, unit, goalColumn) {\n        let { cm6 } = this;\n        const doc = cm6.state.doc;\n        let pixels = unit == 'page' ? cm6.dom.clientHeight : 0;\n        const startOffset = indexFromPos(doc, start);\n        let range = EditorSelection.range(startOffset, startOffset, goalColumn);\n        let count = Math.round(Math.abs(amount));\n        for (let i = 0; i < count; i++) {\n            if (unit == 'page') {\n                range = cm6.moveVertically(range, amount > 0, pixels);\n            }\n            else if (unit == 'line') {\n                range = cm6.moveVertically(range, amount > 0);\n            }\n        }\n        let pos = posFromIndex(doc, range.head);\n        // set hitside to true if there was no place to move and cursor was clipped to the edge\n        // of document. Needed for gj/gk\n        if ((amount < 0 &&\n            range.head == 0 && goalColumn != 0 &&\n            start.line == 0 && start.ch != 0) || (amount > 0 &&\n            range.head == doc.length && pos.ch != goalColumn\n            && start.line == pos.line)) {\n            pos.hitSide = true;\n        }\n        return pos;\n    }\n    ;\n    charCoords(pos, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = indexFromPos(this.cm6.state.doc, pos);\n        var coords = this.cm6.coordsAtPos(offset);\n        var d = -rect.top;\n        return { left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left, top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d, bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d };\n    }\n    ;\n    coordsChar(coords, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = this.cm6.posAtCoords({ x: coords.left + rect.left, y: coords.top + rect.top }) || 0;\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    getScrollInfo() {\n        var scroller = this.cm6.scrollDOM;\n        return {\n            left: scroller.scrollLeft, top: scroller.scrollTop,\n            height: scroller.scrollHeight,\n            width: scroller.scrollWidth,\n            clientHeight: scroller.clientHeight, clientWidth: scroller.clientWidth\n        };\n    }\n    ;\n    scrollTo(x, y) {\n        if (x != null)\n            this.cm6.scrollDOM.scrollLeft = x;\n        if (y != null)\n            this.cm6.scrollDOM.scrollTop = y;\n    }\n    ;\n    scrollIntoView(pos, margin) {\n        if (pos) {\n            var offset = this.indexFromPos(pos);\n            this.cm6.dispatch({\n                effects: EditorView.scrollIntoView(offset)\n            });\n        }\n        else {\n            this.cm6.dispatch({ scrollIntoView: true, userEvent: \"scroll\" });\n        }\n    }\n    ;\n    getWrapperElement() {\n        return this.cm6.dom;\n    }\n    ;\n    // for tests\n    getMode() {\n        return { name: this.getOption(\"mode\") };\n    }\n    ;\n    setSize(w, h) {\n        this.cm6.dom.style.width = w + 4 + \"px\";\n        this.cm6.dom.style.height = h + \"px\";\n        this.refresh();\n    }\n    refresh() {\n        this.cm6.measure();\n    }\n    // event listeners\n    destroy() {\n        this.removeOverlay();\n    }\n    ;\n    onChange(update) {\n        for (let i in this.marks) {\n            let m = this.marks[i];\n            m.update(update.changes);\n        }\n        if (this.virtualSelection) {\n            this.virtualSelection.ranges = this.virtualSelection.ranges.map(range => range.map(update.changes));\n        }\n        var curOp = this.curOp = this.curOp || {};\n        update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n            if (curOp.$changeStart == null || curOp.$changeStart > fromB)\n                curOp.$changeStart = fromB;\n            this.$lastChangeEndOffset = toB;\n            var change = { text: text.toJSON() };\n            if (!curOp.lastChange) {\n                curOp.lastChange = curOp.change = change;\n            }\n            else {\n                curOp.lastChange.next = curOp.lastChange = change;\n            }\n        }, true);\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._handlers[\"change\"] && this._handlers[\"change\"].slice();\n    }\n    ;\n    onSelectionChange() {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._handlers[\"cursorActivity\"] && this._handlers[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n    }\n    ;\n    operation(fn) {\n        if (!this.curOp)\n            this.curOp = { $d: 0 };\n        this.curOp.$d++;\n        try {\n            var result = fn();\n        }\n        finally {\n            if (this.curOp) {\n                this.curOp.$d--;\n                if (!this.curOp.$d)\n                    this.onBeforeEndOperation();\n            }\n        }\n        return result;\n    }\n    ;\n    onBeforeEndOperation() {\n        var op = this.curOp;\n        var scrollIntoView = false;\n        if (op) {\n            if (op.change) {\n                signalTo(op.changeHandlers, this, op.change);\n            }\n            if (op && op.cursorActivity) {\n                signalTo(op.cursorActivityHandlers, this, null);\n                if (op.isVimOp)\n                    scrollIntoView = true;\n            }\n            this.curOp = null;\n        }\n        if (scrollIntoView)\n            this.scrollIntoView();\n    }\n    ;\n    moveH(increment, unit) {\n        if (unit == 'char') {\n            // todo\n            var cur = this.getCursor();\n            this.setCursor(cur.line, cur.ch + increment);\n        }\n    }\n    ;\n    setOption(name, val) {\n        switch (name) {\n            case \"keyMap\":\n                this.state.keyMap = val;\n                break;\n        }\n    }\n    ;\n    getOption(name) {\n        switch (name) {\n            case \"firstLineNumber\": return 1;\n            case \"tabSize\": return this.cm6.state.tabSize || 4;\n            case \"readonly\": return this.cm6.state.readOnly;\n            case \"indentWithTabs\": return this.cm6.state.facet(indentUnit) == \"\\t\"; // TODO\n            case \"indentUnit\": return this.cm6.state.facet(indentUnit).length || 2;\n            // for tests\n            case \"keyMap\": return this.state.keyMap || \"vim\";\n        }\n    }\n    ;\n    toggleOverwrite(on) {\n        this.state.overwrite = on;\n    }\n    ;\n    getTokenTypeAt(pos) {\n        var _a;\n        // only comment|string are needed\n        var offset = this.indexFromPos(pos);\n        var tree = ensureSyntaxTree(this.cm6.state, offset);\n        var node = tree === null || tree === void 0 ? void 0 : tree.resolve(offset);\n        var type = ((_a = node === null || node === void 0 ? void 0 : node.type) === null || _a === void 0 ? void 0 : _a.name) || \"\";\n        if (/comment/i.test(type))\n            return \"comment\";\n        if (/string/i.test(type))\n            return \"string\";\n        return \"\";\n    }\n    ;\n    overWriteSelection(text) {\n        var doc = this.cm6.state.doc;\n        var sel = this.cm6.state.selection;\n        var ranges = sel.ranges.map(x => {\n            if (x.empty) {\n                var ch = x.to < doc.length ? doc.sliceString(x.from, x.to + 1) : \"\";\n                if (ch && !/\\n/.test(ch))\n                    return EditorSelection.range(x.from, x.to + 1);\n            }\n            return x;\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, sel.mainIndex)\n        });\n        this.replaceSelection(text);\n    }\n    /*** multiselect ****/\n    isInMultiSelectMode() {\n        return this.cm6.state.selection.ranges.length > 1;\n    }\n    virtualSelectionMode() {\n        return !!this.virtualSelection;\n    }\n    forEachSelection(command) {\n        var selection = this.cm6.state.selection;\n        this.virtualSelection = EditorSelection.create(selection.ranges, selection.mainIndex);\n        for (var i = 0; i < this.virtualSelection.ranges.length; i++) {\n            var range = this.virtualSelection.ranges[i];\n            if (!range)\n                continue;\n            this.cm6.dispatch({ selection: EditorSelection.create([range]) });\n            command();\n            this.virtualSelection.ranges[i] = this.cm6.state.selection.ranges[0];\n        }\n        this.cm6.dispatch({ selection: this.virtualSelection });\n        this.virtualSelection = null;\n    }\n}\n// --------------------------\nCodeMirror.Pos = Pos;\nCodeMirror.StringStream = StringStream;\nCodeMirror.commands = {\n    cursorCharLeft: function (cm) { cursorCharLeft(cm.cm6); },\n    redo: function (cm) { runHistoryCommand(cm, false); },\n    undo: function (cm) { runHistoryCommand(cm, true); },\n    newlineAndIndent: function (cm) {\n        insertNewlineAndIndent({\n            state: cm.cm6.state,\n            dispatch: (tr) => {\n                return dispatchChange(cm, tr);\n            }\n        });\n    },\n    indentAuto: function (cm) {\n        indentSelection(cm.cm6);\n    }\n};\nCodeMirror.defineOption = function (name, val, setter) { };\nCodeMirror.isWordChar = function (ch) {\n    return wordChar.test(ch);\n};\nCodeMirror.keys = {\n    Backspace: function (cm) {\n        deleteCharBackward(cm.cm6);\n    },\n    Delete: function (cm) {\n        deleteCharForward(cm.cm6);\n    }\n};\nCodeMirror.keyMap = {};\nCodeMirror.addClass = function () { };\nCodeMirror.rmClass = function () { };\nCodeMirror.e_preventDefault = function (e) {\n    e.preventDefault();\n};\nCodeMirror.e_stop = function (e) {\n    var _a, _b;\n    (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);\n    (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);\n};\nCodeMirror.keyName = function (e) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key == \"Escape\")\n        key = \"Esc\";\n    if (key == \" \")\n        key = \"Space\";\n    if (key.length > 1) {\n        key = key.replace(/Numpad|Arrow/, \"\");\n    }\n    if (key.length == 1)\n        key = key.toUpperCase();\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'Ctrl-';\n    }\n    if (e.altKey) {\n        name += 'Alt-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'Shift-';\n    }\n    name += key;\n    return name;\n};\nCodeMirror.vimKey = function vimKey(e) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if (e.metaKey) {\n        name += 'M-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    var result = CodeMirror.keys[key];\n    if (result)\n        handle(result);\n};\nCodeMirror.on = on;\nCodeMirror.off = off;\nCodeMirror.signal = signal;\nCodeMirror.findMatchingTag = findMatchingTag;\nCodeMirror.findEnclosingTag = findEnclosingTag;\n/************* dialog *************/\nfunction dialogDiv(cm, template, bottom) {\n    var dialog = document.createElement(\"div\");\n    dialog.appendChild(template);\n    return dialog;\n}\nfunction closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n        cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n}\nfunction openNotification(cm, template, options) {\n    closeNotification(cm, close);\n    var dialog = dialogDiv(cm, template, options && options.bottom);\n    var closed = false;\n    var doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n    function close() {\n        if (closed)\n            return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n        hideDialog(cm, dialog);\n    }\n    dialog.onclick = function (e) {\n        e.preventDefault();\n        close();\n    };\n    showDialog(cm, dialog);\n    if (duration)\n        doneTimer = setTimeout(close, duration);\n    return close;\n}\nfunction showDialog(cm, dialog) {\n    var oldDialog = cm.state.dialog;\n    cm.state.dialog = dialog;\n    if (dialog && oldDialog !== dialog) {\n        if (oldDialog && oldDialog.contains(document.activeElement))\n            cm.focus();\n        if (oldDialog && oldDialog.parentElement) {\n            oldDialog.parentElement.replaceChild(dialog, oldDialog);\n        }\n        else if (oldDialog) {\n            oldDialog.remove();\n        }\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction hideDialog(cm, dialog) {\n    if (cm.state.dialog == dialog) {\n        cm.state.dialog = null;\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction openDialog(me, template, callback, options) {\n    if (!options)\n        options = {};\n    closeNotification(me, undefined);\n    var dialog = dialogDiv(me, template, options.bottom);\n    var closed = false;\n    showDialog(me, dialog);\n    function close(newVal) {\n        if (typeof newVal == 'string') {\n            inp.value = newVal;\n        }\n        else {\n            if (closed)\n                return;\n            closed = true;\n            hideDialog(me, dialog);\n            if (!me.state.dialog)\n                me.focus();\n            if (options.onClose)\n                options.onClose(dialog);\n        }\n    }\n    var inp = dialog.getElementsByTagName(\"input\")[0];\n    if (inp) {\n        if (options.value) {\n            inp.value = options.value;\n            if (options.selectValueOnOpen !== false)\n                inp.select();\n        }\n        if (options.onInput)\n            CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n        if (options.onKeyUp)\n            CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                return;\n            }\n            if (e.keyCode == 13)\n                callback(inp.value);\n            if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                inp.blur();\n                CodeMirror.e_stop(e);\n                close();\n            }\n        });\n        if (options.closeOnBlur !== false)\n            CodeMirror.on(inp, \"blur\", function () {\n                setTimeout(function () {\n                    if (document.activeElement === inp)\n                        return;\n                    close();\n                });\n            });\n        inp.focus();\n    }\n    return close;\n}\nvar matching = { \"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\" };\nfunction bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/;\n}\nfunction scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n    var stack = [];\n    var re = bracketRegex(config);\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n        : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n            continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n            continue;\n        if (lineNo == where.line)\n            pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end; pos += dir) {\n            var ch = line.charAt(pos);\n            if (re.test(ch) /*&& (style === undefined ||\n                                (cm.getTokenTypeAt(new Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))*/) {\n                var match = matching[ch];\n                if (match && (match.charAt(1) == \">\") == (dir > 0))\n                    stack.push(ch);\n                else if (!stack.length)\n                    return { pos: new Pos(lineNo, pos), ch: ch };\n                else\n                    stack.pop();\n            }\n        }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n}\nfunction findMatchingTag(cm, pos) {\n    var state = cm.cm6.state;\n    var offset = cm.indexFromPos(pos);\n    var m = matchBrackets(state, offset + 1, -1, { brackets: \"\\n\\n\" });\n    if (m) {\n        if (!m.end || !m.start)\n            return;\n        return {\n            open: convertRange(state.doc, m.end),\n            close: convertRange(state.doc, m.start),\n        };\n    }\n    m = matchBrackets(state, offset, 1, { brackets: \"\\n\\n\" });\n    if (m) {\n        if (!m.end || !m.start)\n            return;\n        return {\n            open: convertRange(state.doc, m.start),\n            close: convertRange(state.doc, m.end),\n        };\n    }\n}\nfunction convertRange(doc, cm6Range) {\n    return {\n        from: posFromIndex(doc, cm6Range.from),\n        to: posFromIndex(doc, cm6Range.to)\n    };\n}\nfunction findEnclosingTag(cm, pos) {\n    var state = cm.cm6.state;\n    var offset = cm.indexFromPos(pos);\n    var text = state.sliceDoc(0, offset);\n    var i = offset;\n    while (i > 0) {\n        var m = matchBrackets(state, i, 1, { brackets: \"\\n\\n\" });\n        if (m && m.start && m.end) {\n            return {\n                open: convertRange(state.doc, m.start),\n                close: convertRange(state.doc, m.end),\n            };\n        }\n        i = text.lastIndexOf(\">\", i - 1);\n    }\n}\nclass Marker {\n    constructor(cm, offset, assoc) {\n        this.cm = cm;\n        this.id = cm.$mid++;\n        this.offset = offset;\n        this.assoc = assoc;\n        cm.marks[this.id] = this;\n    }\n    ;\n    clear() { delete this.cm.marks[this.id]; }\n    ;\n    find() {\n        if (this.offset == null)\n            return null;\n        return this.cm.posFromIndex(this.offset);\n    }\n    ;\n    update(change) {\n        if (this.offset != null)\n            this.offset = change.mapPos(this.offset, this.assoc, MapMode.TrackDel);\n    }\n}\n\nclass Piece {\n    constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {\n        this.left = left;\n        this.top = top;\n        this.height = height;\n        this.fontFamily = fontFamily;\n        this.fontSize = fontSize;\n        this.fontWeight = fontWeight;\n        this.color = color;\n        this.className = className;\n        this.letter = letter;\n        this.partial = partial;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        elt.style.height = this.height + \"px\";\n        elt.style.lineHeight = this.height + \"px\";\n        elt.style.fontFamily = this.fontFamily;\n        elt.style.fontSize = this.fontSize;\n        elt.style.fontWeight = this.fontWeight;\n        elt.style.color = this.partial ? \"transparent\" : this.color;\n        elt.className = this.className;\n        elt.textContent = this.letter;\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.height == p.height &&\n            this.fontFamily == p.fontFamily && this.fontSize == p.fontSize &&\n            this.fontWeight == p.fontWeight && this.color == p.color &&\n            this.className == p.className &&\n            this.letter == p.letter;\n    }\n}\nclass BlockCursorPlugin {\n    constructor(view, cm) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.cm = cm;\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = \"cm-cursorLayer cm-vimCursorLayer\";\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        this.cursorLayer.style.animationDuration = 1200 + \"ms\";\n    }\n    update(update) {\n        if (update.selectionSet || update.geometryChanged || update.viewportChanged) {\n            this.view.requestMeasure(this.measureReq);\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        }\n    }\n    scheduleRedraw() {\n        this.view.requestMeasure(this.measureReq);\n    }\n    readPos() {\n        let { state } = this.view;\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            let piece = measureCursor(this.cm, this.view, r, prim);\n            if (piece)\n                cursors.push(piece);\n        }\n        return { cursors };\n    }\n    drawSel({ cursors }) {\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            let oldCursors = this.cursorLayer.children;\n            if (oldCursors.length !== cursors.length) {\n                this.cursorLayer.textContent = \"\";\n                for (const c of cursors)\n                    this.cursorLayer.appendChild(c.draw());\n            }\n            else {\n                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n            }\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.cursorLayer.remove();\n    }\n}\nconst themeSpec = {\n    \".cm-vimMode .cm-line\": {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" },\n        caretColor: \"transparent !important\",\n    },\n    \".cm-fat-cursor\": {\n        position: \"absolute\",\n        background: \"#ff9696\",\n        border: \"none\",\n        whiteSpace: \"pre\",\n    },\n    \"&:not(.cm-focused) .cm-fat-cursor\": {\n        background: \"none\",\n        outline: \"solid 1px #ff9696\"\n    },\n};\nconst hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\n}\nfunction measureCursor(cm, view, cursor, primary) {\n    let head = cursor.head;\n    let fatCursor = false;\n    let hCoeff = 1;\n    let vim = cm.state.vim;\n    if (vim && (!vim.insertMode || cm.state.overwrite)) {\n        fatCursor = true;\n        if (vim.visualBlock && !primary)\n            return null;\n        if (cursor.anchor < cursor.head)\n            head--;\n        if (cm.state.overwrite)\n            hCoeff = 0.2;\n        else if (vim.status)\n            hCoeff = 0.5;\n    }\n    if (fatCursor) {\n        let pos = view.coordsAtPos(head, cursor.assoc || 1);\n        if (!pos)\n            return null;\n        let base = getBase(view);\n        let domAtPos = view.domAtPos(head);\n        let node = domAtPos ? domAtPos.node : view.contentDOM;\n        while (domAtPos && domAtPos.node instanceof HTMLElement) {\n            node = domAtPos.node;\n            domAtPos = { node: domAtPos.node.childNodes[domAtPos.offset], offset: 0 };\n        }\n        if (!(node instanceof HTMLElement)) {\n            node = node.parentNode;\n        }\n        let style = getComputedStyle(node);\n        let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);\n        if (!letter || letter == \"\\n\" || letter == \"\\r\")\n            letter = \"\\xa0\";\n        let h = (pos.bottom - pos.top);\n        return new Piece(pos.left - base.left, pos.top - base.top + h * (1 - hCoeff), h * hCoeff, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? \"cm-fat-cursor cm-cursor-primary\" : \"cm-fat-cursor cm-cursor-secondary\", letter, hCoeff != 1);\n    }\n    else {\n        return null;\n    }\n}\n\nconst Vim = /*@__PURE__*/initVim(CodeMirror);\nconst HighlightMargin = 250;\nconst vimStyle = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)\": {\n        display: \"none\",\n    },\n    \".cm-vim-panel\": {\n        padding: \"0px 10px\",\n        fontFamily: \"monospace\",\n        minHeight: \"1.3em\",\n    },\n    \".cm-vim-panel input\": {\n        border: \"none\",\n        outline: \"none\",\n        backgroundColor: \"inherit\",\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n});\nconst vimPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.status = \"\";\n        this.query = null;\n        this.decorations = Decoration.none;\n        this.view = view;\n        const cm = (this.cm = new CodeMirror(view));\n        Vim.enterVimMode(this.cm);\n        this.view.cm = this.cm;\n        this.cm.state.vimPlugin = this;\n        this.blockCursor = new BlockCursorPlugin(view, cm);\n        this.updateClass();\n        this.cm.on(\"vim-command-done\", () => {\n            if (cm.state.vim)\n                cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateStatus();\n        });\n        this.cm.on(\"vim-mode-change\", (e) => {\n            cm.state.vim.mode = e.mode;\n            if (e.subMode) {\n                cm.state.vim.mode += \" block\";\n            }\n            cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateClass();\n            this.updateStatus();\n        });\n        this.cm.on(\"dialog\", () => {\n            if (this.cm.state.statusbar) {\n                this.updateStatus();\n            }\n            else {\n                view.dispatch({\n                    effects: showVimPanel.of(!!this.cm.state.dialog),\n                });\n            }\n        });\n        this.dom = document.createElement(\"span\");\n        this.dom.style.cssText = \"position: absolute; right: 10px; top: 1px\";\n    }\n    update(update) {\n        var _a;\n        if ((update.viewportChanged || update.docChanged) && this.query) {\n            this.highlight(this.query);\n        }\n        if (update.docChanged) {\n            this.cm.onChange(update);\n        }\n        if (update.selectionSet) {\n            this.cm.onSelectionChange();\n        }\n        if (update.viewportChanged) ;\n        if (this.cm.curOp && !this.cm.curOp.isVimOp) {\n            this.cm.onBeforeEndOperation();\n        }\n        if (update.transactions) {\n            for (let tr of update.transactions)\n                for (let effect of tr.effects) {\n                    if (effect.is(setSearchQuery)) {\n                        let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;\n                        if (!forVim) {\n                            this.highlight(null);\n                        }\n                        else {\n                            let query = effect.value.create();\n                            this.highlight(query);\n                        }\n                    }\n                }\n        }\n        this.blockCursor.update(update);\n    }\n    updateClass() {\n        const state = this.cm.state;\n        if (!state.vim || (state.vim.insertMode && !state.overwrite))\n            this.view.scrollDOM.classList.remove(\"cm-vimMode\");\n        else\n            this.view.scrollDOM.classList.add(\"cm-vimMode\");\n    }\n    updateStatus() {\n        let dom = this.cm.state.statusbar;\n        let vim = this.cm.state.vim;\n        if (!dom || !vim)\n            return;\n        let dialog = this.cm.state.dialog;\n        if (dialog) {\n            if (dialog.parentElement != dom) {\n                dom.textContent = \"\";\n                dom.appendChild(dialog);\n            }\n        }\n        else {\n            dom.textContent = `--${(vim.mode || \"normal\").toUpperCase()}--`;\n        }\n        this.dom.textContent = vim.status;\n        dom.appendChild(this.dom);\n    }\n    destroy() {\n        Vim.leaveVimMode(this.cm);\n        this.updateClass();\n        this.blockCursor.destroy();\n        delete this.view.cm;\n    }\n    highlight(query) {\n        this.query = query;\n        if (!query)\n            return (this.decorations = Decoration.none);\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * HighlightMargin)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                builder.add(from, to, matchMark);\n            });\n        }\n        return (this.decorations = builder.finish());\n    }\n}, {\n    eventHandlers: {\n        keydown: function (e, view) {\n            const key = CodeMirror.vimKey(e);\n            const cm = this.cm;\n            if (!key)\n                return;\n            let vim = cm.state.vim;\n            if (!vim)\n                return;\n            // clear search highlight\n            if (key == \"<Esc>\" &&\n                !vim.insertMode &&\n                !vim.visualMode &&\n                this.query /* && !cm.inMultiSelectMode*/) {\n                const searchState = vim.searchState_;\n                if (searchState) {\n                    cm.removeOverlay(searchState.getOverlay());\n                    searchState.setOverlay(null);\n                }\n            }\n            vim.status = (vim.status || \"\") + key;\n            let result = Vim.multiSelectHandleKey(cm, key, \"user\");\n            vim = cm.state.vim; // the object can change if there is an exception in handleKey\n            // insert mode\n            if (!result && vim.insertMode && cm.state.overwrite) {\n                if (e.key && e.key.length == 1 && !/\\n/.test(e.key)) {\n                    result = true;\n                    cm.overWriteSelection(e.key);\n                }\n                else if (e.key == \"Backspace\") {\n                    result = true;\n                    CodeMirror.commands.cursorCharLeft(cm);\n                }\n            }\n            if (result) {\n                CodeMirror.signal(this.cm, 'vim-keypress', key);\n                e.preventDefault();\n                e.stopPropagation();\n                this.blockCursor.scheduleRedraw();\n            }\n            this.updateStatus();\n            return !!result;\n        },\n    },\n    decorations: (v) => v.decorations,\n});\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" });\nconst showVimPanel = /*@__PURE__*/StateEffect.define();\nconst vimPanelState = /*@__PURE__*/StateField.define({\n    create: () => false,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(showVimPanel))\n                value = e.value;\n        return value;\n    },\n    provide: (f) => {\n        return showPanel.from(f, (on) => (on ? createVimPanel : null));\n    },\n});\nfunction createVimPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    if (cm.state.dialog) {\n        dom.appendChild(cm.state.dialog);\n    }\n    return { top: false, dom };\n}\nfunction statusPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    cm.state.statusbar = dom;\n    cm.state.vimPlugin.updateStatus();\n    return { dom };\n}\nfunction vim(options = {}) {\n    return [\n        vimStyle,\n        vimPlugin,\n        hideNativeSelection,\n        options.status ? showPanel.of(statusPanel) : vimPanelState,\n    ];\n}\nfunction getCM(view) {\n    return view.cm || null;\n}\n\nexport { CodeMirror, Vim, getCM, vim };\n"],
  "mappings": "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",
  "names": ["EditorSelection", "MapMode", "Prec", "RangeSetBuilder", "StateEffect", "StateField", "foldCode", "matchBrackets", "indentUnit", "ensureSyntaxTree", "StringStream", "EditorView", "Direction", "ViewPlugin", "Decoration", "showPanel", "SearchQuery", "setSearchQuery", "RegExpCursor", "indentMore", "indentLess", "cursorLineBoundaryBackward", "cursorLineBoundaryForward", "cursorCharBackward", "cursorCharLeft", "insertNewlineAndIndent", "indentSelection", "deleteCharBackward", "deleteCharForward", "undo", "redo", "initVim", "CodeMirror", "Pos", "transformCursor", "cm", "range", "vim", "head", "defaultKeymap", "defaultKeymapLength", "defaultExCommandMap", "enterVimMode", "onCursorActivity", "maybeInitVimState", "getOnPasteFn", "leaveVimMode", "highlightTimeout", "detachVimMap", "next", "attachVimMap", "prev", "val", "cmKey", "key", "vimKey", "cmKeyToVimKey", "cmd", "vimApi", "modifiers", "specialKeys", "pieces", "lastPiece", "hasCharacter", "piece", "isUpperCase", "offsetCursor", "actions", "numberRegex", "wordCharTest", "ch", "bigWordCharTest", "makeKeyRange", "start", "size", "keys", "i", "upperCaseAlphabet", "lowerCaseAlphabet", "numbers", "validMarks", "validRegisters", "upperCaseChars", "isLine", "line", "isLowerCase", "k", "isMatchableSymbol", "isNumber", "isWhiteSpaceString", "isEndOfSentenceSymbol", "inArray", "arr", "options", "defineOption", "name", "defaultValue", "type", "aliases", "callback", "setOption", "value", "cfg", "option", "scope", "getOption", "local", "mode", "createCircularJumpList", "pointer", "tail", "buffer", "add", "oldCur", "newCur", "current", "curMark", "useNextSlot", "cursor", "trashMark", "markPos", "cursorEqual", "move", "offset", "mark", "inc", "find", "oldPointer", "createInsertModeChanges", "c", "MacroModeState", "macroModeState", "vimGlobalState", "registerName", "register", "template", "dom", "InputState", "resetVimGlobalState", "RegisterController", "HistoryController", "optionName", "lastInsertModeKeyTimer", "InsertModeKey", "lhs", "rhs", "ctx", "exCommandDispatcher", "toCtxArray", "ctxsToMap", "actualLength", "origLength", "mapping", "newMapping", "mappedCtxs", "el", "userKeymap", "contexts", "j", "prefix", "func", "exCommands", "origin", "command", "multiSelectHandleKey", "handleMacroRecording", "clearInputState", "logKey", "handleEsc", "exitVisualMode", "exitInsertMode", "doKeyToKey", "match", "handleKeyInsertMode", "keysAreChars", "commandDispatcher", "thisMatch", "selections", "here", "handleKeyNonInsertMode", "keysMatcher", "context", "mainKey", "e", "input", "defineMotion", "defineAction", "defineOperator", "mapCommand", "_mapCommand", "defineRegister", "n", "repeat", "reason", "Register", "text", "linewise", "blockwise", "changes", "query", "registers", "operator", "append", "up", "historyBuffer", "dir", "element", "index", "keyMap", "inputState", "matches", "commandMatches", "bestMatch", "character", "lastChar", "copyArgs", "updateCmSelection", "visualMode", "operatorMotionArgs", "repeatIsExplicit", "actionArgs", "forward", "wholeWordOnly", "getSearchState", "promptPrefix", "originalQuery", "originalScrollPos", "handleQuery", "ignoreCase", "smartCase", "updateSearchQuery", "showConfirm", "onPromptClose", "logSearchQuery", "onPromptKeyUp", "close", "keyName", "parsedQuery", "findNext", "clearSearchHighlight", "onPromptKeyDown", "showPrompt", "word", "expandWordUnderCursor", "isKeyword", "escapeRegex", "motion", "motionArgs", "operatorArgs", "sel", "origHead", "copyCursor", "clipCursorToContent", "origAnchor", "oldHead", "oldAnchor", "newHead", "newAnchor", "motionResult", "motions", "jumpList", "cachedCursor", "recordJumpPosition", "updateMark", "cursorIsBefore", "lastSel", "lineOffset", "chOffset", "curStart", "curEnd", "cmSel", "cursorMin", "cursorMax", "makeCmSelection", "ranges", "lineLength", "tmp", "expandSelectionToLine", "clipToLine", "exclusive", "operatorMoveTo", "operators", "actionCommand", "_head", "getUserVisibleLines", "findFirstNonWhiteSpaceCharacter", "_cm", "cur", "state", "highlightSearchMatches", "prevInputState", "findNextFromAndToInclusive", "from", "to", "anchor", "pos", "getMarkPos", "best", "isWrongDirection", "equal", "between", "cursorIsBetween", "endCh", "first", "last", "posV", "hasMarkedText", "moveToEol", "res", "lastCharCoords", "goalCoords", "resCoords", "findParagraph", "findSentence", "scrollbox", "orig", "dest", "moveToWord", "moveToCharacter", "increment", "recordLastCharacterSearch", "findSymbol", "moveToColumn", "lineText", "symbol", "style", "re", "matched", "lineNum", "mirroredPairs", "selfPaired", "inclusive", "selectCompanionObject", "findBeginningAndEnd", "expandTagUnderCursor", "content", "end", "getSentence", "expandSelection", "lastSearch", "fn", "fillArray", "times", "args", "finalHead", "replacement", "lastState", "prevLineEnd", "wasLastLine", "startLine", "endLine", "_args", "swapped", "toLower", "toSwap", "endPos", "lineHeight", "top", "delta", "newPos", "cursorCoords", "newBottom", "charCoords", "height", "y", "lineLastCharPos", "lineLastCharCoords", "executeMacroRegister", "insertAt", "getLastEditPos", "onChange", "onKeyEventTargetKeyDown", "selectForInsert", "_actionArgs", "lastSelection", "updateLastSelection", "finalCh", "curFinalPos", "newlineFn", "tabSize", "whitespaceLength", "str", "tabs", "spaces", "currentLine", "indent", "chompedText", "wasChomped", "firstIndent", "wspace", "newIndent", "quotient", "curPosFinal", "idx", "lastSelectionCurEnd", "selectedArea", "getSelectedAreaRange", "selectionStart", "selectionEnd", "selectedText", "emptyStrings", "selectBlock", "lastCh", "extendLineToColumn", "repeatFn", "markName", "replaceWith", "replaceTo", "replaceWithStr", "lineStr", "numberStr", "baseStr", "digits", "base", "number", "zeroPadding", "lastEditInputState", "repeatLastEdit", "includeLineBreak", "maxCh", "ret", "prop", "offsetLine", "offsetCh", "partial", "full", "commandMatch", "pressed", "mapped", "prefixLen", "pressedPrefix", "mappedPrefix", "selectedCharacter", "cur1", "cur2", "cur3", "cur1before2", "cur2before3", "trim", "s", "column", "isClipped", "curHead", "primIndex", "getIndex", "wasClipped", "max", "firstLine", "lastLine", "baseCh", "headCh", "newDir", "lineHead", "atAnchor", "atHead", "getCurrentSelectedAreaRange", "getLastSelectedAreaRange", "block", "width", "headOffset", "anchorOffset", "fromCh", "bottom", "toCh", "primary", "getHead", "moveHead", "selection", "lines", "firstNonWS", "_forward", "bigWord", "noSymbol", "test", "wordEnd", "wordStart", "tags", "symbolToMode", "findSymbolModes", "found", "token", "symb", "curCh", "init", "isComplete", "lineLen", "findWord", "emptyLineIsWord", "charTests", "stop", "foundWord", "words", "eodCh", "shortCircuit", "firstWord", "lastWord", "keepHPos", "retval", "charIdxInLine", "includeChar", "min", "isEmpty", "isBoundary", "any", "startState", "nextChar", "curr", "ln", "lastSentencePos", "reverse", "curr_index", "last_valid", "skip_empty_lines", "bracketRegexp", "openSym", "curChar", "chars", "len", "firstIndex", "SearchState", "overlay", "reversed", "annotate", "splitBySlash", "argString", "splitBySeparator", "findUnescapedSlashes", "findUnescapedSeparators", "separator", "slashes", "tokens", "escapeNextChar", "translateRegex", "specials", "unescape", "out", "specialComesNext", "charUnescapes", "translateRegexReplace", "unescapes", "unescapeRegexReplace", "stream", "output", "matcher", "parseQuery", "lastSearchRegister", "regexPart", "forceIgnoreCase", "flagsPart", "regexp", "a", "pre", "makePrompt", "desc", "shortText", "regexEqual", "r1", "r2", "props", "rawQuery", "searchOverlay", "matchSol", "searchState", "lastEndPos", "isInRange", "scrollInfo", "occludeToleranceTop", "occludeToleranceBottom", "bottomY", "done", "ExCommandDispatcher", "opt_params", "that", "commandHistoryRegister", "previousCommand", "inputStream", "params", "commandName", "result", "numberMatch", "offsetMatch", "delim", "mapArgs", "setArgs", "setCfg", "expr", "forceGet", "optionIsBoolean", "oldValue", "setOptionReturn", "regArgs", "regInfo", "unique", "pattern", "parseArgs", "opts", "decimal", "hex", "octal", "err", "lineStart", "lineEnd", "radix", "numPart", "textPart", "matchPart", "compareFn", "b", "anum", "bnum", "comparePatternFn", "textOld", "inverted", "matchedLines", "nextCommand", "replacePart", "trailing", "count", "confirm", "global", "startPos", "doReplace", "sym", "startMark", "finishMark", "finish", "searchCursor", "lastPos", "modifiedLineNumber", "joined", "replaceAll", "replace", "newText", "unmodifiedLineNumber", "findNextValidMatch", "lastMatchTo", "_value", "savedCallback", "insertModeChangeRegister", "isPlaying", "lastChange", "logInsertModeChange", "extra", "keyBuffer", "imc", "repeatInsertModeChanges", "changeObj", "selectionCount", "handleExternalSelection", "onKeyFound", "repeatForInsert", "isAction", "cachedInputState", "repeatCommand", "repeatInsert", "changeObject", "keyHandler", "binding", "visualBlock", "change", "cloneVimState", "o", "isHandled", "wasMultiselect", "old", "indexFromPos", "doc", "lineNumber", "posFromIndex", "on", "emitter", "map", "off", "signal", "_a", "handlers", "signalTo", "specialKey", "ignoredKeys", "wordChar", "dispatchChange", "transaction", "view", "note", "runHistoryCommand", "revert", "changeStartIndex", "cm6", "openDialog", "openNotification", "tmpRanges", "p", "r", "x", "row", "handle", "replacements", "m", "config", "scanForBracket", "more", "assoc", "bm", "Marker", "cm6Query", "effect", "lastCM5Result", "firstOffset", "source", "rCursor", "nextMatch", "ChunkSize", "prevMatchInRange", "back", "endAt", "startFrom", "amount", "unit", "goalColumn", "pixels", "startOffset", "rect", "coords", "d", "scroller", "margin", "w", "h", "update", "curOp", "fromA", "toA", "fromB", "toB", "op", "scrollIntoView", "tree", "node", "tr", "setter", "_b", "findMatchingTag", "findEnclosingTag", "dialogDiv", "dialog", "closeNotification", "newVal", "closed", "doneTimer", "duration", "hideDialog", "showDialog", "oldDialog", "me", "inp", "matching", "bracketRegex", "where", "maxScanLen", "maxScanLines", "stack", "lineNo", "convertRange", "cm6Range", "Piece", "left", "fontFamily", "fontSize", "fontWeight", "color", "className", "letter", "elt", "BlockCursorPlugin", "cursors", "prim", "measureCursor", "oldCursors", "themeSpec", "hideNativeSelection", "getBase", "fatCursor", "hCoeff", "domAtPos", "Vim", "HighlightMargin", "vimStyle", "vimPlugin", "showVimPanel", "builder", "l", "matchMark", "v", "vimPanelState", "f", "createVimPanel", "statusPanel"]
}
